import{_ as t,V as o,W as l,X as a,Z as n,Y as c,a0 as s,D as i}from"./framework-5dde3bca.js";const p="/assets/image-20220414103954905-5fcdc185.png",r={},u=s(`<h1 id="java-线程池" tabindex="-1"><a class="header-anchor" href="#java-线程池" aria-hidden="true">#</a> Java 线程池</h1><h3 id="java中的线程池" tabindex="-1"><a class="header-anchor" href="#java中的线程池" aria-hidden="true">#</a> Java中的线程池</h3><p>在开发的过程中，合理的使用线程池能够带来三个好处。</p><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程可管理性：线程是稀缺的资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ul><h4 id="threadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor" aria-hidden="true">#</a> ThreadPoolExecutor</h4><p>ThreadPoolExecutor是Java对线程池的一个具体实现。</p><h5 id="线程池状态" tabindex="-1"><a class="header-anchor" href="#线程池状态" aria-hidden="true">#</a> 线程池状态</h5><p>主要分为5种状态</p><table><thead><tr><th>线程池状态</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>允许提交并处理任务</td></tr><tr><td>SHUTDOWN</td><td>不允许提交新任务，但是会处理完已提交的任务</td></tr><tr><td>STOP</td><td>不允许提交新任务，也不会处理阻塞队里中未执行的任务<br>并设置正在执行的线程的中断标志位</td></tr><tr><td>TIDYING</td><td>所有任务执行完毕，池中工作线程数为0，等待执行terminated()钩子方法</td></tr><tr><td>TERMINATED</td><td>terminated()钩子方法执行完毕</td></tr></tbody></table><ul><li>线程池的shutdown()方法，将线程池有RUNNING转换为SHUTDOWN状态</li><li>线程池的shutdownNow()方法将线程池由RUNNING状态或SHUTDOWN状态转换为STOP状态</li></ul><p>注：SHUTDOWN状态和STOP状态先会转换为TIDYING状态转换为STOP状态</p><h5 id="创建线程池" tabindex="-1"><a class="header-anchor" href="#创建线程池" aria-hidden="true">#</a> 创建线程池</h5><p>要创建线程池，必须通过构造函数来进行创建，下面众多构造函数中参数最全的一个：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//核心线程数</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//最大线程数</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//线程空闲时间</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//时间单位</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//任务队列</span>
                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//线程工厂</span>
                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">//拒绝策略) </span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>corePoolSize：线程池中核心线程数的最大值</li><li>maximumPoolSize：线程池中能拥有最多线程数</li><li>keepAliveTime：表示空闲线程的存活时间</li><li>unit：表示keepAliveTime的时间单位</li><li>workQueue：用于缓存任务的缓冲队列，它决定了缓存任务的排队策略</li><li>handler： 线程池对拒绝任务的处理策略</li></ul><h5 id="线程池的工作原理" tabindex="-1"><a class="header-anchor" href="#线程池的工作原理" aria-hidden="true">#</a> 线程池的工作原理</h5><p>当调用线程池execute()方法添加一个任务时，线程池会做如下判断：</p><ol><li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li><li>如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。</li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</li><li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</li></ol><img src="`+p+'" alt="image-20220414103954905" style="zoom:50%;"><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><p>注：如果线程池设置了allowCoreThreadTimeout参数为true（默认false），那么当空闲线程超过keepaliveTime后直接停掉。（不会判断线程数是否大于corePoolSize）即：最终线程数会变为0。</p><p><strong>线程池中的三种等待队列</strong></p><p>ThreadPoolExecutor线程池推荐了三种等待队列，它们是：SynchronousQueue 、LinkedBlockingQueue 和 ArrayBlockingQueue。</p><ul><li>有界队列：</li></ul><p>SynchronousQueue ：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于 阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。</p><p>ArrayBlockingQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p><ul><li>无界队列：</li></ul><p>LinkedBlockingQueue：基于链表结构的无界阻塞队列，它可以指定容量也可以不指定容量（实际上任何无限容量的队列/栈都是有容量的，这个容量就是Integer.MAX_VALUE）</p><p>PriorityBlockingQueue：是一个按照优先级进行内部元素排序的无界阻塞队列。队列中的元素必须实现 Comparable 接口，这样才能通过实现compareTo()方法进行排序。优先级最高的元素将始终排在队列的头部；PriorityBlockingQueue 不会保证优先级一样的元素的排序。</p><p>注意：keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系。如果BlockingQueue是无界的，那么永远不会触发maximumPoolSize，自然keepAliveTime也就没有了意义。</p><p><strong>threadFactory</strong></p><p>threadFactory ：指定创建线程的工厂。（可以不指定）</p><p>如果不指定线程工厂时，ThreadPoolExecutor 会使用ThreadPoolExecutor.defaultThreadFactory 创建线程。默认工厂创建的线程：同属于相同的线程组，具有同为 Thread.NORM_PRIORITY 的优先级，以及名为 “pool-XXX-thread-” 的线程名（XXX为创建线程时顺序序号），且创建的线程都是非守护进程。</p><p><strong>handler 拒绝策略：</strong></p><p>handler ：表示当 workQueue 已满，且池中的线程数达到 maximumPoolSize 时，线程池拒绝添加新任务时采取的策略。（可以不指定）</p><table><thead><tr><th>策略</th><th>BB</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy()</td><td>抛出RejectedExecutionException异常。默认策略</td></tr><tr><td>ThreadPoolExecutor.CallerRunsPolicy()</td><td>由向线程池提交任务的线程来执行该任务</td></tr><tr><td>ThreadPoolExecutor.DiscardPolicy()</td><td>抛弃当前的任务</td></tr><tr><td>ThreadPoolExecutor.DiscardOldestPolicy()</td><td>抛弃最旧的任务（最先提交而没有得到执行的任务）</td></tr></tbody></table><p>最科学的的还是 AbortPolicy 提供的处理方式：抛出异常，由开发人员进行处理。</p><h5 id="线程池的常用方法" tabindex="-1"><a class="header-anchor" href="#线程池的常用方法" aria-hidden="true">#</a> 线程池的常用方法</h5><ul><li>getCorePoolSize()：返回线程池的核心线程数，这个值是一直不变的，返回在构造函数中设置的coreSize大小；</li><li>getMaximumPoolSize()：返回线程池的最大线程数，这个值是一直不变的，返回在构造函数中设置的coreSize大小；</li><li>getLargestPoolSize()：记录了曾经出现的最大线程个数（水位线）；</li><li>getPoolSize()：线程池中当前线程的数量；</li><li>getActiveCount()：Returns the approximate（近似） number of threads that are actively executing tasks；</li><li>prestartAllCoreThreads()：会启动所有核心线程，无论是否有待执行的任务，线程池都会创建新的线程，直到池中线程数量达到 corePoolSize；</li><li>prestartCoreThread()：会启动一个核心线程（同上）；</li><li>allowCoreThreadTimeOut(true)：允许核心线程在KeepAliveTime时间后，退出；</li></ul><h4 id="executors" tabindex="-1"><a class="header-anchor" href="#executors" aria-hidden="true">#</a> Executors</h4><p>Executors类的底层实现便是ThreadPoolExecutor！ Executors 工厂方法有：</p><ul><li>Executors.newCachedThreadPool()：无界线程池，可以进行自动线程回收</li><li>Executors.newFixedThreadPool(int)：固定大小线程池</li><li>Executors.newSingleThreadExecutor()：单个后台线程</li></ul><p>它们均为大多数使用场景预定义了设置。不过在阿里java文档中说明，尽量不要用该类创建线程池。</p><p>[(39条消息) ThreadPoolExecutor详解_赶路人儿的博客-CSDN博客_threadpoolexecutor</p>',44),d={href:"https://blog.csdn.net/liuxiao723846/article/details/108026782",target:"_blank",rel:"noopener noreferrer"},h={href:"https://blog.csdn.net/wangwenhui11/article/details/6760474?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&utm_relevant_index=1",target:"_blank",rel:"noopener noreferrer"},k=s(`<h2 id="threadpoolexecutor-1" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor-1" aria-hidden="true">#</a> ThreadPoolExecutor</h2><h2 id="scheduledthreadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#scheduledthreadpoolexecutor" aria-hidden="true">#</a> ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor实现了按时间调度来执行任务，具体而言有一下两个方面：</p><p>（1）延迟执行任务</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> 

<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）周期执行任务</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span> <span class="token keyword">long</span> period<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> 
    
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span> <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7);function m(v,x){const e=i("ExternalLinkIcon");return o(),l("div",null,[u,a("p",null,[a("a",d,[n(e)])]),a("p",null,[a("a",h,[c("(39条消息) ThreadPoolExecutor使用介绍_wangwenhui11的博客-CSDN博客_threadpoolexecutor"),n(e)])]),k])}const b=t(r,[["render",m],["__file","java-concurrent-pool.html.vue"]]);export{b as default};
