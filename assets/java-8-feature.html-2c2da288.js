const l=JSON.parse('{"key":"v-ad0ef95a","path":"/java/java-feature/java-8-feature.html","title":"Java 8 新特性总结","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Java 8 新特性—概述","slug":"java-8-新特性—概述","link":"#java-8-新特性—概述","children":[{"level":3,"title":"JEP 126：Lambda 表达式","slug":"jep-126-lambda-表达式","link":"#jep-126-lambda-表达式","children":[]},{"level":3,"title":"JEP 126：函数式接口","slug":"jep-126-函数式接口","link":"#jep-126-函数式接口","children":[]},{"level":3,"title":"JEP 150：接口的默认方法","slug":"jep-150-接口的默认方法","link":"#jep-150-接口的默认方法","children":[]},{"level":3,"title":"JEP 107：Stream API","slug":"jep-107-stream-api","link":"#jep-107-stream-api","children":[]},{"level":3,"title":"Optional 类","slug":"optional-类","link":"#optional-类","children":[]},{"level":3,"title":"JEP 170：新的日期时间 API","slug":"jep-170-新的日期时间-api","link":"#jep-170-新的日期时间-api","children":[]},{"level":3,"title":"JEP 120：重复注解","slug":"jep-120-重复注解","link":"#jep-120-重复注解","children":[]},{"level":3,"title":"Base64 编码解码","slug":"base64-编码解码","link":"#base64-编码解码","children":[]},{"level":3,"title":"JEP 104：类型注解","slug":"jep-104-类型注解","link":"#jep-104-类型注解","children":[]},{"level":3,"title":"JEP 101：类型推断优化","slug":"jep-101-类型推断优化","link":"#jep-101-类型推断优化","children":[]},{"level":3,"title":"JEP 174：Nashorn JavaScript 引擎","slug":"jep-174-nashorn-javascript-引擎","link":"#jep-174-nashorn-javascript-引擎","children":[]},{"level":3,"title":"JEP 122：移除Permgen","slug":"jep-122-移除permgen","link":"#jep-122-移除permgen","children":[]}]},{"level":2,"title":"Java 8 新特性—Lambda 表达式","slug":"java-8-新特性—lambda-表达式","link":"#java-8-新特性—lambda-表达式","children":[{"level":3,"title":"什么是 Lambda 表达式","slug":"什么是-lambda-表达式","link":"#什么是-lambda-表达式","children":[]},{"level":3,"title":"常见用法","slug":"常见用法","link":"#常见用法","children":[]},{"level":3,"title":"Lambda 简写依据","slug":"lambda-简写依据","link":"#lambda-简写依据","children":[]}]},{"level":2,"title":"Java 8 新特性—函数式接口","slug":"java-8-新特性—函数式接口","link":"#java-8-新特性—函数式接口","children":[{"level":3,"title":"什么是函数式接口","slug":"什么是函数式接口","link":"#什么是函数式接口","children":[]},{"level":3,"title":"自定义函数式接口","slug":"自定义函数式接口","link":"#自定义函数式接口","children":[]},{"level":3,"title":"常用函数式接口","slug":"常用函数式接口","link":"#常用函数式接口","children":[]}]},{"level":2,"title":"Java 8 新特性—方法引用和构造器引用","slug":"java-8-新特性—方法引用和构造器引用","link":"#java-8-新特性—方法引用和构造器引用","children":[{"level":3,"title":"什么是方法引用","slug":"什么是方法引用","link":"#什么是方法引用","children":[]},{"level":3,"title":"三种方法引用类型","slug":"三种方法引用类型","link":"#三种方法引用类型","children":[]},{"level":3,"title":"方法引用的前提条件","slug":"方法引用的前提条件","link":"#方法引用的前提条件","children":[]},{"level":3,"title":"方法引用的终极神器","slug":"方法引用的终极神器","link":"#方法引用的终极神器","children":[]},{"level":3,"title":"构造器引用","slug":"构造器引用","link":"#构造器引用","children":[]},{"level":3,"title":"数组引用","slug":"数组引用","link":"#数组引用","children":[]}]},{"level":2,"title":"Java 8 新特性—Optional","slug":"java-8-新特性—optional","link":"#java-8-新特性—optional","children":[{"level":3,"title":"引言","slug":"引言","link":"#引言","children":[]},{"level":3,"title":"Optional 是什么","slug":"optional-是什么","link":"#optional-是什么","children":[]},{"level":3,"title":"API 介绍","slug":"api-介绍","link":"#api-介绍","children":[]},{"level":3,"title":"实战应用","slug":"实战应用","link":"#实战应用","children":[]}]},{"level":2,"title":"Java 8 新特性—日期时间 API","slug":"java-8-新特性—日期时间-api","link":"#java-8-新特性—日期时间-api","children":[{"level":3,"title":"为什么 Java 8 要重新设计日期时间 API","slug":"为什么-java-8-要重新设计日期时间-api","link":"#为什么-java-8-要重新设计日期时间-api","children":[]},{"level":3,"title":"Instant：时间点","slug":"instant-时间点","link":"#instant-时间点","children":[]},{"level":3,"title":"LocalDate ：本地日期","slug":"localdate-本地日期","link":"#localdate-本地日期","children":[]},{"level":3,"title":"Period：LocalDate 的距离","slug":"period-localdate-的距离","link":"#period-localdate-的距离","children":[]},{"level":3,"title":"LocalTime 本地时间","slug":"localtime-本地时间","link":"#localtime-本地时间","children":[]},{"level":3,"title":"LocalDateTime 本地日期时间","slug":"localdatetime-本地日期时间","link":"#localdatetime-本地日期时间","children":[]},{"level":3,"title":"ZonedDateTime 带时区的日期时间","slug":"zoneddatetime-带时区的日期时间","link":"#zoneddatetime-带时区的日期时间","children":[]}]},{"level":2,"title":"Java 8 新特性—日期时间格式化","slug":"java-8-新特性—日期时间格式化","link":"#java-8-新特性—日期时间格式化","children":[{"level":3,"title":"DateTimeFormatter","slug":"datetimeformatter","link":"#datetimeformatter","children":[]},{"level":3,"title":"DateTimeFormatterBuilder","slug":"datetimeformatterbuilder","link":"#datetimeformatterbuilder","children":[]}]},{"level":2,"title":"Java 8 新特性—CompletableFuture","slug":"java-8-新特性—completablefuture","link":"#java-8-新特性—completablefuture","children":[{"level":3,"title":"Future 的局限性","slug":"future-的局限性","link":"#future-的局限性","children":[]},{"level":3,"title":"什么是 CompletableFuture","slug":"什么是-completablefuture","link":"#什么是-completablefuture","children":[]},{"level":3,"title":"CompletableFuture 的核心 API","slug":"completablefuture-的核心-api","link":"#completablefuture-的核心-api","children":[]},{"level":3,"title":"CompletableFuture 的任务编排","slug":"completablefuture-的任务编排","link":"#completablefuture-的任务编排","children":[]},{"level":3,"title":"CompletableFuture API 总结","slug":"completablefuture-api-总结","link":"#completablefuture-api-总结","children":[]}]},{"level":2,"title":"Java 8 新特性—重复注解@Repeatable","slug":"java-8-新特性—重复注解-repeatable","link":"#java-8-新特性—重复注解-repeatable","children":[{"level":3,"title":"Java 8 之前如何使用重复注解","slug":"java-8-之前如何使用重复注解","link":"#java-8-之前如何使用重复注解","children":[]},{"level":3,"title":"Java 8 重复注解 @Repeatable","slug":"java-8-重复注解-repeatable","link":"#java-8-重复注解-repeatable","children":[]}]},{"level":2,"title":"Java 8 新特性—接口默认方法和静态方法","slug":"java-8-新特性—接口默认方法和静态方法","link":"#java-8-新特性—接口默认方法和静态方法","children":[{"level":3,"title":"接口默认方法","slug":"接口默认方法","link":"#接口默认方法","children":[]},{"level":3,"title":"接口静态方法","slug":"接口静态方法","link":"#接口静态方法","children":[]}]},{"level":2,"title":"Java 8 新特性—Stream API 对元素流进行函数式操作","slug":"java-8-新特性—stream-api-对元素流进行函数式操作","link":"#java-8-新特性—stream-api-对元素流进行函数式操作","children":[{"level":3,"title":"什么是 Stream API","slug":"什么是-stream-api","link":"#什么是-stream-api","children":[]},{"level":3,"title":"为什么要用 Stream API","slug":"为什么要用-stream-api","link":"#为什么要用-stream-api","children":[]},{"level":3,"title":"Stream 操作三部曲","slug":"stream-操作三部曲","link":"#stream-操作三部曲","children":[]},{"level":3,"title":"Stream API 介绍","slug":"stream-api-介绍","link":"#stream-api-介绍","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]}]},{"level":2,"title":"Java 8 新特性—类型注解","slug":"java-8-新特性—类型注解","link":"#java-8-新特性—类型注解","children":[{"level":3,"title":"类型注解可以用在哪些地方？","slug":"类型注解可以用在哪些地方","link":"#类型注解可以用在哪些地方","children":[]},{"level":3,"title":"类型注解有什么作用？","slug":"类型注解有什么作用","link":"#类型注解有什么作用","children":[]}]},{"level":2,"title":"Java 8 新特性—类型推断优化","slug":"java-8-新特性—类型推断优化","link":"#java-8-新特性—类型推断优化","children":[{"level":3,"title":"理解泛型","slug":"理解泛型","link":"#理解泛型","children":[]},{"level":3,"title":"Java 7 类型推断优化","slug":"java-7-类型推断优化","link":"#java-7-类型推断优化","children":[]},{"level":3,"title":"Java 8 类型推断优化","slug":"java-8-类型推断优化","link":"#java-8-类型推断优化","children":[]}]},{"level":2,"title":"Java 8 新特性—全新的、标准的 Base64 API","slug":"java-8-新特性—全新的、标准的-base64-api","link":"#java-8-新特性—全新的、标准的-base64-api","children":[{"level":3,"title":"引言","slug":"引言-1","link":"#引言-1","children":[]},{"level":3,"title":"Base64 的核心原理","slug":"base64-的核心原理","link":"#base64-的核心原理","children":[]},{"level":3,"title":"Java 8 中的Base64 API","slug":"java-8-中的base64-api","link":"#java-8-中的base64-api","children":[]},{"level":3,"title":"Base64示例","slug":"base64示例","link":"#base64示例","children":[]}]}],"git":{"createdTime":1716620422000,"updatedTime":1716801999000,"contributors":[{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":2}]},"readingTime":{"minutes":121.75,"words":36524},"filePathRelative":"java/java-feature/java-8-feature.md","localizedDate":"2024年5月25日","excerpt":"<h1> Java 8 新特性总结</h1>\\n<h2> Java 8 新特性—概述</h2>\\n<blockquote>\\n<p>Java 8 是Java历史上一个重大的版本更新，发布于2014年3月18日。</p>\\n</blockquote>\\n<p></p>\\n<h3> <strong>JEP 126：Lambda 表达式</strong></h3>\\n<p>Lambda 表达式是 Java 8 新特性中最重要且最显著的一个，为 Java 增加了函数式编程的能力，使得代码变得更加简洁和易读。Lambda 表达式主要用于简化匿名内部类的实现。</p>\\n<p>Lambda 表达式的基本语法：</p>\\n<div class=\\"language-Java line-numbers-mode\\" data-ext=\\"Java\\"><pre class=\\"language-Java\\"><code>(parameters) -&gt; expression 或 (parameters) -&gt; { statements; }\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div>"}');export{l as data};
