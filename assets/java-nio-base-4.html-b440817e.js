import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as s,c as i,a as o,b as r,d as t,e as a}from"./app-e53dd85b.js";const l="/assets/nio-20211031100001-badde082.jpg",d="/assets/nio-20211031100002-59918d8f.jpg",p={},h=a('<h1 id="nio-基础-聊聊-proactor-模型" tabindex="-1"><a class="header-anchor" href="#nio-基础-聊聊-proactor-模型" aria-hidden="true">#</a> NIO 基础 - 聊聊 Proactor 模型</h1><p>上篇文章我们分析了高性能 IO模型Reactor模式，了解了什么是Reactor 模式以及它的三种常见的模式，这篇文章，大明再介绍另外一种高性能IO模型： <strong>Proactor</strong>。</p><p><img src="'+l+'" alt="img"></p><h1 id="为什么是-proactor-模式" tabindex="-1"><a class="header-anchor" href="#为什么是-proactor-模式" aria-hidden="true">#</a> 为什么是 Proactor 模式</h1>',4),_={href:"https://www.skjava.com/series/article/4295744090",target:"_blank",rel:"noopener noreferrer"},u=o("strong",null,"同步IO",-1),I=o("strong",null,"同步IO、",-1),g=o("strong",null,"异步IO",-1),O={href:"https://www.skjava.com/series/article/7825517347",target:"_blank",rel:"noopener noreferrer"},P={href:"https://www.skjava.com/series/article/2218162706",target:"_blank",rel:"noopener noreferrer"},f=a('<p>既然 <strong>同步IO</strong>有缺陷，那我们是不是可以调整为 <strong>异步IO</strong>呢？完全可以，这就是 <strong>Proactor 模式</strong>。</p><h1 id="什么是-proactor-模式" tabindex="-1"><a class="header-anchor" href="#什么是-proactor-模式" aria-hidden="true">#</a> 什么是 Proactor 模式</h1><p>Proactor 模式整体与Reactor 模式一致，区别就在于Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。模型如下：</p><p><img src="'+d+'" alt="img"></p><ul><li><strong>Procator Initiator</strong>：负责创建Handler和Procator，并将Procator和Handler都通过Asynchronous operation processor注册到内核。</li><li><strong>Handler</strong>：执行业务流程的业务处理器。</li><li><strong>Asynchronous operation processor</strong>：负责处理注册请求，并完成IO操作。完成IO操作后会通知Procator。</li><li><strong>Procator</strong>：根据不同的事件类型回调不同的handler进行业务处理。</li></ul><p>这里需要注意的是： <strong>Proactor关注的不是就绪事件，而是完成事件，这是区分Reactor模式的关键点</strong>。</p><p>然而可惜的是，Linux下的异步 I/O 是不完善的，<code>aio</code> 系列函数是由 <code>POSIX</code> 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 <code>aio</code> 异步操作，网络编程中的 <code>socket </code>是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p><p>而 Windows 里实现了一套完整的支持 <code>socket</code> 的异步编程接口，这套接口就是 <code>IOCP</code>，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。</p><p><strong>优缺点</strong></p><ul><li>优点 <ul><li>性能确实是强大，效率也高</li></ul></li><li>缺点 <ul><li>复杂。性能好，效率高，东西是好东西，但是使用起来就是复杂。</li><li>操作系统支持。上面提到过，Linux系统对异步IO支持不是很好，不是很完善</li></ul></li></ul><h1 id="proactor-模式与reactor-模式" tabindex="-1"><a class="header-anchor" href="#proactor-模式与reactor-模式" aria-hidden="true">#</a> Proactor 模式与Reactor 模式</h1><p>Proactor模式与Reactor模式 的区别有如下几点：</p><ul><li>Reactor 模式注册的是文件描述符的就绪事件。当Reactor 模式有事件发生时，它需要判断当前事件是读事件还是写事件，然后在调用系统的<code>read</code>或者<code>write</code>将数据从内核中拷贝到用户数据区，然后进行业务处理。</li><li>Proactor模式注册的则是完成事件。即发起异步操作后，操作系统将在内核态完成I/O并拷贝数据到用户提供的缓冲区中，完成后通知Proactor进行回调，用户只需要处理后续的业务即可。</li><li>Reactor模式实现<code>同步I/O多路分发</code></li><li>Proactor模式实现<code>异步I/O分发</code>。</li></ul><blockquote><p>在 Linux 操作系统下实现高并发网络编程依然以Reactor 模式为主。</p></blockquote>',14);function m(k,x){const e=n("ExternalLinkIcon");return s(),i("div",null,[h,o("p",null,[r("上篇文章 "),o("a",_,[r("【死磕 NIO】— Reactor 模式就一定意味着高性能吗？"),t(e)]),r("大明哥分析了 Reactor模式，我们知道Reactor性能确实非常高，适合高并发场景，但是它依然存在一个问题，那就是它是 "),u,r("。同步IO会有一个什么问题呢？同步IO需要线程自己等待内核准备好数据，在内核准备数据的过程中，当前线程是阻塞的，这样就会导致如果某个线程因为读取IO的时间过长（比如读取文件、写文件），则它势必会影响其他线程的执行。如果对 "),I,r(),g,r(" 不了解的同学，可以看如下两篇文章：")]),o("ul",null,[o("li",null,[o("a",O,[r("【死磕NIO】— 阻塞、非阻塞、同步、异步，傻傻分不清楚"),t(e)])]),o("li",null,[o("a",P,[r("【死磕NIO】— 阻塞IO，非阻塞IO，IO复用，信号驱动IO，异步IO，这你真的分的清楚吗？"),t(e)])])]),f])}const w=c(p,[["render",m],["__file","java-nio-base-4.html.vue"]]);export{w as default};
