const a=JSON.parse('{"key":"v-78cb2b4f","path":"/java/java-io/java-nio-base-4.html","title":"NIO 基础 - 聊聊 Proactor 模型","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"createdTime":1716801999000,"updatedTime":1716801999000,"contributors":[{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":1}]},"readingTime":{"minutes":3.39,"words":1018},"filePathRelative":"java/java-io/java-nio-base-4.md","localizedDate":"2024年5月27日","excerpt":"<h1> NIO 基础 - 聊聊 Proactor 模型</h1>\\n<p>上篇文章我们分析了高性能 IO模型Reactor模式，了解了什么是Reactor 模式以及它的三种常见的模式，这篇文章，大明再介绍另外一种高性能IO模型： <strong>Proactor</strong>。</p>\\n<p></p>\\n<h1> 为什么是 Proactor 模式</h1>\\n<p>上篇文章 <a href=\\"https://www.skjava.com/series/article/4295744090\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【死磕 NIO】— Reactor 模式就一定意味着高性能吗？</a>大明哥分析了 Reactor模式，我们知道Reactor性能确实非常高，适合高并发场景，但是它依然存在一个问题，那就是它是 <strong>同步IO</strong>。同步IO会有一个什么问题呢？同步IO需要线程自己等待内核准备好数据，在内核准备数据的过程中，当前线程是阻塞的，这样就会导致如果某个线程因为读取IO的时间过长（比如读取文件、写文件），则它势必会影响其他线程的执行。如果对 <strong>同步IO、</strong> <strong>异步IO</strong> 不了解的同学，可以看如下两篇文章：</p>"}');export{a as data};
