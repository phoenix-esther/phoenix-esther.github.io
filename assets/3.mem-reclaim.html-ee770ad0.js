const e=JSON.parse('{"key":"v-cec9dbf2","path":"/quality/operating-system/3.memory-manage/3.mem-reclaim.html","title":"内存满了，会发生什么？","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"#内存分配的过程是怎样的？","slug":"内存分配的过程是怎样的","link":"#内存分配的过程是怎样的","children":[]},{"level":2,"title":"#哪些内存可以被回收？","slug":"哪些内存可以被回收","link":"#哪些内存可以被回收","children":[]},{"level":2,"title":"#回收内存带来的性能影响","slug":"回收内存带来的性能影响","link":"#回收内存带来的性能影响","children":[{"level":3,"title":"#调整文件页和匿名页的回收倾向","slug":"调整文件页和匿名页的回收倾向","link":"#调整文件页和匿名页的回收倾向","children":[]},{"level":3,"title":"#尽早触发 kswapd 内核线程异步回收内存","slug":"尽早触发-kswapd-内核线程异步回收内存","link":"#尽早触发-kswapd-内核线程异步回收内存","children":[]},{"level":3,"title":"#NUMA 架构下的内存回收策略","slug":"numa-架构下的内存回收策略","link":"#numa-架构下的内存回收策略","children":[]}]},{"level":2,"title":"#如何保护一个进程不被 OOM 杀掉呢？","slug":"如何保护一个进程不被-oom-杀掉呢","link":"#如何保护一个进程不被-oom-杀掉呢","children":[]},{"level":2,"title":"#总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1696924078000,"updatedTime":1696924078000,"contributors":[{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":1}]},"readingTime":{"minutes":17.3,"words":5191},"filePathRelative":"quality/operating-system/3.memory-manage/3.mem-reclaim.md","localizedDate":"2023年10月10日","excerpt":"<h1> 内存满了，会发生什么？</h1>\\n<p>大家好，我是小林。</p>\\n<p>前几天有位读者留言说，面腾讯时，被问了两个内存管理的问题：</p>\\n<p></p>\\n<p></p>\\n<p>先来说说第一个问题：虚拟内存有什么作用？</p>\\n<ul>\\n<li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>\\n<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li>\\n<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li>\\n</ul>"}');export{e as data};
