import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as l,c as a,a as o,b as t,d as s,e}from"./app-9aa256ea.js";const p="/assets/提问-d72b4410.png",c="/assets/缓存污染提纲-0cd8f140.png",g="/assets/虚拟文件系统-0f71c710.png",d="/assets/缓冲池.drawio-ff00d0f0.png",_="/assets/lru-a3a08e34.png",h="/assets/lru2-00ed26ed.png",u="/assets/lru3-5c15b672.png",m="/assets/ae8252378169c8c14b8b9907983f7d8b-e4dba1b2.png",E="/assets/active_inactive_list.drawio-fe8fd4a0.png",L="/assets/active_inactive_list1.drawio-26ab82c3.png",B="/assets/active_inactive_list2.drawio-dcc81cb7.png",y="/assets/young-plus-old-9c303d67.png",f="/assets/lrutwo.drawio-b392e09e.png",x="/assets/lrutwo2-0e9c2ef8.png",R="/assets/lrutwo3-a169b31c.png",U="/assets/lruthree.drawio-53780239.png",b="/assets/lruthree1-bbf9a951.png",A={},v=e('<h1 id="如何避免预读失效和缓存污染的问题" tabindex="-1"><a class="header-anchor" href="#如何避免预读失效和缓存污染的问题" aria-hidden="true">#</a> 如何避免预读失效和缓存污染的问题？</h1><p>大家好，我是小林。</p><p>上周群里看到有位小伙伴面试时，被问到这两个问题：</p><p><img src="'+p+'" alt="img"></p><p>咋一看，以为是在问操作系统的问题，其实这两个题目都是在问<strong>如何改进 LRU 算法</strong>。</p><p>因为传统的 LRU 算法存在这两个问题：</p><ul><li><strong>「预读失效」导致缓存命中率下降（对应第一个题目）</strong></li><li><strong>「缓存污染」导致缓存命中率下降（对应第二个题目）</strong></li></ul><p>Redis 的缓存淘汰算法则是通过<strong>实现 LFU 算法</strong>来避免「缓存污染」而导致缓存命中率下降的问题（Redis 没有预读机制）。</p><p>MySQL 和 Linux 操作系统是通过<strong>改进 LRU 算法</strong>来避免「预读失效和缓存污染」而导致缓存命中率下降的问题。</p><p>这次，就重点讲讲 <strong>MySQL 和 Linux 操作系统是如何改进 LRU 算法的？</strong></p><p>好了，开始发车，坐稳了！</p><p><img src="'+c+'" alt="img"></p>',12),k={id:"linux-和-mysql-的缓存",tabindex:"-1"},S=o("a",{class:"header-anchor",href:"#linux-和-mysql-的缓存","aria-hidden":"true"},"#",-1),Q={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#linux-%E5%92%8C-mysql-%E7%9A%84%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"},M={id:"linux-操作系统的缓存",tabindex:"-1"},C=o("a",{class:"header-anchor",href:"#linux-操作系统的缓存","aria-hidden":"true"},"#",-1),D={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"},P=o("p",null,[t("在应用程序读取文件的数据的时候，Linux 操作系统是会对读取的文件数据进行缓存的，会缓存在文件系统中的 "),o("strong",null,"Page Cache"),t("（如下图中的页缓存）。")],-1),I=o("p",null,[o("img",{src:g,alt:"img"})],-1),F=o("p",null,"Page Cache 属于内存空间里的数据，由于内存访问比磁盘访问快很多，在下一次访问相同的数据就不需要通过磁盘 I/O 了，命中缓存就直接返回数据即可。",-1),q=o("p",null,"因此，Page Cache 起到了加速访问数据的作用。",-1),w={id:"mysql-的缓存",tabindex:"-1"},K=o("a",{class:"header-anchor",href:"#mysql-的缓存","aria-hidden":"true"},"#",-1),O={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#mysql-%E7%9A%84%E7%BC%93%E5%AD%98",target:"_blank",rel:"noopener noreferrer"},N=o("p",null,[t("MySQL 的数据是存储在磁盘里的，为了提升数据库的读写性能，Innodb 存储引擎设计了一个"),o("strong",null,"缓冲池"),t("（Buffer Pool），Buffer Pool 属于内存空间里的数据。")],-1),V=o("p",null,[o("img",{src:d,alt:"img"})],-1),H=o("p",null,"有了缓冲池后：",-1),T=o("ul",null,[o("li",null,"当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。"),o("li",null,"当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。")],-1),j={id:"传统-lru-是如何管理内存数据的",tabindex:"-1"},z=o("a",{class:"header-anchor",href:"#传统-lru-是如何管理内存数据的","aria-hidden":"true"},"#",-1),G={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E4%BC%A0%E7%BB%9F-lru-%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84",target:"_blank",rel:"noopener noreferrer"},J=e('<p>Linux 的 Page Cache 和 MySQL 的 Buffer Pool 的大小是有限的，并不能无限的缓存数据，对于一些频繁访问的数据我们希望可以一直留在内存中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证内存不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在内存中。</p><p>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</p><p>LRU 算法一般是用「链表」作为数据结构来实现的，链表头部的数据是最近使用的，而链表末尾的数据是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，也就是链表末尾的数据，从而腾出内存空间。</p><p>因为 Linux 的 Page Cache 和 MySQL 的 Buffer Pool 缓存的<strong>基本数据单位都是页（Page）单位</strong>，所以<strong>后续以「页」名称代替「数据」</strong>。</p><p>传统的 LRU 算法的实现思路是这样的：</p><ul><li>当访问的页在内存里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li><li>当访问的页不在内存里，除了要把该页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的页。</li></ul><p>比如下图，假设 LRU 链表长度为 5，LRU 链表从左到右有编号为 1，2，3，4，5 的页。</p><p><img src="'+_+'" alt="img"></p><p>如果访问了 3 号页，因为 3 号页已经在内存了，所以把 3 号页移动到链表头部即可，表示最近被访问了。</p><p><img src="'+h+'" alt="img"></p><p>而如果接下来，访问了 8 号页，因为 8 号页不在内存里，且 LRU 链表长度为 5，所以必须要淘汰数据，以腾出内存空间来缓存 8 号页，于是就会淘汰末尾的 5 号页，然后再将 8 号页加入到头部。</p><p><img src="'+u+'" alt="img"></p><p>传统的 LRU 算法并没有被 Linux 和 MySQL 使用，因为传统的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul>',14),W={id:"预读失效-怎么办",tabindex:"-1"},X=o("a",{class:"header-anchor",href:"#预读失效-怎么办","aria-hidden":"true"},"#",-1),Y={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88-%E6%80%8E%E4%B9%88%E5%8A%9E",target:"_blank",rel:"noopener noreferrer"},Z={id:"什么是预读机制",tabindex:"-1"},$=o("a",{class:"header-anchor",href:"#什么是预读机制","aria-hidden":"true"},"#",-1),oo={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E8%AF%BB%E6%9C%BA%E5%88%B6",target:"_blank",rel:"noopener noreferrer"},to=e('<p>Linux 操作系统为基于 Page Cache 的读缓存机制提供<strong>预读机制</strong>，一个例子是：</p><ul><li>应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。</li><li>但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；</li></ul><p>下图代表了操作系统的预读机制：</p><p><img src="'+m+'" alt="img"></p><p>上图中，应用程序利用 read 系统调动读取 4KB 数据，实际上内核使用预读机制（ReadaHead） 机制完成了 16KB 数据的读取，也就是通过一次磁盘顺序读将多个 Page 数据装入 Page Cache。</p><p>这样下次读取 4KB 数据后面的数据的时候，就不用从磁盘读取了，直接在 Page Cache 即可命中数据。因此，预读机制带来的好处就是<strong>减少了 磁盘 I/O 次数，提高系统磁盘 I/O 吞吐量</strong>。</p><p>MySQL Innodb 存储引擎的 Buffer Pool 也有类似的预读机制，MySQL 从磁盘加载页时，会提前把它相邻的页一并加载进来，目的是为了减少磁盘 IO。</p>',7),no={id:"预读失效会带来什么问题",tabindex:"-1"},so=o("a",{class:"header-anchor",href:"#预读失效会带来什么问题","aria-hidden":"true"},"#",-1),eo={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98",target:"_blank",rel:"noopener noreferrer"},io=o("p",null,[t("如果"),o("strong",null,"这些被提前加载进来的页，并没有被访问"),t("，相当于这个预读工作是白做了，这个就是"),o("strong",null,"预读失效"),t("。")],-1),ro=o("p",null,"如果使用传统的 LRU 算法，就会把「预读页」放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。",-1),lo=o("p",null,[t("如果这些「预读页」如果一直不会被访问到，就会出现一个很奇怪的问题，"),o("strong",null,"不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率"),t(" 。")],-1),ao={id:"如何避免预读失效造成的影响",tabindex:"-1"},po=o("a",{class:"header-anchor",href:"#如何避免预读失效造成的影响","aria-hidden":"true"},"#",-1),co={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D",target:"_blank",rel:"noopener noreferrer"},go=e('<p>我们不能因为害怕预读失效，而将预读机制去掉，大部分情况下，空间局部性原理还是成立的。</p><p>要避免预读失效带来影响，最好就是<strong>让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在内存里的时间尽可能长</strong>。</p><p>那到底怎么才能避免呢？</p><p>Linux 操作系统和 MySQL Innodb 通过改进传统 LRU 链表来避免预读失效带来的影响，具体的改进分别如下：</p><ul><li>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）</strong>；</li><li>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：<strong>young 区域 和 old 区域</strong>。</li></ul><p>这两个改进方式，设计思想都是类似的，<strong>都是将数据分为了冷数据和热数据，然后分别进行 LRU 算法</strong>。不再像传统的 LRU 算法那样，所有数据都只用一个 LRU 算法管理。</p><p>接下来，具体聊聊 Linux 和 MySQL 是如何避免预读失效带来的影响？</p><blockquote><p>Linux 是如何避免预读失效带来的影响？</p></blockquote><p>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）</strong>。</p><ul><li><strong>active list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li><li><strong>inactive list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li></ul><p>有了这两个 LRU 链表后，<strong>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部</strong>。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。</p><p>接下来，给大家举个例子。</p><p>假设 active list 和 inactive list 的长度为 5，目前内存中已经有如下 10 个页：</p><p><img src="'+E+'" alt="img"></p><p>现在有个编号为 20 的页被预读了，这个页只会被插入到 inactive list 的头部，而 inactive list 末尾的页（10号）会被淘汰掉。</p><p><img src="'+L+'" alt="img"></p><p><strong>即使编号为 20 的预读页一直不会被访问，它也没有占用到 active list 的位置</strong>，而且还会比 active list 中的页更早被淘汰出去。</p><p>如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 active list 的头部， active list 末尾的页（5号），会被<strong>降级</strong>到 inactive list ，作为 inactive list 的头部，这个过程并不会有数据被淘汰。</p><p><img src="'+B+'" alt="img"></p><blockquote><p>MySQL 是如何避免预读失效带来的影响？</p></blockquote><p>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域，<strong>young 区域 和 old 区域</strong>。</p><p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，这两个区域都有各自的头和尾节点，如下图：</p><p><img src="'+y+'" alt="img"></p><p>young 区域与 old 区域在 LRU 链表中的占比关系并不是一比一的关系，而是 63:37（默认比例）的关系。</p><p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><p>接下来，给大家举个例子。</p><p>假设有一个长度为 10 的 LRU 链表，其中 young 区域占比 70 %，old 区域占比 30 %。</p><p><img src="'+f+'" alt="img"></p><p>现在有个编号为 20 的页被预读了，这个页只会被插入到 old 区域头部，而 old 区域末尾的页（10号）会被淘汰掉。</p><p><img src="'+x+'" alt="img"></p><p>如果 20 号页一直不会被访问，它也没有占用到 young 区域的位置，而且还会比 young 区域的数据更早被淘汰出去。</p><p>如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 young 区域的头部，young 区域末尾的页（7号），会被挤到 old 区域，作为 old 区域的头部，这个过程并不会有页被淘汰。</p><p><img src="'+R+'" alt="img"></p>',33),_o={id:"缓存污染-怎么办",tabindex:"-1"},ho=o("a",{class:"header-anchor",href:"#缓存污染-怎么办","aria-hidden":"true"},"#",-1),uo={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93-%E6%80%8E%E4%B9%88%E5%8A%9E",target:"_blank",rel:"noopener noreferrer"},mo={id:"什么是缓存污染",tabindex:"-1"},Eo=o("a",{class:"header-anchor",href:"#什么是缓存污染","aria-hidden":"true"},"#",-1),Lo={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93",target:"_blank",rel:"noopener noreferrer"},Bo=o("p",null,"虽然 Linux （实现两个 LRU 链表）和 MySQL （划分两个区域）通过改进传统的 LRU 数据结构，避免了预读失效带来的影响。",-1),yo=o("p",null,[t("但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么"),o("strong",null,"还存在缓存污染的问题"),t("。")],-1),fo=o("p",null,[t("当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，"),o("strong",null,"如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了"),t("。")],-1),xo={id:"缓存污染会带来什么问题",tabindex:"-1"},Ro=o("a",{class:"header-anchor",href:"#缓存污染会带来什么问题","aria-hidden":"true"},"#",-1),Uo={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98",target:"_blank",rel:"noopener noreferrer"},bo=e(`<p>缓存污染带来的影响就是很致命的，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，系统性能就会急剧下降。</p><p>我以 MySQL 举例子，Linux 发生缓存污染的现象也是类似。</p><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，MySQL 性能就会急剧下降。</p><p>注意， 缓存污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成缓存污染。</p><p>比如，在一个数据量非常大的表，执行了这条语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">&quot;%xiaolin%&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p><ul><li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li><li>当从页里读取行记录时，也就是<strong>页被访问的时候，就要将该页放到 young 区域头部</strong>；</li><li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li><li>如此往复，直到扫描完表中的所有记录。</li></ul><p>经过这一番折腾，由于这条 SQL 语句访问的页非常多，每访问一个页，都会将其加入 young 区域头部，那么<strong>原本 young 区域的热点数据都会被替换掉，导致缓存命中率下降</strong>。那些在批量扫描时，而被加入到 young 区域的页，如果在很长一段时间都不会再被访问的话，那么就污染了 young 区域。</p><p>举个例子，假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）。</p><p><img src="`+U+'" alt="img"></p><p>在批量访问这些页的时候，会被逐一插入到 young 区域头部。</p><p><img src="'+b+'" alt="img"></p><p>可以看到，原本在 young 区域的 6 和 7 号页都被淘汰了，而批量扫描的页基本占满了 young 区域，如果这些页在很长一段时间都不会被访问，那么就对 young 区域造成了污染。</p><p>如果 6 和 7 号页是热点数据，那么在被淘汰后，后续有 SQL 再次读取 6 和 7 号页时，由于缓存未命中，就要从磁盘中读取了，降低了 MySQL 的性能，这就是缓存污染带来的影响。</p>',15),Ao={id:"怎么避免缓存污染造成的影响",tabindex:"-1"},vo=o("a",{class:"header-anchor",href:"#怎么避免缓存污染造成的影响","aria-hidden":"true"},"#",-1),ko={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D",target:"_blank",rel:"noopener noreferrer"},So=e("<p>前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者 young 区域），<strong>这种 LRU 算法进入活跃 LRU 链表的门槛太低了</strong>！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃 LRU 链表里的热点数据淘汰了。</p><p>所以，<strong>只要我们提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉</strong>。</p><p>Linux 操作系统和 MySQL Innodb 存储引擎分别是这样提高门槛的：</p><ul><li><p><strong>Linux 操作系统</strong>：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</p></li><li><p>MySQL Innodb</p><p>：在内存页被访问</p><p>第二次</p><p>的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行</p><p>停留在 old 区域的时间判断</p><p>：</p><ul><li>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</li><li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li></ul></li></ul><p>提高了进入活跃 LRU 链表（或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。</p><p>在批量读取数据时候，<strong>如果这些大量数据只会被访问一次，那么它们就不会进入到活跃 LRU 链表（或者 young 区域）</strong>，也就不会把热点数据淘汰，只会待在非活跃 LRU 链表（或者 old 区域）中，后续很快也会被淘汰。</p>",6),Qo={id:"总结",tabindex:"-1"},Mo=o("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#",-1),Co={href:"https://xiaolincoding.com/os/3_memory/cache_lru.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"},Do=e("<p>传统的 LRU 算法法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul><p>为了避免「预读失效」造成的影响，Linux 和 MySQL 对传统的 LRU 链表做了改进：</p><ul><li>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）</strong>。</li><li>MySQL Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：<strong>young 区域 和 old 区域</strong>。</li></ul><p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么<strong>还存在缓存污染的问题</strong>。</p><p>为了避免「缓存污染」造成的影响，Linux 操作系统和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛：</p><ul><li><p>Linux 操作系统：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</p></li><li><p>MySQL Innodb：在内存页被访问</p><p>第二次</p><p>的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行</p><p>停留在 old 区域的时间判断</p><p>：</p><ul><li>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</li><li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li></ul></li></ul><p>通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。</p><p>完！</p>",9);function Po(Io,Fo){const n=r("ExternalLinkIcon");return l(),a("div",null,[v,o("h2",k,[S,t(),o("a",Q,[t("#"),s(n)]),t("Linux 和 MySQL 的缓存")]),o("h3",M,[C,t(),o("a",D,[t("#"),s(n)]),t("Linux 操作系统的缓存")]),P,I,F,q,o("h3",w,[K,t(),o("a",O,[t("#"),s(n)]),t("MySQL 的缓存")]),N,V,H,T,o("h2",j,[z,t(),o("a",G,[t("#"),s(n)]),t("传统 LRU 是如何管理内存数据的？")]),J,o("h2",W,[X,t(),o("a",Y,[t("#"),s(n)]),t("预读失效，怎么办？")]),o("h3",Z,[$,t(),o("a",oo,[t("#"),s(n)]),t("什么是预读机制？")]),to,o("h3",no,[so,t(),o("a",eo,[t("#"),s(n)]),t("预读失效会带来什么问题？")]),io,ro,lo,o("h3",ao,[po,t(),o("a",co,[t("#"),s(n)]),t("如何避免预读失效造成的影响？")]),go,o("h2",_o,[ho,t(),o("a",uo,[t("#"),s(n)]),t("缓存污染，怎么办？")]),o("h3",mo,[Eo,t(),o("a",Lo,[t("#"),s(n)]),t("什么是缓存污染？")]),Bo,yo,fo,o("h3",xo,[Ro,t(),o("a",Uo,[t("#"),s(n)]),t("缓存污染会带来什么问题？")]),bo,o("h3",Ao,[vo,t(),o("a",ko,[t("#"),s(n)]),t("怎么避免缓存污染造成的影响？")]),So,o("h2",Qo,[Mo,t(),o("a",Co,[t("#"),s(n)]),t("总结")]),Do])}const Ko=i(A,[["render",Po],["__file","5.cache-lru.html.vue"]]);export{Ko as default};
