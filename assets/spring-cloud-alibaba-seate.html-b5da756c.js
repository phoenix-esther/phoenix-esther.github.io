import{_ as a,V as e,W as i,X as s}from"./framework-4ec38622.js";const t="/assets/image-20210724165045186-f18efcde.png",r="/assets/image-20210724165338958-a67810b1.png",l="/assets/image-20210724170517944-d453e535.png",n="/assets/image-20210724170704694-390d631c.png",p="/assets/image-20210724170735847-93d2f0f2.png",o="/assets/image-20210724170834855-d6f4cc11.png",h="/assets/image-20210724170932072-16f46965.png",d="/assets/image-20210724171007516-35e96a07.png",c="/assets/image-20210724171041210-fc814370.png",g="/assets/image-20210724171546472-3990aafe.png",m="/assets/image-20210724172123567-3f101abf.png",u="/assets/image-20210724172326452-564025d5.png",_="/assets/image-20210724174102768-090f4f4e.png",b="/assets/image-20210724174234987-85fb0cf4.png",f="/assets/image-20210724174424070-7ce14b80.png",A={},x=s('<h1 id="spring-cloud-alibaba-seate" tabindex="-1"><a class="header-anchor" href="#spring-cloud-alibaba-seate" aria-hidden="true">#</a> Spring Cloud Alibaba Seate</h1><h2 id="分布式事务问题" tabindex="-1"><a class="header-anchor" href="#分布式事务问题" aria-hidden="true">#</a> 分布式事务问题</h2><h3 id="_1-1-本地事务" tabindex="-1"><a class="header-anchor" href="#_1-1-本地事务" aria-hidden="true">#</a> 1.1.本地事务</h3><p>本地事务，也就是传统的<strong>单机事务</strong>。在传统数据库事务中，必须要满足四个原则：</p><img src="'+t+'" alt="image-20210724165045186" style="zoom:67%;"><h3 id="_1-2-分布式事务" tabindex="-1"><a class="header-anchor" href="#_1-2-分布式事务" aria-hidden="true">#</a> 1.2.分布式事务</h3><p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：</p><ul><li>跨数据源的分布式事务</li><li>跨服务的分布式事务</li><li>综合情况</li></ul><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p><ul><li>创建新订单</li><li>扣减商品库存</li><li>从用户账户余额扣除金额</li></ul><p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p><img src="'+r+'" alt="image-20210724165338958" style="zoom:67%;"><p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p><p>但是当我们把三件事情看做一个&quot;业务&quot;，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是<strong>分布式系统下的事务</strong>了。</p><p>此时ACID难以满足，这是分布式事务要解决的问题</p><h2 id="理论基础" tabindex="-1"><a class="header-anchor" href="#理论基础" aria-hidden="true">#</a> 理论基础</h2><p>解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。</p><h3 id="cap定理" tabindex="-1"><a class="header-anchor" href="#cap定理" aria-hidden="true">#</a> CAP定理</h3><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p><blockquote><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance （分区容错性）</li></ul></blockquote><img src="'+l+'" alt="image-20210724170517944" style="zoom:67%;"><p>它们的第一个字母分别是 C、A、P。</p><p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p><h4 id="一致性" tabindex="-1"><a class="header-anchor" href="#一致性" aria-hidden="true">#</a> 一致性</h4><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</p><p>比如现在包含两个节点，其中的初始数据是一致的：</p><img src="'+n+'" alt="image-20210724170704694" style="zoom:60%;"><p>当我们修改其中一个节点的数据时，两者的数据产生了差异：</p><img src="'+p+'" alt="image-20210724170735847" style="zoom:60%;"><p>要想保住一致性，就必须实现node01 到 node02的数据 同步：</p><img src="'+o+'" alt="image-20210724170834855" style="zoom:60%;"><br><h4 id="可用性" tabindex="-1"><a class="header-anchor" href="#可用性" aria-hidden="true">#</a> 可用性</h4><p>Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</p><p>如图，有三个节点的集群，访问任何一个都可以及时得到响应：</p><img src="'+h+'" alt="image-20210724170932072" style="zoom:60%;"><p>当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用：</p><img src="'+d+'" alt="image-20210724171007516" style="zoom:60%;"><h4 id="分区容错" tabindex="-1"><a class="header-anchor" href="#分区容错" aria-hidden="true">#</a> 分区容错</h4><p><strong>Partition（分区）</strong>：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p><img src="'+c+'" alt="image-20210724171041210" style="zoom:60%;"><p><strong>Tolerance（容错）</strong>：在集群出现分区时，整个系统也要持续对外提供服务</p><h4 id="矛盾" tabindex="-1"><a class="header-anchor" href="#矛盾" aria-hidden="true">#</a> 矛盾</h4><p>在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。</p><p>当节点接收到新的数据变更时，就会出现问题了：</p><img src="'+g+'" alt="image-20210724171546472" style="zoom:60%;"><p>如果此时要保证<strong>一致性</strong>，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p><p>如果此时要保证<strong>可用性</strong>，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。</p><p>也就是说，在P一定会出现的情况下，A和C之间只能实现一个。</p><h3 id="base理论" tabindex="-1"><a class="header-anchor" href="#base理论" aria-hidden="true">#</a> BASE理论</h3><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>**Soft State（软状态）：**在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><h3 id="解决分布式事务的思路" tabindex="-1"><a class="header-anchor" href="#解决分布式事务的思路" aria-hidden="true">#</a> 解决分布式事务的思路</h3><p>分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</p><ul><li><p>AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</p></li><li><p>CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</p></li></ul><p>但不管是哪一种模式，都需要在子系统事务之间互相通讯，协调事务状态，也就是需要一个<strong>事务协调者(TC)</strong>：</p><img src="'+m+'" alt="image-20210724172123567" style="zoom:60%;"><p>这里的子系统事务，称为<strong>分支事务</strong>；有关联的各个分支事务在一起称为<strong>全局事务</strong>。</p><h2 id="初识seate" tabindex="-1"><a class="header-anchor" href="#初识seate" aria-hidden="true">#</a> 初识Seate</h2><p>Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p><p>官网地址：http://seata.io/，其中的文档、播客中提供了大量的使用说明、源码分析。</p><h3 id="seata的架构" tabindex="-1"><a class="header-anchor" href="#seata的架构" aria-hidden="true">#</a> Seata的架构</h3><p>Seata事务管理中有三个重要的角色：</p><ul><li><p><strong>TC (Transaction Coordinator) -</strong> **事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。</p></li><li><p><strong>TM (Transaction Manager) -</strong> **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。</p></li><li><p><strong>RM (Resource Manager) -</strong> **资源管理器：**管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p></li></ul><p>整体的架构如图：</p><img src="'+u+'" alt="image-20210724172326452" style="zoom:60%;"><p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li><li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul><p>无论哪种方案，都离不开TC，也就是事务的协调者。</p><h2 id="seate的部署和集成" tabindex="-1"><a class="header-anchor" href="#seate的部署和集成" aria-hidden="true">#</a> Seate的部署和集成</h2><h3 id="部署tc服务" tabindex="-1"><a class="header-anchor" href="#部署tc服务" aria-hidden="true">#</a> 部署TC服务</h3><p>略</p><h3 id="集成seate" tabindex="-1"><a class="header-anchor" href="#集成seate" aria-hidden="true">#</a> 集成Seate</h3><p>略</p><h2 id="seate中的事物模型" tabindex="-1"><a class="header-anchor" href="#seate中的事物模型" aria-hidden="true">#</a> Seate中的事物模型</h2><h3 id="xa模式" tabindex="-1"><a class="header-anchor" href="#xa模式" aria-hidden="true">#</a> XA模式</h3><p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><h4 id="两阶段提交" tabindex="-1"><a class="header-anchor" href="#两阶段提交" aria-hidden="true">#</a> 两阶段提交</h4><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p><p>正常情况：</p><img src="'+_+'" alt="image-20210724174102768" style="zoom:67%;"><p>异常情况：</p><img src="'+b+'" alt="image-20210724174234987" style="zoom:67%;"><p>一阶段：</p><ul><li>事务协调者通知每个事物参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作 <ul><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul></li></ul><h3 id="_4-1-2-seata的xa模型" tabindex="-1"><a class="header-anchor" href="#_4-1-2-seata的xa模型" aria-hidden="true">#</a> 4.1.2.Seata的XA模型</h3><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><img src="'+f+'" alt="image-20210724174424070" style="zoom:67%;"><p>RM一阶段的工作：</p><p>​ ① 注册分支事务到TC</p><p>​ ② 执行分支业务sql但不提交</p><p>​ ③ 报告执行状态到TC</p><p>TC二阶段的工作：</p><ul><li><p>TC检测各分支事务执行状态</p><p>a.如果都成功，通知所有RM提交事务</p><p>b.如果有失败，通知所有RM回滚事务</p></li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><h3 id="_4-1-3-优缺点" tabindex="-1"><a class="header-anchor" href="#_4-1-3-优缺点" aria-hidden="true">#</a> 4.1.3.优缺点</h3><p>XA模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则。</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><p>嘁嘁嘁请求</p>',104),C=[x];function y(S,T){return e(),i("div",null,C)}const P=a(A,[["render",y],["__file","spring-cloud-alibaba-seate.html.vue"]]);export{P as default};
