const e=JSON.parse('{"key":"v-0b589964","path":"/java/java-concurrent/Java-concurrent-container.html","title":"Java 并发容器","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[{"level":3,"title":"HashMap的并发死链","slug":"hashmap的并发死链","link":"#hashmap的并发死链","children":[]},{"level":3,"title":"JDK1.7的实现","slug":"jdk1-7的实现","link":"#jdk1-7的实现","children":[]},{"level":3,"title":"JDK1.8的实现","slug":"jdk1-8的实现","link":"#jdk1-8的实现","children":[]}]},{"level":2,"title":"ConcurrentLinkedQueue","slug":"concurrentlinkedqueue","link":"#concurrentlinkedqueue","children":[]},{"level":2,"title":"Java中的阻塞队列","slug":"java中的阻塞队列","link":"#java中的阻塞队列","children":[]},{"level":2,"title":"CopyOnWriteArrayList","slug":"copyonwritearraylist","link":"#copyonwritearraylist","children":[]}],"git":{"createdTime":1652769979000,"updatedTime":1708424156000,"contributors":[{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":6},{"name":"xuliang","email":"895252461@qq.com","commits":1}]},"readingTime":{"minutes":10.75,"words":3225},"filePathRelative":"java/java-concurrent/Java-concurrent-container.md","localizedDate":"2022年5月17日","excerpt":"<h1> Java 并发容器</h1>\\n<h2> ConcurrentHashMap</h2>\\n<h3> HashMap的并发死链</h3>\\n<p>HashMap的并发死链仅出现在JDK1.7中，该问题在JDK1.8中得以解决。下面只针对JDK1.7进行讨论。</p>\\n<h4> 前置知识</h4>\\n<p>在 JDK1.7 中HashMap的底层数据实现是数组+链表的方式，如下图所示：</p>\\n\\n<p>而<code>HashMap</code>在数据添加时使用的是头插入，如下图所示：</p>\\n\\n<p><code>HashMap</code>正常情况下的扩容实现如下图所示：</p>\\n\\n<p>总结一下，JDK1.7中的HashMap使用数组加链表的方式实现。使用头插法实现新数据的添加，在扩容时会导致链表顺序的反转。正是因为这些基础的实现逻辑，导致了最终的并发死链问题。</p>"}');export{e as data};
