import{_ as e,V as n,W as t,a0 as p}from"./framework-5dde3bca.js";const o="/assets/image-20220426093437386-a03fbceb.png",i="/assets/image-20220426095518142-c4c13a30.png",l="/assets/image-20220426095639059-c6fe43b7.png",d="/assets/image-20220426095957217-5e470c58.png",r="/assets/image-20220426125410635-ea50920f.png",c="/assets/image-20220426125454233-d8bc2366.png",u="/assets/image-20220426125558905-a88d00ef.png",m="/assets/image-20220426125715435-d617d0d6.png",g="/assets/image-20220426125836198-1638a19c.png",h="/assets/image-20220426130002472-a8a1e085.png",k="/assets/image-20220426130112307-a9ee5735.png",b="/assets/image-20220426130147436-9b9b5dce.png",v="/assets/image-20220426132101688-915a67bc.png",y="/assets/image-20220426132221890-dac67025.png",_="/assets/image-20220426133035695-99184019.png",x="/assets/image-20220426133244664-627d62dc.png",f="/assets/image-20220426133553213-bd2d91d9.png",w="/assets/image-20220426133716953-e6acbe09.png",q="/assets/image-20220426133851894-2e00f48d.png",L="/assets/image-20220426134116001-b2461b53.png",S="/assets/image-20220426134155085-a4d96e07.png",D="/assets/image-20220426134818605-02deedfc.png",B="/assets/image-20220426135255321-c91d6c28.png",I="/assets/image-20220426135401081-e3b725f4.png",M="/assets/image-20220426135541380-cb543dc5.png",E="/assets/image-20220426135632221-3afb4a5a.png",z="/assets/image-20220426135730402-d47d9cdb.png",Q="/assets/image-20220426135807560-5be4e5ee.png",R="/assets/image-20220426135900534-6d2d7fc3.png",T="/assets/image-20220426140032442-a644aab8.png",A="/assets/image-20220426140210209-2045af22.png",C="/assets/image-20220426140525159-119b00fc.png",U="/assets/image-20220426140602887-29ac60d7.png",O="/assets/image-20220426140707371-96cff37b.png",N="/assets/image-20220426140843786-252895ee.png",P="/assets/image-20220426141016243-35069dbc.png",V="/assets/image-20220426141147408-593d6ad5.png",H="/assets/image-20220426141312971-d634e89f.png",X="/assets/image-20220426141420100-69b88a8e.png",W="/assets/image-20220426141550959-db102ee6.png",F="/assets/image-20220426141639442-d6582ad9.png",G="/assets/image-20220426142000554-132d7559.png",K="/assets/image-20220426142104568-74064a72.png",Y="/assets/image-20220426144116562-0dd4e247.png",J="/assets/image-20220426144253275-ea7317c4.png",j="/assets/image-20220426144634023-53f3c7ab.png",Z="/assets/image-20220426144946484-c3a2929c.png",$="/assets/image-20220426145016039-f5f5cdd3.png",ss="/assets/image-20220426145143737-8d5a8400.png",as="/assets/image-20220426145216169-bee7dd1f.png",es="/assets/image-20220426145536751-ae0fd661.png",ns="/assets/image-20220426145743018-a6dfafde.png",ts="/assets/image-20220426145819299-bdbf044f.png",ps="/assets/image-20220426145904194-90b849d7.png",os="/assets/image-20220426145933220-0ff220d2.png",is="/assets/image-20220426150616520-951037ed.png",ls="/assets/image-20220426150834107-e9fccca2.png",ds="/assets/image-20220426150905721-f9df9cb9.png",rs="/assets/image-20220426151017038-dbbffc7d.png",cs="/assets/image-20220426151103028-b4a8100a.png",us="/assets/image-20220426151138823-c5d45d8e.png",ms="/assets/image-20220426151214000-e393c61c.png",gs="/assets/image-20220426151343299-ced1e706.png",hs="/assets/image-20220426151436767-83d462d3.png",ks="/assets/image-20220426151507616-63aa8459.png",bs="/assets/image-20220426151533629-3220c05c.png",vs="/assets/image-20220426151559527-bbeb5d30.png",ys="/assets/image-20220426151629960-575e6bc9.png",_s="/assets/image-20220426151753238-b4f59af9.png",xs="/assets/image-20220426151816649-5ce2d8ab.png",fs="/assets/image-20220426151833513-9a94535b.png",ws="/assets/image-20220426151913875-6dedd36f.png",qs="/assets/image-20220426151931681-83e53da2.png",Ls="/assets/image-20220426152045680-9a51fd9d.png",Ss="/assets/image-20220426152313693-98b76006.png",Ds="/assets/image-20220426152358277-fab69bc9.png",Bs="/assets/image-20220426152439578-b012ce00.png",Is="/assets/image-20220426153204338-0040b11e.png",Ms="/assets/image-20220426153230444-623dd994.png",Es="/assets/image-20220426153351875-33c2723d.png",zs="/assets/image-20220426153508957-bbbfc419.png",Qs="/assets/image-20220426153619040-9062fd65.png",Rs="/assets/image-20220426153729688-340b4932.png",Ts="/assets/image-20220426153740747-b56a2288.png",As="/assets/image-20220426154028829-1c0199fe.png",Cs="/assets/image-20220426154100621-970563c5.png",Us="/assets/image-20220426154150695-62c16642.png",Os="/assets/image-20220426154257324-2ec9fa27.png",Ns="/assets/image-20220426154316395-2136ce3d.png",Ps="/assets/image-20220426154659445-d1ecc663.png",Vs="/assets/image-20220426155608697-89860da3.png",Hs="/assets/image-20220426155839152-90ba3d30.png",Xs="/assets/image-20220426160414695-94a956b3.png",Ws="/assets/image-20220426160456612-9186c762.png",Fs="/assets/image-20220426161203823-1bf97155.png",Gs="/assets/image-20220426161235688-f790d98b.png",Ks="/assets/image-20220426161359156-15ca2d76.png",Ys="/assets/image-20220426161508026-6d1116a4.png",Js="/assets/image-20220426161744776-71c69df1.png",js="/assets/image-20220426161827629-0fcaa899.png",Zs="/assets/image-20220426161908510-a3da96a4.png",$s="/assets/image-20220426162017022-9a6d2c1b.png",sa="/assets/image-20220426163450919-16447d9a.png",aa="/assets/image-20220426163540635-985a876c.png",ea="/assets/image-20220426163601381-85421f32.png",na="/assets/image-20220426163645003-b45ca480.png",ta="/assets/image-20220427080239097-1f042658.png",pa="/assets/image-20220427080814476-73d17ac0.png",oa="/assets/image-20220427081105843-1c6c4ef8.png",ia="/assets/image-20220427081201997-5beed8e3.png",la="/assets/image-20220427081356587-f46411f3.png",da="/assets/image-20220427081505911-9052900a.png",ra="/assets/image-20220427081601090-2a929b6b.png",ca="/assets/image-20220427081942107-70ee484d.png",ua="/assets/image-20220427082018336-074b1042.png",ma="/assets/image-20220427082223707-af19f700.png",ga="/assets/image-20220427082337252-80662ff9.png",ha="/assets/image-20220427082511506-78106681.png",ka="/assets/image-20220427082652621-bc1dbc8a.png",ba="/assets/image-20220427082857707-5fe1f2a2.png",va="/assets/image-20220427083211638-2e93c3a7.png",ya="/assets/image-20220427083250837-bcdf99ae.png",_a="/assets/image-20220427083538516-0e444d5d.png",xa="/assets/image-20220427083611859-ae614232.png",fa="/assets/image-20220427084241423-08fb6704.png",wa="/assets/image-20220427084502280-e13ef5e0.png",qa="/assets/image-20220427084719578-a9c15b28.png",La="/assets/image-20220427090457189-2ee6540d.png",Sa="/assets/image-20220427090527928-9be50345.png",Da="/assets/image-20220427090814049-0448562a.png",Ba="/assets/image-20220427090918139-7e0ea374.png",Ia="/assets/image-20220427091020709-1f5e011e.png",Ma="/assets/image-20220427091058108-791f5b90.png",Ea="/assets/image-20220427091138980-8754656f.png",za="/assets/image-20220427091218848-5b55e075.png",Qa="/assets/image-20220427091253293-19e1526e.png",Ra="/assets/image-20220427093322038-d65aa84b.png",s="/assets/image-20220427093417945-63875f58.png",a="/assets/image-20220427093449949-45d23b43.png",Ta="/assets/image-20220427095606457-16bc627c.png",Aa="/assets/image-20220427095709975-72ac66a5.png",Ca="/assets/image-20220427101337195-b4f0c23e.png",Ua={},Oa=p('<h1 id="mysql-进阶篇" tabindex="-1"><a class="header-anchor" href="#mysql-进阶篇" aria-hidden="true">#</a> MySQL 进阶篇</h1><h2 id="进阶篇-存储引擎" tabindex="-1"><a class="header-anchor" href="#进阶篇-存储引擎" aria-hidden="true">#</a> 进阶篇-存储引擎</h2><h3 id="mysql体系结构" tabindex="-1"><a class="header-anchor" href="#mysql体系结构" aria-hidden="true">#</a> MySQL体系结构</h3><img src="'+o+`" alt="image-20220426093437386" style="zoom:50%;"><ul><li>连接层</li></ul><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><ul><li>服务层</li></ul><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><ul><li>引擎层</li></ul><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</p><ul><li>存储层</li></ul><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><h3 id="mysql存储引擎介绍" tabindex="-1"><a class="header-anchor" href="#mysql存储引擎介绍" aria-hidden="true">#</a> MySQL存储引擎介绍</h3><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p><p>查询当前数据库支持的存储引擎</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> engines<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建表时指定存储引擎</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> name<span class="token punctuation">(</span> 
	字段<span class="token number">1</span> 字段<span class="token number">1</span>类型 <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 字段<span class="token number">1</span>注释 <span class="token punctuation">]</span> <span class="token punctuation">,</span> 
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
	字段n 字段n类型 <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> 字段n注释 <span class="token punctuation">]</span> 
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 表注释 <span class="token punctuation">]</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="存储引擎的特点" tabindex="-1"><a class="header-anchor" href="#存储引擎的特点" aria-hidden="true">#</a> 存储引擎的特点</h3><p>常用存储引擎的对比</p><table><thead><tr><th>特点</th><th>MyISAM</th><th>InnoDB</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>64TB</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>行锁</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>数据缓存</td><td></td><td>支持</td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>低</td><td>高</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>低</td><td>高</td><td>中登</td><td>低</td><td>高</td></tr><tr><td>批量插入的速度</td><td>高</td><td>低</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td></td><td>支持</td><td></td><td></td><td></td></tr></tbody></table><h4 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb" aria-hidden="true">#</a> InnoDB</h4><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p><h5 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> <strong>特点</strong></h5><ul><li><p>DML操作遵循ACID模型，支持事务；</p></li><li><p>行级锁，提高并发访问性能；</p></li><li><p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p></li><li><p>auto_increment 自增列</p></li></ul><h5 id="auto-increment" tabindex="-1"><a class="header-anchor" href="#auto-increment" aria-hidden="true">#</a> AUTO_INCREMENT</h5><p>自增的值默认从1开始，可以手动指定该值，但指定的值是空或者0，则执行自增的逻辑。</p><p>可以修改自增的初始值<code>ALERT TABLE *** AUTO_INCREMENT = n</code>，但是这个值是保存在内存中的。重启后会失效。</p><p>在InnoDB类型的表中，自增列必须是索引列，如果是组合索引，也必须是组合索引的第一列。</p><h5 id="存储方式" tabindex="-1"><a class="header-anchor" href="#存储方式" aria-hidden="true">#</a> <strong>存储方式</strong></h5><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>show variables like &#39;innodb_file_per_table&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+i+'" alt="image-20220426095518142" style="zoom:50%;"><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的数据存放目录： C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。</p><img src="'+l+'" alt="image-20220426095639059" style="zoom:50%;"><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p><p>数据存储逻辑图</p><p><img src="'+d+'" alt="image-20220426095957217"></p><ul><li><p><strong>表空间 :</strong> InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。</p></li><li><p><strong>段 :</strong> 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</p></li><li><p><strong>区 :</strong> 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p></li><li><p><strong>页 :</strong> 页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p></li><li><p><strong>行 :</strong> InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段</p></li></ul><h4 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam" aria-hidden="true">#</a> <strong>MyISAM</strong></h4><p>MyISAM是MySQL早期的默认存储引擎。</p><h5 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1" aria-hidden="true">#</a> 特点</h5><p>不支持事务，不支持外键。支持表锁，不支持行锁</p><p>访问速度快，对事物没有完整性没有要求的可以使用这个引擎来创建表。</p><h5 id="存储文件结构" tabindex="-1"><a class="header-anchor" href="#存储文件结构" aria-hidden="true">#</a> 存储文件结构</h5><p>每个MyISAM引擎类型的表在磁盘上存储成3个文件，全称如下：</p><ul><li><p>xxx.sdi：存储表结构信息</p></li><li><p>xxx.MYD: 存储数据</p></li><li><p>xxx.MYI: 存储索引</p></li></ul><h4 id="memory" tabindex="-1"><a class="header-anchor" href="#memory" aria-hidden="true">#</a> Memory</h4><p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><h5 id="特点-2" tabindex="-1"><a class="header-anchor" href="#特点-2" aria-hidden="true">#</a> 特点</h5><p>数据在内存中存放，默认使用hash索引，访问非常快。服务关闭后数据丢失。</p><h5 id="文件" tabindex="-1"><a class="header-anchor" href="#文件" aria-hidden="true">#</a> 文件</h5><p>xxx.sdi：存储表结构信息</p><h4 id="区别及特点" tabindex="-1"><a class="header-anchor" href="#区别及特点" aria-hidden="true">#</a> 区别及特点</h4><h3 id="存储引擎的选择" tabindex="-1"><a class="header-anchor" href="#存储引擎的选择" aria-hidden="true">#</a> 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li><p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p></li><li><p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p></li><li><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p></li></ul><h2 id="进阶篇-索引" tabindex="-1"><a class="header-anchor" href="#进阶篇-索引" aria-hidden="true">#</a> 进阶篇-索引</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><h3 id="索引结构" tabindex="-1"><a class="header-anchor" href="#索引结构" aria-hidden="true">#</a> 索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th><strong>索引结构</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td></tr><tr><td>R-tree(空间索引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-text(全文索引)</td><td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</td></tr></tbody></table><p>上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p><img src="'+r+'" alt="image-20220426125410635" style="zoom:33%;"><p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p><img src="'+c+'" alt="image-20220426125454233" style="zoom:33%;"><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p></li><li><p>大数据量情况下，层级较深，检索速度慢。</p></li></ul><p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:</p><img src="'+u+'" alt="image-20220426125558905" style="zoom:33%;"><p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p><ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。</p><h4 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree" aria-hidden="true">#</a> B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p><img src="'+m+'" alt="image-20220426125715435" style="zoom:40%;"><p>特点：</p><ul><li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p></li><li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p></li><li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p></li></ul><h4 id="b-tree-1" tabindex="-1"><a class="header-anchor" href="#b-tree-1" aria-hidden="true">#</a> B+Tree</h4><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p><img src="'+g+'" alt="image-20220426125836198" style="zoom:50%;"><p>我们可以看到，两部分：</p><ul><li><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</p></li><li><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p></li></ul><p>最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别：</p><ul><li><p>所有的数据都会出现在叶子节点。</p></li><li><p>叶子节点形成一个单向链表。</p></li><li><p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p></li></ul><p>上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的B+Tree。</p><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><img src="'+h+'" alt="image-20220426130002472" style="zoom:50%;"><h4 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。</p><h5 id="结构" tabindex="-1"><a class="header-anchor" href="#结构" aria-hidden="true">#</a> 结构</h5><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><img src="'+k+'" alt="image-20220426130112307" style="zoom:50%;"><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><img src="'+b+'" alt="image-20220426130147436" style="zoom:50%;"><h5 id="特点-3" tabindex="-1"><a class="header-anchor" href="#特点-3" aria-hidden="true">#</a> 特点</h5><ul><li><p>Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，...）</p></li><li><p>无法利用索引完成排序操作</p></li><li><p>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p></li></ul><h5 id="存储引擎支持" tabindex="-1"><a class="header-anchor" href="#存储引擎支持" aria-hidden="true">#</a> 存储引擎支持</h5><p>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><blockquote><p>思考题： 为什么InnoDB存储引擎选择使用B+tree索引结构?</p><ul><li><p>相对于二叉树，层级更少，搜索效率高；</p></li><li><p>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p></li><li><p>相对Hash索引，B+tree支持范围匹配及排序操作；</p></li></ul></blockquote><h3 id="索引分类" tabindex="-1"><a class="header-anchor" href="#索引分类" aria-hidden="true">#</a> 索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对与表中主键穿件的索引</td><td>默认自动创建, 只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h4 id="聚集索引-二级索引" tabindex="-1"><a class="header-anchor" href="#聚集索引-二级索引" aria-hidden="true">#</a> 聚集索引&amp;二级索引</h4><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含有</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有,而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul><p>聚集索引和二级索引的具体结构如下：</p><img src="'+v+'" alt="image-20220426132101688" style="zoom:50%;"><ul><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值</p></li></ul><p>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p><img src="'+y+`" alt="image-20220426132221890" style="zoom:50%;"><p>具体过程如下:</p><p>①. 由于是根据name字段进行查询，所以先根据name=&#39;Arm&#39;到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</p><p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</p><p>③. 最终拿到这一行的数据，直接返回即可。</p><blockquote><p><strong>回表查询</strong>： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p><p><strong>思考题：</strong></p><p>以下两条SQL语句，那个执行效率高? 为什么?</p><p>A. select * from user where id = 10 ;</p><p>B. select * from user where name = &#39;Arm&#39; ;</p><p>备注: id为主键，name字段创建的有索引；</p><p>解答：</p><p>A 语句的执行性能要高于B 语句。因为A语句直接走聚集索引，直接返回数据。 而B语句需要先查询name字段的二级索引，然后再查询聚集索引，也就是需要进行回表查询。</p><p><strong>思考题：</strong></p><p>InnoDB主键索引的B+tree高度为多高呢?</p><p>假设:</p><p>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。</p><p>高度为2：</p><p>n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</p><p>1171* 16 = 18736</p><p>也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p><p>高度为3：</p><p>1171 * 1171 * 16 = 21939856</p><p>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p></blockquote><h3 id="索引语法" tabindex="-1"><a class="header-anchor" href="#索引语法" aria-hidden="true">#</a> 索引语法</h3><p>创建索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token punctuation">[</span> <span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token punctuation">]</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span> index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="sql性能分析" tabindex="-1"><a class="header-anchor" href="#sql性能分析" aria-hidden="true">#</a> SQL性能分析</h3><h4 id="sql执行频率" tabindex="-1"><a class="header-anchor" href="#sql执行频率" aria-hidden="true">#</a> SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session 是查看当前会话,默认是此级别; </span>
<span class="token comment">-- global 是查询全局数据 ; </span>
<span class="token keyword">SHOW</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">&#39;Com_%&#39;</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+_+'" alt="image-20220426133035695" style="zoom:50%;"><ul><li><p>Com_delete: 删除次数</p></li><li><p>Com_insert: 插入次数</p></li><li><p>Com_select: 查询次数</p></li><li><p>Com_update: 更新次数</p></li></ul><p>通过下面两个参数可以了解事物的提交和回滚情况：</p><ul><li>Com_commit: 事物提交次数</li><li>Com_rollback: 事物回滚次数</li></ul><p>下面还有几个针对InnoDB存储引擎的参数可以参考：</p><ul><li>Innodb_row_read: Select查询返回的行数</li><li>Innodb_rows_inserted: 执行INSERT操作插入的行数。</li><li>Innodb_rows_updated: 执行UPDATE操作更新的行数</li><li>Innodb_rows_deleted: 执行DELETE操作删除的行数</li></ul><p>通过这几个操作可以很容易了解当前数据库是以插入更新为主，还是以查询操作为主。</p><p>以下几个参数用于了解数据库的基本情况：</p><ul><li>Connections： 试图连接MySQL服务器的次数</li><li>Uptime： 服务器的工作时间</li><li>Slow_queries: 慢查询的次数。</li></ul><h4 id="慢查询日志" tabindex="-1"><a class="header-anchor" href="#慢查询日志" aria-hidden="true">#</a> 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p><img src="'+x+`" alt="image-20220426133244664" style="zoom:50%;"><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 开启MySQL慢日志查询开关 </span>
<span class="token key attr-name">slow_query_log</span><span class="token punctuation">=</span><span class="token value attr-value">1 </span>
<span class="token comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 </span>
<span class="token key attr-name">long_query_time</span><span class="token punctuation">=</span><span class="token value attr-value">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>systemctl restart mysqld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，再次查看开关情况，慢查询日志就已经打开了。</p><p><strong>测试</strong></p><p>执行如下SQL语句 ：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00sec
select count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时 13.35sec
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+f+'" alt="image-20220426133553213" style="zoom:50%;"><p><strong>检查慢查询日志</strong></p><p>最终我们发现，在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的。那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。</p><img src="'+w+`" alt="image-20220426133716953" style="zoom:50%;"><h4 id="profile详情" tabindex="-1"><a class="header-anchor" href="#profile详情" aria-hidden="true">#</a> profile详情</h4><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> @<span class="token variable">@have_profiling</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+q+`" alt="image-20220426133851894" style="zoom:50%;"><p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在session/global级别开启profiling：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> profiling <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user<span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;白起&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_sku<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查看每一条SQL的耗时基本情况 </span>
<span class="token keyword">show</span> profiles<span class="token punctuation">;</span> 
<span class="token comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况 </span>
<span class="token keyword">show</span> profile <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span> 
<span class="token comment">-- 查看指定query_id的SQL语句CPU的使用情况 </span>
<span class="token keyword">show</span> profile cpu <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看每一条SQL的耗时情况:</p><img src="`+L+'" alt="image-20220426134116001" style="zoom:50%;"><p>查看指定SQL各个阶段的耗时情况 :</p><img src="'+S+`" alt="image-20220426134155085" style="zoom:50%;"><p>MySQL支持进一步选择all、cpu、block io、context、switch、page faults等明细类型来查看MySQL在使用什么资源上耗费了过高的时间。</p><h4 id="explain" tabindex="-1"><a class="header-anchor" href="#explain" aria-hidden="true">#</a> explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>语法:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 直接在select语句之前加上关键字 explain / desc </span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+D+'" alt="image-20220426134818605" style="zoom:50%;"><p>Explain 执行计划中各个字段的含义:</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 <br>SIMPLE（简单表，即不使用表连接或者子查询）、<br>PRIMARY（主查询，即外层的查询）、<br>UNION（UNION 中的第二个或者后面的查询语句）、<br>SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示MySQL在表中找到所需行的方式，或者叫访问类型，常见类型如下：<br>type=ALL： 全表扫描，Mysql遍历全表来找到匹配行<br>type=index：索引全扫描，Mysql遍历整个索引来查询匹配的行，<br>type=range：索引范围扫描，常见于&lt;，&lt;=，&gt;，&gt;=，between等操作。<br>type=ref：使用非唯一索引(不是UNIQUE类型的索引)扫描或唯一索引的前缀扫描，返回匹配某个单独值的记录行。<br>type=eq_ref：使用唯一索引扫描（例如：锁表连接中使用primary key或者unique key作为关联条件）<br>type=const/system：单表中只有一行匹配，查询非常迅速，例如通过primary key 或者 unique key 进行查询。<br>type=NULL：MySQL不用访问索引，就能获取结果。</td></tr><tr><td>possible_key</td><td>表示查询是可能使用的索引</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr></tbody></table><h3 id="索引使用" tabindex="-1"><a class="header-anchor" href="#索引使用" aria-hidden="true">#</a> 索引使用</h3><h4 id="最左前缀法则" tabindex="-1"><a class="header-anchor" href="#最左前缀法则" aria-hidden="true">#</a> 最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。</p><img src="'+B+`" alt="image-20220426135255321" style="zoom:50%;"><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。</p><p>对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下</p><p>具体的执行计划：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+I+`" alt="image-20220426135401081" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+M+`" alt="image-20220426135541380" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+E+`" alt="image-20220426135632221" style="zoom:50%;"><p>以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age字段索引长度为2、status字段索引长度为5。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+z+`" alt="image-20220426135730402" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Q+`" alt="image-20220426135807560" style="zoom:50%;"><p>而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+R+'" alt="image-20220426135900534" style="zoom:50%;"><p>上述的SQL查询时，存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。</p><blockquote><p>思考题：</p><p>当执行SQL语句: explain select * from tb_user where age = 31 and status = &#39;0&#39; and profession = &#39;软件工程&#39;； 时，是否满足最左前缀法则，走不走上述的联合索引，索引长度？</p><img src="'+T+`" alt="image-20220426140032442" style="zoom:50%;"><p>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></blockquote><h4 id="范围查询" tabindex="-1"><a class="header-anchor" href="#范围查询" aria-hidden="true">#</a> 范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">&gt;</span> <span class="token number">30</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+A+`" alt="image-20220426140210209" style="zoom:50%;"><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">&gt;=</span> <span class="token number">30</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h4 id="索引失效情况" tabindex="-1"><a class="header-anchor" href="#索引失效情况" aria-hidden="true">#</a> 索引失效情况</h4><h5 id="索引列运算" tabindex="-1"><a class="header-anchor" href="#索引列运算" aria-hidden="true">#</a> 索引列运算</h5><p>不要在索引列上进行运算操作， 索引将失效。</p><p>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p>当根据phone字段进行等值匹配查询时, 索引生效。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+C+`" alt="image-20220426140525159" style="zoom:50%;"><p>当根据phone字段进行函数运算操作之后，索引失效。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from tb_user where substring(phone,10,2) = &#39;15&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+U+`" alt="image-20220426140602887" style="zoom:50%;"><h5 id="字符串不加引号" tabindex="-1"><a class="header-anchor" href="#字符串不加引号" aria-hidden="true">#</a> 字符串不加引号</h5><p>字符串类型字段使用时，不加引号，索引将失效。</p><p>接下来，我们通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+O+`" alt="image-20220426140707371" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">17799990015</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+N+`" alt="image-20220426140843786" style="zoom:50%;"><p>经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。</p><h5 id="模糊查询" tabindex="-1"><a class="header-anchor" href="#模糊查询" aria-hidden="true">#</a> 模糊查询</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>接下来，我们来看一下这三条SQL语句的执行效果，查看一下其执行计划：</p><p>由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的，我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;软件%&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;%工程&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;%工%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+P+`" alt="image-20220426141016243" style="zoom:50%;"><p>经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。</p><h5 id="or连接条件" tabindex="-1"><a class="header-anchor" href="#or连接条件" aria-hidden="true">#</a> or连接条件</h5><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990017&#39;</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+V+`" alt="image-20220426141147408" style="zoom:50%;"><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><p>然后，我们可以对age字段建立索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>建立了索引之后，我们再次执行上述的SQL语句，看看前后执行计划的变化。</p><img src="`+H+`" alt="image-20220426141312971" style="zoom:50%;"><p>最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><h5 id="数据分布影响" tabindex="-1"><a class="header-anchor" href="#数据分布影响" aria-hidden="true">#</a> 数据分布影响</h5><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;17799990005&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+X+`" alt="image-20220426141420100" style="zoom:50%;"><p>经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？</p><p>就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p><p>接下来，我们再来看看 is null 与 is not null 操作是否走索引。</p><p>执行如下两条语句 ：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">is</span> <span class="token boolean">null</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+W+'" alt="image-20220426141550959" style="zoom:50%;"><p>接下来，我们做一个操作将profession字段值全部更新为null。然后，再次执行上述的两条SQL，查看SQL语句的执行计划。</p><img src="'+F+'" alt="image-20220426141639442" style="zoom:50%;"><p>最终我们看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。</p><h4 id="sql提示" tabindex="-1"><a class="header-anchor" href="#sql提示" aria-hidden="true">#</a> SQL提示</h4><p>目前tb_user表的数据情况如下:</p><img src="'+G+'" alt="image-20220426142000554" style="zoom:50%;"><p>索引情况如下:</p><img src="'+K+`" alt="image-20220426142104568" style="zoom:50%;"><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>drop index idx_user_age on tb_user; 
drop index idx_email on tb_user;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行SQL : explain select * from tb_user where profession = &#39;软件工程&#39;;</p><img src="`+Y+'" alt="image-20220426144116562" style="zoom:50%;"><p>查询走了联合索引。</p><p>执行SQL，创建profession的单列索引：create index idx_user_pro on tb_user(profession);</p><p>创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。</p><img src="'+J+`" alt="image-20220426144253275" style="zoom:50%;"><p>测试结果，我们可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p><p>那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于MySQL的SQL提示来完成。 接下来，介绍一下SQL提示。</p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2). ignore index ： 忽略指定的索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">ignore</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3). force index ： 强制使用索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h4><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p><p>接下来，我们来看一组SQL的执行计划，看看执行计划的差别，然后再来具体做一个解析。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span> profession <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> <span class="token keyword">status</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">,</span> name <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软 件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述这几条SQL的执行结果为:</p><img src="`+j+'" alt="image-20220426144634023" style="zoom:50%;"><p>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 Using where; UsingIndex ; 而后面两条SQL的结果为: Using index condition 。</p><table><thead><tr><th><strong>Extra</strong></th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><p>为了大家更清楚的理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组SQL的执行过程。</p><p>A. 表结构及索引示意图:</p><p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p><img src="'+Z+'" alt="image-20220426144946484" style="zoom:50%;"><p>B. 执行SQL : select * from tb_user where id = 2;</p><p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><img src="'+$+'" alt="image-20220426145016039" style="zoom:50%;"><p>C. 执行SQL：selet id,name from tb_user where name = &#39;Arm&#39;;</p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p><img src="'+ss+'" alt="image-20220426145143737" style="zoom:50%;"><p>D. 执行SQL：selet id,name,gender from tb_user where name = &#39;Arm&#39;;</p><p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。</p><img src="'+as+`" alt="image-20220426145216169" style="zoom:50%;"><blockquote><p>思考题：</p><p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案:</p><p>select id,username,password from tb_user where username =&#39;itcast&#39;;</p><p>答案: 针对于 username, password建立联合索引, sql为: create index</p><p>idx_user_name_pass on tb_user(username,password);</p><p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p></blockquote><h4 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引" aria-hidden="true">#</a> 前缀索引</h4><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p><strong>创建前缀索引的语法：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>create index idx_xxxx on table_name(column(n)) ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>前缀长度</strong></p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p><strong>前缀索引的查询流程</strong></p><img src="`+es+'" alt="image-20220426145536751" style="zoom:50%;"><h4 id="单列索引与联合索引" tabindex="-1"><a class="header-anchor" href="#单列索引与联合索引" aria-hidden="true">#</a> 单列索引与联合索引</h4><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>我们先来看看 tb_user 表中目前的索引情况:</p><img src="'+ns+'" alt="image-20220426145743018" style="zoom:50%;"><p>在查询出来的索引中，既有单列索引，又有联合索引。</p><p>接下来，我们来执行一条SQL语句，看看其执行计划：</p><img src="'+ts+`" alt="image-20220426145819299" style="zoom:50%;"><p>通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p><p>紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>create unique index idx_user_phone_name on tb_user(phone,name);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+ps+'" alt="image-20220426145904194" style="zoom:50%;"><p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。</p><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><img src="'+os+`" alt="image-20220426145933220" style="zoom:50%;"><h3 id="索引设计原则" tabindex="-1"><a class="header-anchor" href="#索引设计原则" aria-hidden="true">#</a> 索引设计原则</h3><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p><p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，可以更好地确定哪个索引最有效地用于查询。</p><h2 id="进阶篇-sql优化" tabindex="-1"><a class="header-anchor" href="#进阶篇-sql优化" aria-hidden="true">#</a> 进阶篇-SQL优化</h2><h3 id="插入数据" tabindex="-1"><a class="header-anchor" href="#插入数据" aria-hidden="true">#</a> <strong>插入数据</strong></h3><p>一次性插入多条记录，可以从以下三个方面进行优化</p><ul><li>批量插入数据</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">Insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>手动控制事务</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> 
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>主键顺序插入，性能要高于乱序插入。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3 
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="大批量插入数据" tabindex="-1"><a class="header-anchor" href="#大批量插入数据" aria-hidden="true">#</a> 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：</p><img src="`+is+`" alt="image-20220426150616520" style="zoom:50%;"><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile </span>
mysql –<span class="token operator">-</span><span class="token keyword">local</span><span class="token operator">-</span><span class="token keyword">infile</span> <span class="token operator">-</span>u root <span class="token operator">-</span>p 
<span class="token comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 </span>
<span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token comment">-- 执行load指令将准备好的数据，加载到表结构中 </span>
<span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">&#39;/root/sql1.log&#39;</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;,&#39;</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;\\n&#39;</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="主键优化" tabindex="-1"><a class="header-anchor" href="#主键优化" aria-hidden="true">#</a> 主键优化</h3><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p><h4 id="数据组织方式" tabindex="-1"><a class="header-anchor" href="#数据组织方式" aria-hidden="true">#</a> 数据组织方式</h4><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p><img src="`+ls+'" alt="image-20220426150834107" style="zoom:50%;"><p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p><img src="'+ds+'" alt="image-20220426150905721" style="zoom:50%;"><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。</p><h4 id="页分裂" tabindex="-1"><a class="header-anchor" href="#页分裂" aria-hidden="true">#</a> 页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><h5 id="a-主键顺序插入效果" tabindex="-1"><a class="header-anchor" href="#a-主键顺序插入效果" aria-hidden="true">#</a> A. 主键顺序插入效果</h5><p>①. 从磁盘中申请页， 主键顺序插入</p><img src="'+rs+'" alt="image-20220426151017038" style="zoom:50%;"><p>②. 第一个页没有满，继续往第一页插入</p><img src="'+cs+'" alt="image-20220426151103028" style="zoom:50%;"><p>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><img src="'+us+'" alt="image-20220426151138823" style="zoom:50%;"><p>④. 当第二页写满了，再往第三页写入</p><img src="'+ms+'" alt="image-20220426151214000" style="zoom:50%;"><h5 id="b-主键乱序插入效果" tabindex="-1"><a class="header-anchor" href="#b-主键乱序插入效果" aria-hidden="true">#</a> B. 主键乱序插入效果</h5><p>①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p><img src="'+gs+'" alt="image-20220426151343299" style="zoom:50%;"><p>②. 此时再插入id为50的记录，我们来看看会发生什么现象，会再次开启一个页，写入新的页中吗？</p><img src="'+hs+'" alt="image-20220426151436767" style="zoom:50%;"><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><img src="'+ks+'" alt="image-20220426151507616" style="zoom:50%;"><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><img src="'+bs+'" alt="image-20220426151533629" style="zoom:50%;"><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><img src="'+vs+'" alt="image-20220426151559527" style="zoom:50%;"><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p><img src="'+ys+'" alt="image-20220426151629960" style="zoom:50%;"><p>上述的这种现象，称之为 &quot;页分裂&quot;，是比较耗费性能的操作。</p><h4 id="页合并" tabindex="-1"><a class="header-anchor" href="#页合并" aria-hidden="true">#</a> 页合并</h4><p>目前表中已有数据的索引结构(叶子节点)如下：</p><img src="'+_s+'" alt="image-20220426151753238" style="zoom:50%;"><p>当我们对已有数据进行删除时，具体的效果如下:</p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><img src="'+xs+'" alt="image-20220426151816649" style="zoom:50%;"><p>当我们继续删除2#的数据记录</p><img src="'+fs+'" alt="image-20220426151833513" style="zoom:50%;"><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><img src="'+ws+'" alt="image-20220426151913875" style="zoom:50%;"><p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p><img src="'+qs+'" alt="image-20220426151931681" style="zoom:50%;"><p>这个里面所发生的合并页的这个现象，就称之为 &quot;页合并&quot;。</p><blockquote><p>知识小贴士：</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p></blockquote><h4 id="索引设计原则-1" tabindex="-1"><a class="header-anchor" href="#索引设计原则-1" aria-hidden="true">#</a> 索引设计原则</h4><ul><li><p>满足业务需求的情况下，尽量降低主键的长度。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p></li><li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p></li><li><p>业务操作时，避免对主键的修改。</p></li></ul><img src="'+Ls+'" alt="image-20220426152045680" style="zoom:50%;"><h3 id="order-by-优化" tabindex="-1"><a class="header-anchor" href="#order-by-优化" aria-hidden="true">#</a> order by 优化</h3><p>MySQL的排序，有两种方式：</p><p><strong>Using filesort :</strong> 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p><strong>Using index :</strong> 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p><p>接下来，我们来做一个测试：</p><h4 id="查看索引" tabindex="-1"><a class="header-anchor" href="#查看索引" aria-hidden="true">#</a> 查看索引</h4><img src="'+Ss+`" alt="image-20220426152313693" style="zoom:50%;"><h4 id="执行排序sql" tabindex="-1"><a class="header-anchor" href="#执行排序sql" aria-hidden="true">#</a> 执行排序SQL</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Ds+`" alt="image-20220426152358277" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">,</span> phone <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Bs+`" alt="image-20220426152439578" style="zoom:50%;"><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p><h4 id="创建索引" tabindex="-1"><a class="header-anchor" href="#创建索引" aria-hidden="true">#</a> 创建索引</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 创建索引 </span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age_phone_aa <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age<span class="token punctuation">,</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="执行升序排序" tabindex="-1"><a class="header-anchor" href="#执行升序排序" aria-hidden="true">#</a> 执行升序排序</h4><p>创建索引后，根据age, phone进行升序排序</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Is+`" alt="image-20220426153204338" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token punctuation">,</span> phone<span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Ms+`" alt="image-20220426153230444" style="zoom:50%;"><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了。</p><h4 id="进行降序排序" tabindex="-1"><a class="header-anchor" href="#进行降序排序" aria-hidden="true">#</a> 进行降序排序</h4><p>创建索引后，根据age, phone进行降序排序</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">desc</span> <span class="token punctuation">,</span> phone <span class="token keyword">desc</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Es+`" alt="image-20220426153351875" style="zoom:50%;"><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><h4 id="失效情况" tabindex="-1"><a class="header-anchor" href="#失效情况" aria-hidden="true">#</a> 失效情况</h4><p>根据phone，age进行升序排序，phone在前，age在后。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> phone <span class="token punctuation">,</span> age<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+zs+`" alt="image-20220426153508957" style="zoom:50%;"><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><p>根据age, phone进行降序一个升序，一个降序</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">asc</span> <span class="token punctuation">,</span> phone <span class="token keyword">desc</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Qs+`" alt="image-20220426153619040" style="zoom:50%;"><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort。</p><p>为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序，phone 倒序排序。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age_phone_ad <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age <span class="token keyword">asc</span> <span class="token punctuation">,</span>phone <span class="token keyword">desc</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>升序/降序联合索引结构图示:</p><img src="`+Rs+'" alt="image-20220426153729688" style="zoom:50%;"><img src="'+Ts+'" alt="image-20220426153740747" style="zoom:50%;"><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><p>由上述的测试,我们得出order by优化原则:</p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</p><h3 id="group-by-优化" tabindex="-1"><a class="header-anchor" href="#group-by-优化" aria-hidden="true">#</a> group by 优化</h3><p>分组操作，我们主要来看看索引对于分组操作的影响。</p><p>首先我们先将 tb_user 表的索引全部删除掉 。</p><img src="'+As+`" alt="image-20220426154028829" style="zoom:50%;"><p>接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> profession <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Cs+`" alt="image-20220426154100621" style="zoom:50%;"><p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_pro_age_sta <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>profession <span class="token punctuation">,</span> age <span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>紧接着，再执行前面相同的SQL查看执行计划。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> profession <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Us+'" alt="image-20220426154150695" style="zoom:50%;"><img src="'+Os+'" alt="image-20220426154257324" style="zoom:50%;"><img src="'+Ns+'" alt="image-20220426154316395" style="zoom:50%;"><p>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的。</p><h5 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结：</h5><p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><ul><li><p>在分组操作时，可以通过索引来提高效率。</p></li><li><p>分组操作时，索引的使用也是满足最左前缀法则的。</p></li></ul><h3 id="limit优化" tabindex="-1"><a class="header-anchor" href="#limit优化" aria-hidden="true">#</a> limit优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>我们一起来看看执行limit分页查询耗时对比：</p><img src="'+Ps+`" alt="image-20220426154659445" style="zoom:50%;"><p>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。</p><p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="count优化" tabindex="-1"><a class="header-anchor" href="#count优化" aria-hidden="true">#</a> count优化</h3><p>在测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p><ul><li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p></li><li><p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p></li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</p><h4 id="count用法" tabindex="-1"><a class="header-anchor" href="#count用法" aria-hidden="true">#</a> count用法</h4><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（数字）</p><table><thead><tr><th>count用法</th><th>含义</th></tr></thead><tbody><tr><td>count(主键)</td><td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)</td></tr><tr><td>count(字段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr><tr><td>count(数字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</td></tr><tr><td>count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr></tbody></table><blockquote><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，</p><p>所以尽量使用 count(*)。</p></blockquote><h3 id="update优化" tabindex="-1"><a class="header-anchor" href="#update优化" aria-hidden="true">#</a> update优化</h3><p>我们主要需要注意一下update语句执行时的注意事项。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>update course set name = &#39;javaEE&#39; where id = 1 ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p><p>但是当我们在执行如下SQL时。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>update course set name = &#39;SpringBoot&#39; where name = &#39;PHP&#39; ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</p><blockquote><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p></blockquote><h2 id="进阶篇-视图-存储-触发器" tabindex="-1"><a class="header-anchor" href="#进阶篇-视图-存储-触发器" aria-hidden="true">#</a> 进阶篇-视图/存储/触发器</h2><p>TODO</p><h2 id="进阶篇-锁" tabindex="-1"><a class="header-anchor" href="#进阶篇-锁" aria-hidden="true">#</a> 进阶篇-锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li><p>全局锁：锁定数据库中的所有表。</p></li><li><p>表级锁：每次操作锁住整张表。</p></li><li><p>行级锁：每次操作锁住对应的行数据。</p></li></ul><h3 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁" aria-hidden="true">#</a> 全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>为什么全库逻辑备份，就需要加全就锁呢？</p><p><strong>A. 我们一起先来分析一下不加全局锁，可能存在的问题。</strong></p><p>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。</p><img src="`+Vs+'" alt="image-20220426155608697" style="zoom:50%;"><ul><li><p>在进行数据备份时，先备份了tb_stock库存表。</p></li><li><p>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</p></li><li><p>然后再执行备份 tb_order表的逻辑。</p></li><li><p>业务中执行插入订单日志操作。</p></li><li><p>最后，又备份了tb_orderlog表。</p></li></ul><p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)。</p><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p><strong>B. 再来分析一下加了全局锁后的情况</strong></p><img src="'+Hs+`" alt="image-20220426155839152" style="zoom:50%;"><p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p><h4 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h4><p>1). 加全局锁</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flush tables with read lock ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2). 数据备份</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysqldump -uroot –p1234 itcast &gt; itcast.sql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数据备份的相关指令, 在后面MySQL管理章节, 还会详细讲解.</p><p>3). 释放锁</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>unlock tables ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="特点-4" tabindex="-1"><a class="header-anchor" href="#特点-4" aria-hidden="true">#</a> 特点</h4><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁" aria-hidden="true">#</a> 表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li><p>表锁</p></li><li><p>元数据锁（meta data lock，MDL）</p></li><li><p>意向锁</p></li></ul><h4 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁" aria-hidden="true">#</a> 表锁</h4><p>对于表锁，分为两类：</p><ul><li><p>表共享读锁（read lock）</p></li><li><p>表独占写锁（write lock）</p></li></ul><p><strong>语法：</strong></p><ul><li><p>加锁：lock tables 表名... read/write。</p></li><li><p>释放锁：unlock tables / 客户端断开连接 。</p></li></ul><p><strong>特点:</strong></p><p>A. 读锁</p><p>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</p><img src="`+Xs+'" alt="image-20220426160414695" style="zoom:50%;"><p>B. 写锁</p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p><img src="'+Ws+'" alt="image-20220426160456612" style="zoom:50%;"><blockquote><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p></blockquote><h4 id="元数据锁" tabindex="-1"><a class="header-anchor" href="#元数据锁" aria-hidden="true">#</a> 元数据锁</h4><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p><p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><p>常见的SQL操作时，所添加的元数据锁：</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read /write</td><td>SHARED_READ_ONLY /SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select ... lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select ... for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table ...</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><h4 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁" aria-hidden="true">#</a> 意向锁</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><img src="'+Fs+'" alt="image-20220426161203823" style="zoom:50%;"><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。</p><img src="'+Gs+'" alt="image-20220426161235688" style="zoom:50%;"><p>有了意向锁之后 :</p><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p><img src="'+Ks+'" alt="image-20220426161359156" style="zoom:50%;"><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p><img src="'+Ys+'" alt="image-20220426161508026" style="zoom:50%;"><p>总结：</p><ul><li><p>意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</p></li><li><p>意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</p></li></ul><blockquote><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p></blockquote><h3 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁" aria-hidden="true">#</a> 行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p><img src="'+Js+'" alt="image-20220426161744776" style="zoom:50%;"></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p></li></ul><img src="'+js+'" alt="image-20220426161827629" style="zoom:50%;"><ul><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</li></ul><img src="'+Zs+'" alt="image-20220426161908510" style="zoom:50%;"><h4 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁" aria-hidden="true">#</a> 行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</p></li></ul><p>两种行锁的兼容情况如下:</p><img src="'+$s+`" alt="image-20220426162017022" style="zoom:50%;"><p>常见的SQL语句，在执行时，所加的行锁如下：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT ...</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE ...</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE ...</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT ... LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT ... FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p><strong>演示</strong></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</p></li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="间隙锁-临键锁" tabindex="-1"><a class="header-anchor" href="#间隙锁-临键锁" aria-hidden="true">#</a> 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p></li><li><p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</p></li><li><p>索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。</p></li></ul><blockquote><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p></blockquote><p>A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p><img src="`+sa+'" alt="image-20220426163450919" style="zoom:50%;"><p>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</p><p>介绍分析一下：</p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p><img src="'+aa+'" alt="image-20220426163540635" style="zoom:50%;"><img src="'+ea+'" alt="image-20220426163601381" style="zoom:50%;"><p>C. 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。</p><img src="'+na+'" alt="image-20220426163645003" style="zoom:50%;"><p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：</p><p>[19]</p><p>(19,25]</p><p>(25,+∞]</p><p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p><h2 id="进阶篇-innodb引擎" tabindex="-1"><a class="header-anchor" href="#进阶篇-innodb引擎" aria-hidden="true">#</a> 进阶篇-InnoDB引擎</h2><h3 id="逻辑存储结构" tabindex="-1"><a class="header-anchor" href="#逻辑存储结构" aria-hidden="true">#</a> 逻辑存储结构</h3><p>InnoDB的逻辑存储结构如下图所示:</p><img src="'+ta+'" alt="image-20220427080239097" style="zoom:50%;"><p>**表空间 ：**表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>**段：**分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p>**区：**表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><p>**页：**是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p>**行：**InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段：</p><ul><li><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</p></li><li><p>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p></li></ul><h3 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><img src="'+pa+`" alt="image-20220427080814476" style="zoom:50%;"><h4 id="内存结构" tabindex="-1"><a class="header-anchor" href="#内存结构" aria-hidden="true">#</a> 内存结构</h4><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、AdaptiveHash Index、Log Buffer。 接下来介绍一下这四个部分。</p><h5 id="buffer-pool" tabindex="-1"><a class="header-anchor" href="#buffer-pool" aria-hidden="true">#</a> Buffer Pool</h5><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li><p>free page：空闲page，未被使用。</p></li><li><p>clean page：被使用page，数据没有被修改过。</p></li><li><p>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</p></li></ul><p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> show variables like &#39;innodb_buffer_pool_size&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+oa+'" alt="image-20220427081105843" style="zoom:50%;"><h5 id="change-buffer" tabindex="-1"><a class="header-anchor" href="#change-buffer" aria-hidden="true">#</a> Change Buffer</h5><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义是什么呢?</p><p>先来看一幅图，这个是二级索引的结构图：</p><img src="'+ia+'" alt="image-20220427081201997" style="zoom:50%;"><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><h5 id="adaptive-hash-index" tabindex="-1"><a class="header-anchor" href="#adaptive-hash-index" aria-hidden="true">#</a> Adaptive Hash Index</h5><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</strong></p><p>参数： adaptive_hash_index</p><h5 id="log-buffer" tabindex="-1"><a class="header-anchor" href="#log-buffer" aria-hidden="true">#</a> Log Buffer</h5><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p><p>参数:</p><p>innodb_log_buffer_size：缓冲区大小</p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><ul><li><p>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p></li><li><p>0: 每秒将日志写入并刷新到磁盘一次。</p></li><li><p>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p></li></ul><img src="'+la+'" alt="image-20220427081356587" style="zoom:50%;"><h4 id="磁盘结构" tabindex="-1"><a class="header-anchor" href="#磁盘结构" aria-hidden="true">#</a> 磁盘结构</h4><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：</p><img src="'+da+'" alt="image-20220427081505911" style="zoom:50%;"><h5 id="system-tablespace" tabindex="-1"><a class="header-anchor" href="#system-tablespace" aria-hidden="true">#</a> System Tablespace</h5><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><p>参数：innodb_data_file_path</p><img src="'+ra+'" alt="image-20220427081601090" style="zoom:50%;"><p>系统表空间，默认的文件名叫 ibdata1。</p><h5 id="file-per-table-tablespaces" tabindex="-1"><a class="header-anchor" href="#file-per-table-tablespaces" aria-hidden="true">#</a> File-Per-Table Tablespaces</h5><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：innodb_file_per_table ，该参数默认开启。</p><img src="'+ca+'" alt="image-20220427081942107" style="zoom:50%;"><p>那也就是说，我们每创建一个表，都会产生一个表空间文件，如图：</p><img src="'+ua+`" alt="image-20220427082018336" style="zoom:50%;"><h5 id="general-tablespaces" tabindex="-1"><a class="header-anchor" href="#general-tablespaces" aria-hidden="true">#</a> General Tablespaces</h5><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>A. 创建表空间</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+ma+`" alt="image-20220427082223707" style="zoom:50%;"><p>B. 创建表时指定表空间</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE xxx ... TABLESPACE ts_name;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+ga+'" alt="image-20220427082337252" style="zoom:50%;"><h5 id="undo-tablespaces" tabindex="-1"><a class="header-anchor" href="#undo-tablespaces" aria-hidden="true">#</a> Undo Tablespaces</h5><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p><p>这里要需要说明一下，在MySQL5.6.3之前的版本中，这个<code>undo tablespace</code>是和<code>system tablespace</code>系统表空间存放在一起的，也就是没有单独的<code>undo log</code>文件，直接存放在<code>ibdata1</code>文件里边，在<code>MySQL5.6.3</code>之后的版本中，MySQL支持将undo log tablespace单独剥离出来，但这个特性依然很鸡肋：</p><ol><li>要在安装数据库的时候，就指定好独立undo tablespace，在安装完成后不可更改；</li><li>undo tablespace的space id必须从1开始，无法增加或者删除undo tablespace；</li></ol><p>到了<code>MySQL5.7</code>版本，终于引入期待已久的功能：即在线truncate undo tablespace（解决了第一个鸡肋点，可以在安装数据库之后更改undo tablespace）</p><p>在<code>MySQL8.0</code>中，InnoDB再进一步，对undo log做了进一步的改进：</p><ol><li><strong>从8.0.3版本开始，默认undo tablespace的个数从0调整为2</strong>，也就是在8.0版本中，独立undo tablespace被默认打开。修改该参数为0会报warning并在未来不再支持；</li><li>无需从space_id 1开始创建undo tablespace，这样解决了In-place upgrade或者物理恢复到一个打开了Undo tablespace的实例所产生的space id冲突。不过依然要求undo tablespace的space id是连续分配的；</li></ol><h5 id="temporary-tablespaces" tabindex="-1"><a class="header-anchor" href="#temporary-tablespaces" aria-hidden="true">#</a> Temporary Tablespaces</h5><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><h5 id="doublewrite-buffer-files" tabindex="-1"><a class="header-anchor" href="#doublewrite-buffer-files" aria-hidden="true">#</a> Doublewrite Buffer Files</h5><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><img src="'+ha+'" alt="image-20220427082511506" style="zoom:50%;"><h5 id="redo-log" tabindex="-1"><a class="header-anchor" href="#redo-log" aria-hidden="true">#</a> Redo Log</h5><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：</p><img src="'+ka+'" alt="image-20220427082652621" style="zoom:50%;"><h4 id="后台线程" tabindex="-1"><a class="header-anchor" href="#后台线程" aria-hidden="true">#</a> 后台线程</h4><p>前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。</p><img src="'+ba+'" alt="image-20220427082857707" style="zoom:50%;"><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</p><p>1). Master Thread</p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p>2). IO Thread</p><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IOThread主要负责这些IO请求的回调。</p><p>TODO</p><h3 id="事务原理" tabindex="-1"><a class="header-anchor" href="#事务原理" aria-hidden="true">#</a> 事务原理</h3><h4 id="事务基础" tabindex="-1"><a class="header-anchor" href="#事务基础" aria-hidden="true">#</a> 事务基础</h4><p>1). 事务</p><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>2). 特性</p><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul><p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><img src="'+va+'" alt="image-20220427083211638" style="zoom:50%;"><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，加上MVCC来保证的。</p><img src="'+ya+'" alt="image-20220427083250837" style="zoom:50%;"><p>我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</p><h4 id="redo-log-1" tabindex="-1"><a class="header-anchor" href="#redo-log-1" aria-hidden="true">#</a> redo log</h4><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><img src="'+_a+'" alt="image-20220427083538516" style="zoom:50%;"><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。</p><img src="'+xa+'" alt="image-20220427083611859" style="zoom:50%;"><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h4 id="undo-log" tabindex="-1"><a class="header-anchor" href="#undo-log" aria-hidden="true">#</a> undo log</h4><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相应的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个undo log segment。</p><h3 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc" aria-hidden="true">#</a> MVCC</h3><h4 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h4><h5 id="当前读" tabindex="-1"><a class="header-anchor" href="#当前读" aria-hidden="true">#</a> 当前读</h5><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ... for update、update、insert、delete(排他锁)都是一种当前读。</p><p>测试：</p><img src="'+fa+'" alt="image-20220427084241423" style="zoom:50%;"><p>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p><h5 id="快照读" tabindex="-1"><a class="header-anchor" href="#快照读" aria-hidden="true">#</a> 快照读</h5><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><p>测试:</p><img src="'+wa+'" alt="image-20220427084502280" style="zoom:50%;"><p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><h5 id="mvcc-1" tabindex="-1"><a class="header-anchor" href="#mvcc-1" aria-hidden="true">#</a> MVCC</h5><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从而来介绍一下MVCC的原理。</p><h4 id="隐藏字段" tabindex="-1"><a class="header-anchor" href="#隐藏字段" aria-hidden="true">#</a> 隐藏字段</h4><h5 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h5><img src="'+qa+`" alt="image-20220427084719578" style="zoom:50%;"><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><table><thead><tr><th><strong>隐藏字段</strong></th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p><h5 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h5><p>查看有主键的表 stu</p><p>进入服务器中的 /var/lib/mysql/itcast/ , 查看stu的表结构信息, 通过如下指令:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ibd2sdi stu.ibd 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID隐藏字段。</p><img src="`+La+'" alt="image-20220427090457189" style="zoom:50%;"><img src="'+Sa+`" alt="image-20220427090527928" style="zoom:50%;"><p>查看没有主键的表 employee</p><p>建表语句：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>create table employee (id int , name varchar(10));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ibd2sdi employee.ibd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有指定主键的。</p><h4 id="undolog" tabindex="-1"><a class="header-anchor" href="#undolog" aria-hidden="true">#</a> undolog</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><h5 id="版本链" tabindex="-1"><a class="header-anchor" href="#版本链" aria-hidden="true">#</a> 版本链</h5><p>有一张表原始数据为：</p><img src="`+Da+'" alt="image-20220427090814049" style="zoom:50%;"><blockquote><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</p><p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p></blockquote><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步</p><img src="'+Ba+'" alt="image-20220427090918139" style="zoom:50%;"><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><img src="'+Ia+'" alt="image-20220427091020709" style="zoom:50%;"><p>B.第二步</p><img src="'+Ma+'" alt="image-20220427091058108" style="zoom:50%;"><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><img src="'+Ea+'" alt="image-20220427091138980" style="zoom:50%;"><p>C. 第三步</p><img src="'+za+'" alt="image-20220427091218848" style="zoom:50%;"><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><img src="'+Qa+'" alt="image-20220427091253293" style="zoom:50%;"><blockquote><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条</p><p>记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote><h4 id="readview" tabindex="-1"><a class="header-anchor" href="#readview" aria-hidden="true">#</a> readview</h4><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id ==creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事务更改的。</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了。</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在ReadView生成后才开启。</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果trx_id不在m_ids中，是可以访问该版本的</td><td>成立，说明数据已经提交。</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</p></li><li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul><h4 id="原理分析" tabindex="-1"><a class="header-anchor" href="#原理分析" aria-hidden="true">#</a> 原理分析</h4><h5 id="rc隔离级别" tabindex="-1"><a class="header-anchor" href="#rc隔离级别" aria-hidden="true">#</a> RC隔离级别</h5><p>RC隔离级别下，在事务中每一次执行快照读时都会生成ReadView。</p><p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p><img src="'+Ra+'" alt="image-20220427093322038" style="zoom:50%;"><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><p>先来看第一次快照读具体的读取过程：</p><img src="'+s+'" alt="image-20220427093417945" style="zoom:50%;"><img src="'+a+'" alt="image-20220427093449949" style="zoom:50%;"><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配，在遇到第一条复合的记录后，就直接返回了</p><p>这里返回的是0x00002对应的记录</p><blockquote><p>这么多判断就是为了判断一件事：</p><p><strong>当前记录对应的事物id是否是活跃的事物id，如果活跃，就不可以访问，反之，可以访问</strong></p></blockquote><p>B. 再来看第二次快照读具体的读取过程:</p><img src="'+s+'" alt="image-20220427093417945" style="zoom:50%;"><img src="'+a+'" alt="image-20220427093449949" style="zoom:50%;"><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配，在遇到第一条复合的记录后，就直接返回了</p><p>这里返回的是0x00003对应的记录</p><h5 id="rr隔离级别" tabindex="-1"><a class="header-anchor" href="#rr隔离级别" aria-hidden="true">#</a> RR隔离级别</h5><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><img src="'+Ta+'" alt="image-20220427095606457" style="zoom:50%;"><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><img src="'+Aa+`" alt="image-20220427095709975" style="zoom:50%;"><h2 id="进阶篇-mysql管理" tabindex="-1"><a class="header-anchor" href="#进阶篇-mysql管理" aria-hidden="true">#</a> 进阶篇-MySQL管理</h2><h3 id="系统数据库" tabindex="-1"><a class="header-anchor" href="#系统数据库" aria-hidden="true">#</a> 系统数据库</h3><p>Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便 DBA 和开发人员利用 performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h3 id="常用工具" tabindex="-1"><a class="header-anchor" href="#常用工具" aria-hidden="true">#</a> 常用工具</h3><h4 id="nysql" tabindex="-1"><a class="header-anchor" href="#nysql" aria-hidden="true">#</a> nysql</h4><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法 ：
	mysql [options] [database] 
选项 ：
	-u, --user=name #指定用户名 
	-p, --password[=name] #指定密码 
	-h, --host=name #指定服务器IP或域名 
	-P, --port=port #指定连接端口 
	-e, --execute=name #执行SQL语句并退出
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><h4 id="mysqladmin" tabindex="-1"><a class="header-anchor" href="#mysqladmin" aria-hidden="true">#</a> mysqladmin</h4><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>通过帮助文档查看选项： 
mysqladmin --help
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+Ca+`" alt="image-20220427101337195" style="zoom:50%;"><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法:
	mysqladmin [options] command ... 

选项:
	-u, --user=name #指定用户名 
	-p, --password[=name] #指定密码 
	-h, --host=name #指定服务器IP或域名 
	-P, --port=port #指定连接端口 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqlbinlog" tabindex="-1"><a class="header-anchor" href="#mysqlbinlog" aria-hidden="true">#</a> mysqlbinlog</h4><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法 ：
	mysqlbinlog [options] log-files1 log-files2 ... 
选项 ：
	-d, --database=name 指定数据库名称，只列出指定的数据库相关操作。 
	-o, --offset=# 忽略掉日志中的前n行命令。 
	-r,--result-file=name 将输出的文本格式日志输出到指定文件。 
	-s, --short-form 显示简单格式， 省略掉一些信息。 
	--start-datatime=date1 --stop-datetime=date2 指定日期间隔内的所有日志。 
	--start-position=pos1 --stop-position=pos2 指定位置间隔内的所有日志。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqlshow" tabindex="-1"><a class="header-anchor" href="#mysqlshow" aria-hidden="true">#</a> mysqlshow</h4><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>语法 ：
	mysqlshow <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>db_name <span class="token punctuation">[</span>table_name <span class="token punctuation">[</span>col_name<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> 

选项 ：
	<span class="token comment">--count 显示数据库及表的统计信息（数据库，表 均可以不指定） </span>
	<span class="token operator">-</span>i 显示指定数据库或者指定表的状态信息 

示例：
	<span class="token comment">#查询test库中每个表中的字段书，及行数 </span>
	mysqlshow <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test <span class="token comment">--count </span>
	
	<span class="token comment">#查询test库中book表的详细情况 </span>
	mysqlshow <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test book <span class="token comment">--count</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqldump" tabindex="-1"><a class="header-anchor" href="#mysqldump" aria-hidden="true">#</a> mysqldump</h4><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法 ：
	mysqldump [options] db_name [tables] 
	mysqldump [options] --database/-B db1 [db2 db3...] 
	mysqldump [options] --all-databases/-A 
	
连接选项 ： 
	-u, --user=name 指定用户名 
	-p, --password[=name] 指定密码 
	-h, --host=name 指定服务器ip或域名 
	-P, --port=# 指定连接端口 

输出选项： 
	--add-drop-database 在每个数据库创建语句前加上 drop database 语句 
	--add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不 开启 (--skip-add-drop-table) 
	-n, --no-create-db 不包含数据库的创建语句 
	-t, --no-create-info 不包含数据表的创建语句 
	-d --no-data 不包含数据 
	-T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一 个.txt文件，数据文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqlimport-source" tabindex="-1"><a class="header-anchor" href="#mysqlimport-source" aria-hidden="true">#</a> mysqlimport/source</h4><p><strong>mysqlimport</strong>： 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>语法 ：
	mysqlimport <span class="token punctuation">[</span>options<span class="token punctuation">]</span> db_name textfile1 <span class="token punctuation">[</span>textfile2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> 
示例 ：
	mysqlimport <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test <span class="token operator">/</span>tmp<span class="token operator">/</span>city<span class="token punctuation">.</span>txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>source</strong>：如果需要导入sql文件,可以使用mysql中的source 指令 :</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>语法 ：
	source <span class="token operator">/</span>root<span class="token operator">/</span>xxxxx<span class="token punctuation">.</span><span class="token keyword">sql</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,833),Na=[Oa];function Pa(Va,Ha){return n(),t("div",null,Na)}const Wa=e(Ua,[["render",Pa],["__file","mysql-advance.html.vue"]]);export{Wa as default};
