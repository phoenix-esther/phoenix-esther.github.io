const l=JSON.parse('{"key":"v-4ddadaf6","path":"/java/java-jvm/java-memory-model.html","title":"JVM 内存模型","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"一、理解Java内存区域与Java内存模型","slug":"一、理解java内存区域与java内存模型","link":"#一、理解java内存区域与java内存模型","children":[{"level":3,"title":"1.1 Java内存区域","slug":"_1-1-java内存区域","link":"#_1-1-java内存区域","children":[]},{"level":3,"title":"1.2 Java内存模型概述","slug":"_1-2-java内存模型概述","link":"#_1-2-java内存模型概述","children":[]}]},{"level":2,"title":"二、硬件内存架构与Java内存模型","slug":"二、硬件内存架构与java内存模型","link":"#二、硬件内存架构与java内存模型","children":[{"level":3,"title":"2.1 硬件内存架构","slug":"_2-1-硬件内存架构","link":"#_2-1-硬件内存架构","children":[]},{"level":3,"title":"2.2 Java线程与硬件处理器","slug":"_2-2-java线程与硬件处理器","link":"#_2-2-java线程与硬件处理器","children":[]},{"level":3,"title":"2.3 Java内存模型与硬件内存架构的关系","slug":"_2-3-java内存模型与硬件内存架构的关系","link":"#_2-3-java内存模型与硬件内存架构的关系","children":[]}]},{"level":2,"title":"三、JMM存在的必要性","slug":"三、jmm存在的必要性","link":"#三、jmm存在的必要性","children":[]},{"level":2,"title":"四、Java内存模型的承诺","slug":"四、java内存模型的承诺","link":"#四、java内存模型的承诺","children":[{"level":3,"title":"4.1 原子性","slug":"_4-1-原子性","link":"#_4-1-原子性","children":[]},{"level":3,"title":"4.2 理解指令重排","slug":"_4-2-理解指令重排","link":"#_4-2-理解指令重排","children":[]},{"level":3,"title":"4.3 可见性","slug":"_4-3-可见性","link":"#_4-3-可见性","children":[]},{"level":3,"title":"4.4 有序性","slug":"_4-4-有序性","link":"#_4-4-有序性","children":[]},{"level":3,"title":"4.5 JMM提供的解决方案","slug":"_4-5-jmm提供的解决方案","link":"#_4-5-jmm提供的解决方案","children":[]},{"level":3,"title":"4.6 理解JMM中的happens-before 原则","slug":"_4-6-理解jmm中的happens-before-原则","link":"#_4-6-理解jmm中的happens-before-原则","children":[]}]},{"level":2,"title":"五、volatile内存语义","slug":"五、volatile内存语义","link":"#五、volatile内存语义","children":[{"level":3,"title":"5.1 volatile的可见性","slug":"_5-1-volatile的可见性","link":"#_5-1-volatile的可见性","children":[]},{"level":3,"title":"5.2 volatile禁止重排优化","slug":"_5-2-volatile禁止重排优化","link":"#_5-2-volatile禁止重排优化","children":[]}]}],"git":{"createdTime":1696594256000,"updatedTime":1697101733000,"contributors":[{"name":"xuliang","email":"895252461@qq.com","commits":1},{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":1}]},"readingTime":{"minutes":35.02,"words":10506},"filePathRelative":"java/java-jvm/java-memory-model.md","localizedDate":"2023年10月6日","excerpt":"<h1> JVM 内存模型</h1>\\n<h2> 一、理解Java内存区域与Java内存模型</h2>\\n<h3> 1.1 Java内存区域</h3>\\n<p></p>\\n<p>Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。</p>\\n<ul>\\n<li>\\n<p>方法区（Method Area）：</p>\\n<p>方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。</p>\\n</li>\\n<li>\\n<p>JVM堆（Java Heap）：</p>\\n<p>Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p>\\n</li>\\n<li>\\n<p>程序计数器(Program Counter Register)：</p>\\n<p>属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\\n</li>\\n<li>\\n<p>虚拟机栈(Java Virtual Machine Stacks)：</p>\\n<p>属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程，如下（图有误，应该为栈桢）</p>\\n<p></p>\\n</li>\\n<li>\\n<p>本地方法栈(Native Method Stacks)：</p>\\n<p>本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。</p>\\n</li>\\n</ul>"}');export{l as data};
