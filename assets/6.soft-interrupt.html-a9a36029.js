import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as p,c as d,a as o,b as t,d as s,e as r}from"./app-e53dd85b.js";const i="/assets/软中断提纲-cbe56bc4.png",a="/assets/softirqs-16072ca7.png",_="/assets/ksoftirqd-4d2a7c60.png",h="/assets/top_si-62b43349.png",l="/assets/watch-831db2bd.png",E="/assets/sar_dev-0f1cc17e.png",g={},u=o("h1",{id:"什么是软中断",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#什么是软中断","aria-hidden":"true"},"#"),t(" 什么是软中断？")],-1),f=o("p",null,[t("今日的技术主题："),o("strong",null,"什么是软中断？"),t("。")],-1),m=o("p",null,[o("img",{src:i,alt:"img"})],-1),B=o("hr",null,null,-1),C={id:"中断是什么",tabindex:"-1"},A=o("a",{class:"header-anchor",href:"#中断是什么","aria-hidden":"true"},"#",-1),U={href:"https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E4%B8%AD%E6%96%AD%E6%98%AF%E4%BB%80%E4%B9%88",target:"_blank",rel:"noopener noreferrer"},x=r("<p>先来看看什么是中断？在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</p><p>这样的解释可能过于学术了，容易云里雾里，我就举个生活中取外卖的例子。</p><p>小林中午搬完砖，肚子饿了，点了份白切鸡外卖，这次我带闪了，没有被某团大数据杀熟。虽然平台上会显示配送进度，但是我也不能一直傻傻地盯着呀，时间很宝贵，当然得去干别的事情，等外卖到了配送员会通过「电话」通知我，电话响了，我就会停下手中地事情，去拿外卖。</p><p>这里的打电话，其实就是对应计算机里的中断，没接到电话的时候，我可以做其他的事情，只有接到了电话，也就是发生中断，我才会停下当前的事情，去进行另一个事情，也就是拿外卖。</p><p>从这个例子，我们可以知道，中断是一种异步的事件处理机制，可以提高系统的并发处理能力。</p><p>操作系统收到了中断请求，会打断其他进程的运行，所以<strong>中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。</strong></p><p>而且，中断处理程序在响应中断时，可能还会「临时关闭中断」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要短且快。</p><p>还是回到外卖的例子，小林到了晚上又点起了外卖，这次为了犒劳自己，共点了两份外卖，一份小龙虾和一份奶茶，并且是由不同地配送员来配送，那么问题来了，当第一份外卖送到时，配送员给我打了长长的电话，说了一些杂七杂八的事情，比如给个好评等等，但如果这时另一位配送员也想给我打电话。</p><p>很明显，这时第二位配送员因为我在通话中（相当于关闭了中断响应），自然就无法打通我的电话，他可能尝试了几次后就走掉了（相当于丢失了一次中断）。</p><hr>",10),P={id:"什么是软中断-1",tabindex:"-1"},b=o("a",{class:"header-anchor",href:"#什么是软中断-1","aria-hidden":"true"},"#",-1),D={href:"https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%B8%AD%E6%96%AD",target:"_blank",rel:"noopener noreferrer"},k=r("<p>前面我们也提到了，中断请求的处理程序应该要短且快，这样才能减少对正常进程运行调度地影响，而且中断处理程序可能会暂时关闭中断，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，会丢失当前其他设备的中断请求。</p><p>那 Linux 系统<strong>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</strong>。</p><ul><li><strong>上半部用来快速处理中断</strong>，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</li><li><strong>下半部用来延迟处理上半部未完成的工作</strong>，一般以「内核线程」的方式运行。</li></ul><p>前面的外卖例子，由于第一个配送员长时间跟我通话，则导致第二位配送员无法拨通我的电话，其实当我接到第一位配送员的电话，可以告诉配送员说我现在下楼，剩下的事情，等我们见面再说（上半部），然后就可以挂断电话，到楼下后，在拿外卖，以及跟配送员说其他的事情（下半部）。</p><p>这样，第一位配送员就不会占用我手机太多时间，当第二位配送员正好过来时，会有很大几率拨通我的电话。</p><p>再举一个计算机中的例子，常见的网卡接收网络包的例子。</p><p>网卡收到网络包后，通过 DMA 方式将接收到的数据写入内存，接着会通过<strong>硬件中断</strong>通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来处理该事件，这个事件的处理也是会分成上半部和下半部。</p><p>上部分要做的事情很少，会先禁止网卡中断，避免频繁硬中断，而降低内核的工作效率。接着，内核会触发一个<strong>软中断</strong>，把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和处理，最后把数据送给应用程序。</p><p>所以，中断处理程序的上部分和下半部可以理解为：</p><ul><li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li><li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li></ul><p>还有一个区别，硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」，比如 0 号 CPU 对应的软中断内核线程的名字是 <code>ksoftirqd/0</code></p><p>不过，软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等、RCU 锁（内核里常用的一种锁）等。</p><hr>",13),q={id:"系统里有哪些软中断",tabindex:"-1"},w=o("a",{class:"header-anchor",href:"#系统里有哪些软中断","aria-hidden":"true"},"#",-1),N={href:"https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E7%B3%BB%E7%BB%9F%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%B8%AD%E6%96%AD",target:"_blank",rel:"noopener noreferrer"},R=r('<p>在 Linux 系统里，我们可以通过查看 <code>/proc/softirqs</code> 的 内容来知晓「软中断」的运行情况，以及 <code>/proc/interrupts</code> 的 内容来知晓「硬中断」的运行情况。</p><p>接下来，就来简单的解析下 <code>/proc/softirqs</code> 文件的内容，在我服务器上查看到的文件内容如下：</p><p><img src="'+a+'" alt="img"></p><p>你可以看到，每一个 CPU 都有自己对应的不同类型软中断的<strong>累计运行次数</strong>，有 3 点需要注意下。</p><p>第一点，要注意第一列的内容，它是代表着软中断的类型，在我的系统里，软中断包括了 10 个类型，分别对应不同的工作类型，比如 <code>NET_RX</code> 表示网络接收中断，<code>NET_TX</code> 表示网络发送中断、<code>TIMER</code> 表示定时中断、<code>RCU</code> 表示 RCU 锁中断、<code>SCHED</code> 表示内核调度中断。</p><p>第二点，要注意同一种类型的软中断在不同 CPU 的分布情况，正常情况下，同一种中断在不同 CPU 上的累计次数相差不多，比如我的系统里，<code>NET_RX</code> 在 CPU0 、CPU1、CPU2、CPU3 上的中断次数基本是同一个数量级，相差不多。</p><p>第三点，这些数值是系统运行以来的累计中断次数，数值的大小没什么参考意义，但是系统的<strong>中断次数的变化速率</strong>才是我们要关注的，我们可以使用 <code>watch -d cat /proc/softirqs</code> 命令查看中断次数的变化速率。</p><p>前面提到过，软中断是以内核线程的方式执行的，我们可以用 <code>ps</code> 命令可以查看到，下面这个就是在我的服务器上查到软中断内核线程的结果：</p><p><img src="'+_+'" alt="img"></p><p>可以发现，内核线程的名字外面都有有中括号，这说明 ps 无法获取它们的命令行参数，所以一般来说，名字在中括号里的都可以认为是内核线程。</p><p>而且，你可以看到有 4 个 <code>ksoftirqd</code> 内核线程，这是因为我这台服务器的 CPU 是 4 核心的，每个 CPU 核心都对应着一个内核线程。</p><hr>',12),F={id:"如何定位软中断-cpu-使用率过高的问题",tabindex:"-1"},T=o("a",{class:"header-anchor",href:"#如何定位软中断-cpu-使用率过高的问题","aria-hidden":"true"},"#",-1),L={href:"https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%BD%AF%E4%B8%AD%E6%96%AD-cpu-%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98",target:"_blank",rel:"noopener noreferrer"},I=r('<p>要想知道当前的系统的软中断情况，我们可以使用 <code>top</code> 命令查看，下面是一台服务器上的 top 的数据：</p><p><img src="'+h+'" alt="img"></p><p>上图中的黄色部分 <code>si</code>，就是 CPU 在软中断上的使用率，而且可以发现，每个 CPU 使用率都不高，两个 CPU 的使用率虽然只有 3% 和 4% 左右，但是都是用在软中断上了。</p><p>另外，也可以看到 CPU 使用率最高的进程也是软中断 <code>ksoftirqd</code>，因此可以认为此时系统的开销主要来源于软中断。</p><p>如果要知道是哪种软中断类型导致的，我们可以使用 <code>watch -d cat /proc/softirqs</code> 命令查看每个软中断类型的中断次数的变化速率。</p><p><img src="'+l+'" alt="img"></p><p>一般对于网络 I/O 比较高的 Web 服务器，<code>NET_RX</code> 网络接收中断的变化速率相比其他中断类型快很多。</p><p>如果发现 <code>NET_RX</code> 网络接收中断次数的变化速率过快，接下来就可以使用 <code>sar -n DEV</code> 查看网卡的网络包接收速率情况，然后分析是哪个网卡有大量的网络包进来。</p><p><img src="'+E+'" alt="img"></p><p>接着，在通过 <code>tcpdump</code> 抓包，分析这些包的来源，如果是非法的地址，可以考虑加防火墙，如果是正常流量，则要考虑硬件升级等。</p><hr>',11),V={id:"总结",tabindex:"-1"},X=o("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#",-1),v={href:"https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"},M=o("p",null,"为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：",-1),S=o("ul",null,[o("li",null,"上半部，对应硬中断，由硬件触发中断，用来快速处理中断；"),o("li",null,"下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；")],-1),H=o("p",null,"Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况，如果要实时查看中断次数的变化率，可以使用 watch -d cat /proc/softirqs 命令。",-1),O=o("p",null,"每一个 CPU 都有各自的软中断内核线程，我们还可以用 ps 命令来查看内核线程，一般名字在中括号里面到，都认为是内核线程。",-1),W=o("p",null,"如果在 top 命令发现，CPU 在软中断上的使用率比较高，而且 CPU 使用率最高的进程也是软中断 ksoftirqd 的时候，这种一般可以认为系统的开销被软中断占据了。",-1),j=o("p",null,"这时我们就可以分析是哪种软中断类型导致的，一般来说都是因为网络接收软中断导致的，如果是的话，可以用 sar 命令查看是哪个网卡的有大量的网络包接收，再用 tcpdump 抓网络包，做进一步分析该网络包的源头是不是非法地址，如果是就需要考虑防火墙增加规则，如果不是，则考虑硬件升级等。",-1);function y(z,G){const e=c("ExternalLinkIcon");return p(),d("div",null,[u,f,m,B,o("h2",C,[A,t(),o("a",U,[t("#"),s(e)]),t("中断是什么？")]),x,o("h2",P,[b,t(),o("a",D,[t("#"),s(e)]),t("什么是软中断？")]),k,o("h3",q,[w,t(),o("a",N,[t("#"),s(e)]),t("系统里有哪些软中断？")]),R,o("h2",F,[T,t(),o("a",L,[t("#"),s(e)]),t("如何定位软中断 CPU 使用率过高的问题？")]),I,o("h2",V,[X,t(),o("a",v,[t("#"),s(e)]),t("总结")]),M,S,H,O,W,j])}const Q=n(g,[["render",y],["__file","6.soft-interrupt.html.vue"]]);export{Q as default};
