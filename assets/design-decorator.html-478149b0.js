const e=JSON.parse('{"key":"v-00b98387","path":"/quality/design-mode/design-decorator.html","title":"装饰器模式","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"核心理念","slug":"核心理念","link":"#核心理念","children":[]},{"level":2,"title":"实现","slug":"实现","link":"#实现","children":[{"level":3,"title":"Step1","slug":"step1","link":"#step1","children":[]},{"level":3,"title":"Step 2","slug":"step-2","link":"#step-2","children":[]},{"level":3,"title":"Step 3","slug":"step-3","link":"#step-3","children":[]},{"level":3,"title":"Step 4","slug":"step-4","link":"#step-4","children":[]},{"level":3,"title":"Step 5","slug":"step-5","link":"#step-5","children":[]}]}],"git":{"createdTime":1652840208000,"updatedTime":1653582123000,"contributors":[{"name":"xuliang","email":"895252461@qq.com","commits":2}]},"readingTime":{"minutes":3.38,"words":1015},"filePathRelative":"quality/design-mode/design-decorator.md","localizedDate":"2022年5月18日","excerpt":"<h1> 装饰器模式</h1>\\n<h2> 定义</h2>\\n<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>\\n<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>\\n<h2> 介绍</h2>\\n<p><strong>意图：</strong>  动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>\\n<p>**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>"}');export{e as data};
