const e=JSON.parse('{"key":"v-7eece0c8","path":"/java/java-io/java-nio-10.html","title":"服务端多线程化","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"多线程架构","slug":"多线程架构","link":"#多线程架构","children":[]},{"level":2,"title":"单 Worker 线程","slug":"单-worker-线程","link":"#单-worker-线程","children":[{"level":3,"title":"运行结果问题分析","slug":"运行结果问题分析","link":"#运行结果问题分析","children":[]},{"level":3,"title":"解决方法一：调整执行顺序","slug":"解决方法一-调整执行顺序","link":"#解决方法一-调整执行顺序","children":[]},{"level":3,"title":"解决方法二：主动唤醒 select","slug":"解决方法二-主动唤醒-select","link":"#解决方法二-主动唤醒-select","children":[]}]},{"level":2,"title":"多 Worker 线程","slug":"多-worker-线程","link":"#多-worker-线程","children":[]}],"git":{"createdTime":1716801999000,"updatedTime":1716801999000,"contributors":[{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":1}]},"readingTime":{"minutes":6.48,"words":1944},"filePathRelative":"java/java-io/java-nio-10.md","localizedDate":"2024年5月27日","excerpt":"<h1> 服务端多线程化</h1>\\n<p></p>\\n<h2> 多线程架构</h2>\\n<p>前面所有文章的示例服务端都是单线程模式，这种模式存在很多的缺陷</p>\\n<ol>\\n<li>无法充分利用多核 CPU 的性能</li>\\n<li>如果服务端某个读写操作耗时较多，则会拖慢整个服务端</li>\\n</ol>\\n<p>所以，这篇文章大明哥将介绍服务端多线程的模式，让我们榨干服务器性能。</p>\\n<p>我们清楚服务端主要做两件事，建立连接和处理读写事件，所以我们可以将服务端的线程分为两组：</p>\\n<ol>\\n<li>一个线程专门处理 accept 事件，我们称之为 Boss 线程</li>\\n<li>CPU 核心数个线程，这些线程处理读写事件，我们称之为 Worker 线程</li>\\n</ol>"}');export{e as data};
