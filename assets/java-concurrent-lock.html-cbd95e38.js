const e=JSON.parse('{"key":"v-5dca8ec2","path":"/java/java-concurrent/java-concurrent-lock.html","title":"Java中的锁","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Lock接口","slug":"lock接口","link":"#lock接口","children":[]},{"level":2,"title":"队列同步器","slug":"队列同步器","link":"#队列同步器","children":[{"level":3,"title":"AQS 框架原理","slug":"aqs-框架原理","link":"#aqs-框架原理","children":[]},{"level":3,"title":"AQS实现分析","slug":"aqs实现分析","link":"#aqs实现分析","children":[]}]},{"level":2,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[{"level":3,"title":"如何实现锁的重入","slug":"如何实现锁的重入","link":"#如何实现锁的重入","children":[]},{"level":3,"title":"ReentrantLock的实现","slug":"reentrantlock的实现","link":"#reentrantlock的实现","children":[]}]},{"level":2,"title":"ReentrantReadWriteLock","slug":"reentrantreadwritelock","link":"#reentrantreadwritelock","children":[{"level":3,"title":"如何实现读写锁","slug":"如何实现读写锁","link":"#如何实现读写锁","children":[]},{"level":3,"title":"完整的实现源码","slug":"完整的实现源码","link":"#完整的实现源码","children":[]}]},{"level":2,"title":"LockSupport工具","slug":"locksupport工具","link":"#locksupport工具","children":[]},{"level":2,"title":"Condition接口","slug":"condition接口","link":"#condition接口","children":[{"level":3,"title":"Condition 示例","slug":"condition-示例","link":"#condition-示例","children":[]},{"level":3,"title":"Condition的实现分析","slug":"condition的实现分析","link":"#condition的实现分析","children":[]}]}],"git":{"createdTime":1659075927000,"updatedTime":1660641834000,"contributors":[{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":5},{"name":"xuliang","email":"895252461@qq.com","commits":1}]},"readingTime":{"minutes":31.52,"words":9457},"localizedDate":"2022年7月29日","filePathRelative":"java/java-concurrent/java-concurrent-lock.md","excerpt":"<h1> Java中的锁</h1>\\n<h2> Lock接口</h2>\\n<p>Lock是在JDK1.5中添加的，于synchronized相比，Lock接口最大的有点就是对锁获取于释放的可操作性性。</p>\\n<p>Lock接口提供的synchronized不具备的功能。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>特性</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>尝试非阻塞的获取锁</td>\\n<td>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。</td>\\n</tr>\\n<tr>\\n<td>能被中断的获取锁</td>\\n<td>于synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同事所会被释放。</td>\\n</tr>\\n<tr>\\n<td>超时获取锁</td>\\n<td>在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。</td>\\n</tr>\\n</tbody>\\n</table>"}');export{e as data};
