import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c,a as n,b as s,d,e as t}from"./app-9aa256ea.js";const r="/assets/image-20220426093437386-a03fbceb.png",u="/assets/image-20220426095518142-c4c13a30.png",k="/assets/image-20220426095639059-c6fe43b7.png",m="/assets/image-20220426095957217-5e470c58.png",g="/assets/image-20231205151917133-e70266b7.png",b="/assets/image-20231205152116336-6a378b85.png",v="/assets/image-20231205152143057-f76bed91.png",h="/assets/image-20231205152220680-9c4c39d5.png",_="/assets/image-20220426125410635-ea50920f.png",y="/assets/image-20220426125454233-d8bc2366.png",w="/assets/image-20220426125558905-a88d00ef.png",f="/assets/image-20220426125715435-d617d0d6.png",x="/assets/image-20220426125836198-1638a19c.png",E="/assets/image-20220426130002472-a8a1e085.png",L="/assets/image-20220426130112307-a9ee5735.png",S="/assets/image-20220426130147436-9b9b5dce.png",q="/assets/image-20220426132101688-915a67bc.png",T="/assets/image-20220426132221890-dac67025.png",I="/assets/image-20231205153008440-8d8a2bc1.png",D="/assets/image-20220426133035695-99184019.png",R="/assets/image-20220426133244664-627d62dc.png",A="/assets/image-20220426133553213-bd2d91d9.png",B="/assets/image-20220426133716953-e6acbe09.png",N="/assets/image-20220426133851894-2e00f48d.png",O="/assets/image-20220426134116001-b2461b53.png",M="/assets/image-20220426134155085-a4d96e07.png",C="/assets/image-20220426134818605-02deedfc.png",U="/assets/image-20220426135255321-c91d6c28.png",Q="/assets/image-20220426135401081-e3b725f4.png",z="/assets/image-20220426135541380-cb543dc5.png",P="/assets/image-20220426135632221-3afb4a5a.png",V="/assets/image-20220426135730402-d47d9cdb.png",H="/assets/image-20220426135807560-5be4e5ee.png",G="/assets/image-20220426135900534-6d2d7fc3.png",W="/assets/image-20220426140032442-a644aab8.png",F="/assets/image-20220426140210209-2045af22.png",K="/assets/image-20220426140525159-119b00fc.png",X="/assets/image-20220426140602887-29ac60d7.png",Y="/assets/image-20220426140707371-96cff37b.png",J="/assets/image-20220426140843786-252895ee.png",j="/assets/image-20220426141016243-35069dbc.png",Z="/assets/image-20220426141147408-593d6ad5.png",$="/assets/image-20220426141312971-d634e89f.png",ss="/assets/image-20220426141420100-69b88a8e.png",ns="/assets/image-20220426141550959-db102ee6.png",as="/assets/image-20220426141639442-d6582ad9.png",es="/assets/image-20220426142000554-132d7559.png",ts="/assets/image-20220426142104568-74064a72.png",ps="/assets/image-20220426144116562-0dd4e247.png",os="/assets/image-20220426144253275-ea7317c4.png",ls="/assets/image-20220426144634023-53f3c7ab.png",is="/assets/image-20220426144946484-c3a2929c.png",cs="/assets/image-20220426145016039-f5f5cdd3.png",ds="/assets/image-20220426145143737-8d5a8400.png",rs="/assets/image-20220426145216169-bee7dd1f.png",us="/assets/image-20231206114603448-76f25fa6.png",ks="/assets/image-20220426145536751-ae0fd661.png",ms="/assets/image-20220426145743018-a6dfafde.png",gs="/assets/image-20220426145819299-bdbf044f.png",bs="/assets/image-20220426145904194-90b849d7.png",vs="/assets/image-20220426145933220-0ff220d2.png",hs="/assets/image-20220426150616520-951037ed.png",_s="/assets/image-20220426150834107-e9fccca2.png",ys="/assets/image-20220426150905721-f9df9cb9.png",ws="/assets/image-20220426151017038-dbbffc7d.png",fs="/assets/image-20220426151103028-b4a8100a.png",xs="/assets/image-20220426151138823-c5d45d8e.png",Es="/assets/image-20220426151214000-e393c61c.png",Ls="/assets/image-20220426151343299-ced1e706.png",Ss="/assets/image-20220426151436767-83d462d3.png",qs="/assets/image-20220426151507616-63aa8459.png",Ts="/assets/image-20220426151533629-3220c05c.png",Is="/assets/image-20220426151559527-bbeb5d30.png",Ds="/assets/image-20220426151629960-575e6bc9.png",Rs="/assets/image-20220426151753238-b4f59af9.png",As="/assets/image-20220426151816649-5ce2d8ab.png",Bs="/assets/image-20220426151833513-9a94535b.png",Ns="/assets/image-20220426151913875-6dedd36f.png",Os="/assets/image-20220426151931681-83e53da2.png",Ms="/assets/image-20220426152045680-9a51fd9d.png",Cs="/assets/image-20220426152313693-98b76006.png",Us="/assets/image-20220426152358277-fab69bc9.png",Qs="/assets/image-20220426152439578-b012ce00.png",zs="/assets/image-20220426153204338-0040b11e.png",Ps="/assets/image-20220426153230444-623dd994.png",Vs="/assets/image-20220426153351875-33c2723d.png",Hs="/assets/image-20220426153508957-bbbfc419.png",Gs="/assets/image-20220426153619040-9062fd65.png",Ws="/assets/image-20231206152314963-c7100ff1.png",Fs="/assets/image-20231206152342481-49ad3d11.png",Ks="/assets/image-20231206152421253-2da8144d.png",Xs="/assets/image-20220426153729688-340b4932.png",Ys="/assets/image-20220426153740747-b56a2288.png",Js="/assets/image-20220426154028829-1c0199fe.png",js="/assets/image-20220426154100621-970563c5.png",Zs="/assets/image-20220426154150695-62c16642.png",$s="/assets/image-20220426154257324-2ec9fa27.png",sn="/assets/image-20220426154316395-2136ce3d.png",nn="/assets/image-20220426154659445-d1ecc663.png",an="/assets/image-20220426155608697-89860da3.png",en="/assets/image-20220426155839152-90ba3d30.png",tn="/assets/image-20220426160414695-94a956b3.png",pn="/assets/image-20220426160456612-9186c762.png",on="/assets/image-20220426161203823-1bf97155.png",ln="/assets/image-20220426161235688-f790d98b.png",cn="/assets/image-20220426161359156-15ca2d76.png",dn="/assets/image-20220426161508026-6d1116a4.png",rn="/assets/image-20220426161744776-71c69df1.png",un="/assets/image-20220426161827629-0fcaa899.png",kn="/assets/image-20220426161908510-a3da96a4.png",mn="/assets/记录锁.drawio-ee5d651c.png",gn="/assets/image-20231207191323869-8014d301.png",bn="/assets/image-20231207191418600-edb1605d.png",vn="/assets/image-20231207191518513-89b47b7f.png",hn="/assets/image-20231207191604414-a505b5be.png",_n="/assets/image-20231207191720661-01db2116.png",yn="/assets/image-20231207191739044-af132ae7.png",wn="/assets/image-20231207191818491-6b8ab322.png",fn="/assets/v2-bd416a32e5f1740be516a61665ba285b_720w-e7dbc2d1.png",xn="/assets/v2-60d83dfa236fb4a25ab4c3a5df45b0d0_720w-bdd4f353.png",En="/assets/v2-e5fe73d5f7fda8c298ce60fd35915885_720w-f8bc4cc1.png",Ln="/assets/168579611649421-fc4ff879.png",Sn="/assets/168579611673478-e4f84b2b.png",qn="/assets/b22e0467814f4e5783286f6a7cfd2b00-f07363d2.png",Tn="/assets/Q1NETiBA5YeG5Zu-54G15a-1cbdee0b.png",In="/assets/image-20220427080239097-1f042658.png",Dn="/assets/image-20220427080814476-73d17ac0.png",Rn="/assets/image-20220427081105843-1c6c4ef8.png",An="/assets/image-20220427081201997-5beed8e3.png",Bn="/assets/image-20220427081356587-f46411f3.png",Nn="/assets/image-20220427081505911-9052900a.png",On="/assets/image-20220427081601090-2a929b6b.png",Mn="/assets/image-20220427081942107-70ee484d.png",Cn="/assets/image-20220427082018336-074b1042.png",Un="/assets/image-20220427082223707-af19f700.png",Qn="/assets/image-20220427082337252-80662ff9.png",zn="/assets/image-20220427082511506-78106681.png",Pn="/assets/image-20220427082652621-bc1dbc8a.png",Vn="/assets/image-20220427082857707-5fe1f2a2.png",Hn="/assets/image-20220427083211638-2e93c3a7.png",Gn="/assets/image-20220427083250837-bcdf99ae.png",Wn="/assets/image-20220427083538516-0e444d5d.png",Fn="/assets/image-20220427083611859-ae614232.png",Kn="/assets/TiBA5YeG5Zu-54G15aWW5b6X5L-cbcccd13.png",Xn="/assets/Q1NETiBA5YeG5Zu-54G15aWW5b6X5Li-c0d0443c.png",Yn="/assets/16-1702877123651-45-29c45b41.png",Jn="/assets/x_16-1702877364789-49-2b84d256.png",jn="/assets/x_16-1702877431130-53-bce6f4ed.png",Zn="/assets/x_16-1702877476733-57-ae6d2136.png",$n="/assets/x_2023-12-18-13-37-13-67a02df3.png",sa="/assets/x_16-1702877909003-65-6a7fa8e9.png",na="/assets/x_16-1702877962579-69-2c706a20.png",aa="/assets/x_16-1702878020596-73-f5a96ed3.png",ea="/assets/x_16-1702968368925-77-df2dd69f.png",ta="/assets/x_16-1702968405210-81-004ca12b.png",pa="/assets/x_16-1703055305330-85-c177b8ef.png",oa="/assets/x_16-1703055339268-89-0a5fb3b4.png",la="/assets/f6010fb0701d42b29c6f71fa10615217-7ce9e0c1.png",ia="/assets/x_16-1703055454935-95-17b5067a.png",ca="/assets/x_Q1NETiBA5Y16-3428f017.png",da="/assets/x_16-1703055573955-102-fbc0a2d2.png",ra="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBA5YeG5Zu-54G15aWW5b6X5Li7_size_20_color_FFFFFF_t_70_g_se_x_16-1703057882350-106-b42c53d5.png",ua="/assets/image-20220427084241423-08fb6704.png",ka="/assets/image-20220427084502280-e13ef5e0.png",ma="/assets/image-20220427084719578-a9c15b28.png",ga="/assets/image-20220427090457189-2ee6540d.png",ba="/assets/image-20220427090527928-9be50345.png",va="/assets/image-20220427090814049-0448562a.png",ha="/assets/image-20220427090918139-7e0ea374.png",_a="/assets/image-20220427091020709-1f5e011e.png",ya="/assets/image-20220427091058108-791f5b90.png",wa="/assets/image-20220427091138980-8754656f.png",fa="/assets/image-20220427091218848-5b55e075.png",xa="/assets/image-20220427091253293-19e1526e.png",Ea="/assets/image-20220427093322038-d65aa84b.png",a="/assets/image-20220427093417945-63875f58.png",e="/assets/image-20220427093449949-45d23b43.png",La="/assets/image-20220427095606457-16bc627c.png",Sa="/assets/image-20220427095709975-72ac66a5.png",qa="/assets/image-20220427101337195-b4f0c23e.png",Ta={},Ia=t('<h1 id="mysql-进阶篇" tabindex="-1"><a class="header-anchor" href="#mysql-进阶篇" aria-hidden="true">#</a> MySQL 进阶篇</h1><h2 id="一、进阶篇-存储引擎" tabindex="-1"><a class="header-anchor" href="#一、进阶篇-存储引擎" aria-hidden="true">#</a> 一、进阶篇-存储引擎</h2><h3 id="_1-1-mysql体系结构" tabindex="-1"><a class="header-anchor" href="#_1-1-mysql体系结构" aria-hidden="true">#</a> 1.1 MySQL体系结构</h3><img src="'+r+`" alt="image-20220426093437386" style="zoom:50%;"><ul><li>连接层</li></ul><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><ul><li>服务层</li></ul><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><ul><li>引擎层</li></ul><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</p><ul><li>存储层</li></ul><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><h3 id="_1-2-mysql存储引擎介绍" tabindex="-1"><a class="header-anchor" href="#_1-2-mysql存储引擎介绍" aria-hidden="true">#</a> 1.2 MySQL存储引擎介绍</h3><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p><p>查询当前数据库支持的存储引擎</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> engines<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建表时指定存储引擎</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> name<span class="token punctuation">(</span> 
	字段<span class="token number">1</span> 字段<span class="token number">1</span>类型 <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 字段<span class="token number">1</span>注释 <span class="token punctuation">]</span> <span class="token punctuation">,</span> 
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
	字段n 字段n类型 <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> 字段n注释 <span class="token punctuation">]</span> 
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span> <span class="token punctuation">[</span> <span class="token keyword">COMMENT</span> 表注释 <span class="token punctuation">]</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-3-存储引擎的特点" tabindex="-1"><a class="header-anchor" href="#_1-3-存储引擎的特点" aria-hidden="true">#</a> 1.3 存储引擎的特点</h3><p>常用存储引擎的对比</p><table><thead><tr><th>特点</th><th>MyISAM</th><th>InnoDB</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>64TB</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>行锁</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>数据缓存</td><td></td><td>支持</td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>低</td><td>高</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>低</td><td>高</td><td>中登</td><td>低</td><td>高</td></tr><tr><td>批量插入的速度</td><td>高</td><td>低</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td></td><td>支持</td><td></td><td></td><td></td></tr></tbody></table><h4 id="_1-3-1-innodb" tabindex="-1"><a class="header-anchor" href="#_1-3-1-innodb" aria-hidden="true">#</a> 1.3.1 InnoDB</h4><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p><h5 id="_1-3-1-1-特点" tabindex="-1"><a class="header-anchor" href="#_1-3-1-1-特点" aria-hidden="true">#</a> 1.3.1.1 特点</h5><ul><li><p>DML操作遵循ACID模型，支持事务；</p></li><li><p>行级锁，提高并发访问性能；</p></li><li><p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p></li><li><p>auto_increment 自增列</p></li></ul><h5 id="_1-3-1-2-auto-increment" tabindex="-1"><a class="header-anchor" href="#_1-3-1-2-auto-increment" aria-hidden="true">#</a> 1.3.1.2 AUTO_INCREMENT</h5><p>自增的值默认从1开始，可以手动指定该值，但指定的值是空或者0，则执行自增的逻辑。</p><p>可以修改自增的初始值<code>ALERT TABLE *** AUTO_INCREMENT = n</code>，但是这个值是保存在内存中的。重启后会失效。</p><p><strong>在InnoDB类型的表中，自增列必须是索引列，如果是组合索引，也必须是组合索引的第一列</strong>。</p><h5 id="_1-3-1-3-存储方式" tabindex="-1"><a class="header-anchor" href="#_1-3-1-3-存储方式" aria-hidden="true">#</a> 1.3.1.3 存储方式</h5><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;innodb_file_per_table&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+u+'" alt="image-20220426095518142" style="zoom:50%;"><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的数据存放目录： <code>C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data</code>， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。</p><img src="'+k+'" alt="image-20220426095639059" style="zoom:50%;"><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p><p>数据存储逻辑图</p><p><img src="'+m+'" alt="image-20220426095957217"></p><ul><li><p><strong>表空间 :</strong> InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。</p></li><li><p><strong>段 :</strong> 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</p></li><li><p><strong>区 :</strong> 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p></li><li><p><strong>页 :</strong> 页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p></li><li><p><strong>行 :</strong> InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段</p></li></ul><h5 id="_1-3-1-4-外键约束" tabindex="-1"><a class="header-anchor" href="#_1-3-1-4-外键约束" aria-hidden="true">#</a> 1.3.1.4 外键约束</h5><h4 id="_1-3-2-myisam" tabindex="-1"><a class="header-anchor" href="#_1-3-2-myisam" aria-hidden="true">#</a> 1.3.2 MyISAM</h4><p>MyISAM是MySQL早期的默认存储引擎。</p><h5 id="_1-3-2-1-特点" tabindex="-1"><a class="header-anchor" href="#_1-3-2-1-特点" aria-hidden="true">#</a> 1.3.2.1 特点</h5><p>不支持事务，不支持外键。支持表锁，不支持行锁</p><p>访问速度快，对事物没有完整性没有要求的可以使用这个引擎来创建表。</p><h5 id="_1-3-2-2-存储文件结构" tabindex="-1"><a class="header-anchor" href="#_1-3-2-2-存储文件结构" aria-hidden="true">#</a> 1.3.2.2 存储文件结构</h5><p>每个MyISAM引擎类型的表在磁盘上存储成3个文件，全称如下：</p><ul><li><p>xxx.sdi：存储表结构信息</p></li><li><p>xxx.MYD: 存储数据</p></li><li><p>xxx.MYI: 存储索引</p></li></ul><h4 id="_1-3-3-memory" tabindex="-1"><a class="header-anchor" href="#_1-3-3-memory" aria-hidden="true">#</a> 1.3.3 Memory</h4><p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><h5 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h5><p>数据在内存中存放，默认使用hash索引，访问非常快。服务关闭后数据丢失。</p><h5 id="文件" tabindex="-1"><a class="header-anchor" href="#文件" aria-hidden="true">#</a> 文件</h5><p>xxx.sdi：存储表结构信息</p><h4 id="_1-3-4-区别及特点" tabindex="-1"><a class="header-anchor" href="#_1-3-4-区别及特点" aria-hidden="true">#</a> 1.3.4 区别及特点</h4><h3 id="_1-4-存储引擎的选择" tabindex="-1"><a class="header-anchor" href="#_1-4-存储引擎的选择" aria-hidden="true">#</a> 1.4 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li><p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p></li><li><p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p></li><li><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p></li></ul><h2 id="二、进阶篇-索引" tabindex="-1"><a class="header-anchor" href="#二、进阶篇-索引" aria-hidden="true">#</a> 二、进阶篇-索引</h2><h3 id="_2-1-索引概述" tabindex="-1"><a class="header-anchor" href="#_2-1-索引概述" aria-hidden="true">#</a> 2.1 索引概述</h3><h4 id="_2-1-1-介绍" tabindex="-1"><a class="header-anchor" href="#_2-1-1-介绍" aria-hidden="true">#</a> 2.1.1 介绍</h4><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><img src="'+g+'" alt="image-20231205151917133"></p><h4 id="_2-1-2-演示" tabindex="-1"><a class="header-anchor" href="#_2-1-2-演示" aria-hidden="true">#</a> 2.1.2 演示</h4><p>表结构及其数据如下：</p><p><img src="'+b+'" alt="image-20231205152116336"></p><p>假如我们要执行的SQL语句为 ： select * from user where age = 45;</p><p>1). 无索引情况</p><p><img src="'+v+'" alt="image-20231205152143057"></p><p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。</p><p>2). 有索引情况</p><p>如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。</p><p><img src="'+h+'" alt="image-20231205152220680"></p><p>此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。</p><h4 id="_2-1-3-特点" tabindex="-1"><a class="header-anchor" href="#_2-1-3-特点" aria-hidden="true">#</a> 2.1.3 特点</h4><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><h3 id="_2-2-索引结构" tabindex="-1"><a class="header-anchor" href="#_2-2-索引结构" aria-hidden="true">#</a> 2.2 索引结构</h3><h4 id="_2-2-1-概述" tabindex="-1"><a class="header-anchor" href="#_2-2-1-概述" aria-hidden="true">#</a> 2.2.1 概述</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th><strong>索引结构</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td></tr><tr><td>R-tree(空间索引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-text(全文索引)</td><td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</td></tr></tbody></table><p>上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="_2-2-2-二叉树" tabindex="-1"><a class="header-anchor" href="#_2-2-2-二叉树" aria-hidden="true">#</a> 2.2.2 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p><img src="'+_+'" alt="image-20220426125410635" style="zoom:33%;"><p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p><img src="'+y+'" alt="image-20220426125454233" style="zoom:33%;"><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p></li><li><p>大数据量情况下，层级较深，检索速度慢。</p></li></ul><p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:</p><img src="'+w+'" alt="image-20220426125558905" style="zoom:33%;"><p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p><ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。</p><h4 id="_2-2-3-b-tree" tabindex="-1"><a class="header-anchor" href="#_2-2-3-b-tree" aria-hidden="true">#</a> 2.2.3 B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p><img src="'+f+'" alt="image-20220426125715435" style="zoom:40%;"><p>特点：</p><ul><li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p></li><li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p></li><li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p></li></ul><blockquote><p>我们可以通过一个数据结构可视化的网站来简单演示一下。 https://www.cs.usfca.edu/~galles/visualization/BTree.html</p></blockquote><h4 id="_2-2-4-b-tree" tabindex="-1"><a class="header-anchor" href="#_2-2-4-b-tree" aria-hidden="true">#</a> 2.2.4 B+Tree</h4><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p><img src="'+x+'" alt="image-20220426125836198" style="zoom:50%;"><p>我们可以看到，两部分：</p><ul><li><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</p></li><li><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p></li></ul><p>最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别：</p><ul><li><p>所有的数据都会出现在叶子节点。</p></li><li><p>叶子节点形成一个单向链表。</p></li><li><p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p></li></ul><p>上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的B+Tree。</p><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><img src="'+E+'" alt="image-20220426130002472" style="zoom:50%;"><h4 id="_2-2-5-hash" tabindex="-1"><a class="header-anchor" href="#_2-2-5-hash" aria-hidden="true">#</a> 2.2.5 Hash</h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。</p><p><strong>【1】结构</strong></p><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><img src="'+L+'" alt="image-20220426130112307" style="zoom:50%;"><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><img src="'+S+'" alt="image-20220426130147436" style="zoom:50%;"><p><strong>【2】特点</strong></p><ul><li><p>Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，...）</p></li><li><p>无法利用索引完成排序操作</p></li><li><p>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p></li></ul><p><strong>【3】存储引擎支持</strong></p><p>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><blockquote><p>思考题： 为什么InnoDB存储引擎选择使用B+tree索引结构?</p><ul><li><p>相对于二叉树，层级更少，搜索效率高；</p></li><li><p>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p></li><li><p>相对Hash索引，B+tree支持范围匹配及排序操作；</p></li></ul></blockquote><h3 id="_2-3-索引分类" tabindex="-1"><a class="header-anchor" href="#_2-3-索引分类" aria-hidden="true">#</a> 2.3 索引分类</h3><h4 id="_2-3-1-索引的分类" tabindex="-1"><a class="header-anchor" href="#_2-3-1-索引的分类" aria-hidden="true">#</a> 2.3.1 索引的分类</h4><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引（不允许为null）</td><td>默认自动创建, 只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复（可为null）</td><td>可以有多个索引</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h4 id="_2-3-2-聚集索引-二级索引" tabindex="-1"><a class="header-anchor" href="#_2-3-2-聚集索引-二级索引" aria-hidden="true">#</a> 2.3.2 聚集索引&amp;二级索引</h4><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含有</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有,而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，则优先将主键索引作为聚集索引。</li><li>如果不存在主键，将使用第一个不允许为null的唯一索引(UNIQUE)作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul><p>聚集索引和二级索引的具体结构如下：</p><img src="'+q+'" alt="image-20220426132101688" style="zoom:50%;"><ul><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值</p></li></ul><p>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p><img src="'+T+'" alt="image-20220426132221890" style="zoom:50%;"><p>具体过程如下:</p><p>①. 由于是根据name字段进行查询，所以先根据name=&#39;Arm&#39;到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</p><p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</p><p>③. 最终拿到这一行的数据，直接返回即可。</p><blockquote><p><strong>回表查询</strong>： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote><blockquote><p><strong>思考题：</strong></p><p>以下两条SQL语句，那个执行效率高? 为什么?</p><p>A. select * from user where id = 10 ;</p><p>B. select * from user where name = &#39;Arm&#39; ;</p><p>备注: id为主键，name字段创建的有索引；</p><p>解答：</p><p>A 语句的执行性能要高于B 语句。因为A语句直接走聚集索引，直接返回数据。 而B语句需要先查询name字段的二级索引，然后再查询聚集索引，也就是需要进行回表查询。</p></blockquote><blockquote><p><strong>思考题：</strong></p><p>InnoDB主键索引的B+tree高度为多高呢?</p><p><img src="'+I+`" alt="image-20231205153008440"></p><p>假设:</p><p>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。</p><p>高度为2：</p><p>​ n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</p><p>​ 1171* 16 = 18736</p><p>​ 也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p><p>高度为3：</p><p>​ 1171 * 1171 * 16 = 21939856</p><p>​ 也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p></blockquote><h3 id="_2-4-索引语法" tabindex="-1"><a class="header-anchor" href="#_2-4-索引语法" aria-hidden="true">#</a> 2.4 索引语法</h3><p>创建索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token punctuation">[</span> <span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token punctuation">]</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span> index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2-5-sql性能分析" tabindex="-1"><a class="header-anchor" href="#_2-5-sql性能分析" aria-hidden="true">#</a> 2.5 SQL性能分析</h3><h4 id="_2-5-1-sql执行频率" tabindex="-1"><a class="header-anchor" href="#_2-5-1-sql执行频率" aria-hidden="true">#</a> 2.5.1 SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 show [session | global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session 是查看当前会话,默认是此级别; </span>
<span class="token comment">-- global 是查询全局数据 ; </span>
<span class="token keyword">SHOW</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">&#39;Com_%&#39;</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+D+'" alt="image-20220426133035695" style="zoom:50%;"><ul><li><p>Com_delete: 删除次数</p></li><li><p>Com_insert: 插入次数</p></li><li><p>Com_select: 查询次数</p></li><li><p>Com_update: 更新次数</p></li></ul><p>通过下面两个参数可以了解事物的提交和回滚情况：</p><ul><li>Com_commit: 事物提交次数</li><li>Com_rollback: 事物回滚次数</li></ul><p>下面还有几个针对InnoDB存储引擎的参数可以参考：</p><ul><li>Innodb_row_read: Select查询返回的行数</li><li>Innodb_rows_inserted: 执行INSERT操作插入的行数。</li><li>Innodb_rows_updated: 执行UPDATE操作更新的行数</li><li>Innodb_rows_deleted: 执行DELETE操作删除的行数</li></ul><p>通过这几个操作可以很容易了解当前数据库是以插入更新为主，还是以查询操作为主。从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p><ul><li>Connections： 试图连接MySQL服务器的次数</li><li>Uptime： 服务器的工作时间</li><li>Slow_queries: 慢查询的次数。</li></ul><p>那么通过查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询日志。</p><p>接下来，我们就来介绍一下MySQL中的慢查询日志。</p><h4 id="_2-5-2-慢查询日志" tabindex="-1"><a class="header-anchor" href="#_2-5-2-慢查询日志" aria-hidden="true">#</a> 2.5.2 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p><img src="'+R+`" alt="image-20220426133244664" style="zoom:50%;"><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 开启MySQL慢日志查询开关 </span>
<span class="token key attr-name">slow_query_log</span><span class="token punctuation">=</span><span class="token value attr-value">1 </span>
<span class="token comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 </span>
<span class="token key attr-name">long_query_time</span><span class="token punctuation">=</span><span class="token value attr-value">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息<code>/var/lib/mysql/localhost-slow.log</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>systemctl restart mysqld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，再次查看开关情况，慢查询日志就已经打开了。</p><p><strong>测试</strong></p><p>执行如下SQL语句 ：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user<span class="token punctuation">;</span> <span class="token comment">-- 这条SQL执行效率比较高, 执行耗时 0.00sec</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_sku<span class="token punctuation">;</span> <span class="token comment">-- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时 13.35sec</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+A+'" alt="image-20220426133553213" style="zoom:50%;"><p><strong>检查慢查询日志</strong></p><p>最终我们发现，在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的。那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。</p><img src="'+B+`" alt="image-20220426133716953" style="zoom:50%;"><h4 id="_2-5-3-profile详情" tabindex="-1"><a class="header-anchor" href="#_2-5-3-profile详情" aria-hidden="true">#</a> 2.5.3 profile详情</h4><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> @<span class="token variable">@have_profiling</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+N+`" alt="image-20220426133851894" style="zoom:50%;"><p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在session/global级别开启profiling：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> profiling <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user<span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;白起&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_sku<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查看每一条SQL的耗时基本情况 </span>
<span class="token keyword">show</span> profiles<span class="token punctuation">;</span> 
<span class="token comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况 </span>
<span class="token keyword">show</span> profile <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span> 
<span class="token comment">-- 查看指定query_id的SQL语句CPU的使用情况 </span>
<span class="token keyword">show</span> profile cpu <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看每一条SQL的耗时情况:</p><img src="`+O+'" alt="image-20220426134116001" style="zoom:50%;"><p>查看指定SQL各个阶段的耗时情况 :</p><img src="'+M+`" alt="image-20220426134155085" style="zoom:50%;"><p>MySQL支持进一步选择all、cpu、block io、context、switch、page faults等明细类型来查看MySQL在使用什么资源上耗费了过高的时间。</p><h4 id="_2-5-4-explain-执行计划" tabindex="-1"><a class="header-anchor" href="#_2-5-4-explain-执行计划" aria-hidden="true">#</a> 2.5.4 explain 执行计划</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>语法:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 直接在select语句之前加上关键字 explain / desc </span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+C+'" alt="image-20220426134818605" style="zoom:50%;"><p>Explain 执行计划中各个字段的含义:</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 <br>SIMPLE（简单表，即不使用表连接或者子查询）、<br>PRIMARY（主查询，即外层的查询）、<br>UNION（UNION 中的第二个或者后面的查询语句）、<br>SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示MySQL在表中找到所需行的方式，或者叫访问类型，常见类型如下：<br>type=ALL： 全表扫描，Mysql遍历全表来找到匹配行<br>type=index：索引全扫描，Mysql遍历整个索引来查询匹配的行，<br>type=range：索引范围扫描，常见于&lt;，&lt;=，&gt;，&gt;=，between等操作。<br>type=ref：使用非唯一索引(不是UNIQUE类型的索引)扫描或唯一索引的前缀扫描，返回匹配某个单独值的记录行。<br>type=eq_ref：使用唯一索引扫描（例如：锁表连接中使用primary key或者unique key作为关联条件）<br>type=const/system：单表中只有一行匹配，查询非常迅速，例如通过primary key 或者 unique key 进行查询。<br>type=NULL：MySQL不用访问索引，就能获取结果。</td></tr><tr><td>possible_key</td><td>表示查询是可能使用的索引</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr></tbody></table><h3 id="_2-6-索引使用" tabindex="-1"><a class="header-anchor" href="#_2-6-索引使用" aria-hidden="true">#</a> 2.6 索引使用</h3><h4 id="_2-6-1-最左前缀法则" tabindex="-1"><a class="header-anchor" href="#_2-6-1-最左前缀法则" aria-hidden="true">#</a> 2.6.1 最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。</p><img src="'+U+`" alt="image-20220426135255321" style="zoom:50%;"><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。</p><p>对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下</p><p>具体的执行计划：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Q+`" alt="image-20220426135401081" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+z+`" alt="image-20220426135541380" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+P+`" alt="image-20220426135632221" style="zoom:50%;"><p>以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age字段索引长度为2、status字段索引长度为5。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+V+`" alt="image-20220426135730402" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+H+`" alt="image-20220426135807560" style="zoom:50%;"><p>而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+G+'" alt="image-20220426135900534" style="zoom:50%;"><p>上述的SQL查询时，存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。</p><blockquote><p>思考题：</p><p>当执行SQL语句: explain select * from tb_user where age = 31 and status = &#39;0&#39; and profession = &#39;软件工程&#39;； 时，是否满足最左前缀法则，走不走上述的联合索引，索引长度？</p><img src="'+W+`" alt="image-20220426140032442" style="zoom:50%;"><p>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></blockquote><h4 id="_2-6-2-范围查询" tabindex="-1"><a class="header-anchor" href="#_2-6-2-范围查询" aria-hidden="true">#</a> 2.6.2 范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">&gt;</span> <span class="token number">30</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+F+`" alt="image-20220426140210209" style="zoom:50%;"><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">&gt;=</span> <span class="token number">30</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h4 id="_2-6-3-索引失效情况" tabindex="-1"><a class="header-anchor" href="#_2-6-3-索引失效情况" aria-hidden="true">#</a> 2.6.3 索引失效情况</h4><h5 id="_2-6-3-1-索引列运算" tabindex="-1"><a class="header-anchor" href="#_2-6-3-1-索引列运算" aria-hidden="true">#</a> 2.6.3.1 索引列运算</h5><p>不要在索引列上进行运算操作， 索引将失效。</p><p>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p>当根据phone字段进行等值匹配查询时, 索引生效。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+K+`" alt="image-20220426140525159" style="zoom:50%;"><p>当根据phone字段进行函数运算操作之后，索引失效。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from tb_user where substring(phone,10,2) = &#39;15&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+X+`" alt="image-20220426140602887" style="zoom:50%;"><h5 id="_2-6-3-2-字符串不加引号" tabindex="-1"><a class="header-anchor" href="#_2-6-3-2-字符串不加引号" aria-hidden="true">#</a> 2.6.3.2 字符串不加引号</h5><p>字符串类型字段使用时，不加引号，索引将失效。</p><p>接下来，我们通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+Y+`" alt="image-20220426140707371" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">17799990015</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+J+`" alt="image-20220426140843786" style="zoom:50%;"><p>经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。</p><h5 id="_2-6-3-3-模糊查询" tabindex="-1"><a class="header-anchor" href="#_2-6-3-3-模糊查询" aria-hidden="true">#</a> 2.6.3.3 模糊查询</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>接下来，我们来看一下这三条SQL语句的执行效果，查看一下其执行计划：</p><p>由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的，我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;软件%&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;%工程&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;%工%&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+j+`" alt="image-20220426141016243" style="zoom:50%;"><p>经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。</p><h5 id="_2-6-3-4-or连接条件" tabindex="-1"><a class="header-anchor" href="#_2-6-3-4-or连接条件" aria-hidden="true">#</a> 2.6.3.4 or连接条件</h5><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990017&#39;</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+Z+`" alt="image-20220426141147408" style="zoom:50%;"><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><p>然后，我们可以对age字段建立索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>建立了索引之后，我们再次执行上述的SQL语句，看看前后执行计划的变化。</p><img src="`+$+`" alt="image-20220426141312971" style="zoom:50%;"><p>最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><h5 id="_2-6-3-5-数据分布影响" tabindex="-1"><a class="header-anchor" href="#_2-6-3-5-数据分布影响" aria-hidden="true">#</a> 2.6.3.5 数据分布影响</h5><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;17799990005&#39;</span><span class="token punctuation">;</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+ss+`" alt="image-20220426141420100" style="zoom:50%;"><p>经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？</p><p>就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p><p>接下来，我们再来看看 is null 与 is not null 操作是否走索引。</p><p>执行如下两条语句 ：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">is</span> <span class="token boolean">null</span><span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+ns+'" alt="image-20220426141550959" style="zoom:50%;"><p>接下来，我们做一个操作将profession字段值全部更新为null。然后，再次执行上述的两条SQL，查看SQL语句的执行计划。</p><img src="'+as+'" alt="image-20220426141639442" style="zoom:50%;"><p>最终我们看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。</p><h4 id="_2-6-4-sql提示" tabindex="-1"><a class="header-anchor" href="#_2-6-4-sql提示" aria-hidden="true">#</a> 2.6.4 SQL提示</h4><p>目前tb_user表的数据情况如下:</p><img src="'+es+'" alt="image-20220426142000554" style="zoom:50%;"><p>索引情况如下:</p><img src="'+ts+`" alt="image-20220426142104568" style="zoom:50%;"><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>drop index idx_user_age on tb_user; 
drop index idx_email on tb_user;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行SQL : <code>explain select * from tb_user where profession = &#39;软件工程&#39;</code>;</p><img src="`+ps+'" alt="image-20220426144116562" style="zoom:50%;"><p>查询走了联合索引。</p><p>执行SQL，创建profession的单列索引：<code>create index idx_user_pro on tb_user(profession);</code></p><p>创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。</p><img src="'+os+`" alt="image-20220426144253275" style="zoom:50%;"><p>测试结果，我们可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p><p>那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于MySQL的SQL提示来完成。 接下来，介绍一下SQL提示。</p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2). ignore index ： 忽略指定的索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">ignore</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3). force index ： 强制使用索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2-6-5-覆盖索引" tabindex="-1"><a class="header-anchor" href="#_2-6-5-覆盖索引" aria-hidden="true">#</a> 2.6.5 覆盖索引</h4><p>尽量使用覆盖索引，减少select *。那么什么是覆盖索引呢？覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。</p><p>接下来，我们来看一组SQL的执行计划，看看执行计划的差别，然后再来具体做一个解析。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span> profession <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> <span class="token keyword">status</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span> 
<span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">,</span> name <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软 件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述这几条SQL的执行结果为:</p><img src="`+ls+'" alt="image-20220426144634023" style="zoom:50%;"><p>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 Using where; UsingIndex ; 而后面两条SQL的结果为: Using index condition 。</p><table><thead><tr><th><strong>Extra</strong></th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><p>为了大家更清楚的理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组SQL的执行过程。</p><p>A. 表结构及索引示意图:</p><p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p><img src="'+is+'" alt="image-20220426144946484" style="zoom:50%;"><p>B. 执行SQL : <code>select * from tb_user where id = 2;</code></p><p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><img src="'+cs+'" alt="image-20220426145016039" style="zoom:50%;"><p>C. 执行SQL：<code>selet id,name from tb_user where name = &#39;Arm&#39;;</code></p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p><img src="'+ds+'" alt="image-20220426145143737" style="zoom:50%;"><p>D. 执行SQL：<code>selet id,name,gender from tb_user where name = &#39;Arm&#39;;</code></p><p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。</p><img src="'+rs+`" alt="image-20220426145216169" style="zoom:50%;"><blockquote><p>思考题：</p><p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案:</p><p>select id,username,password from tb_user where username =&#39;itcast&#39;;</p><p>答案: 针对于 username, password建立联合索引, sql为: create index</p><p>idx_user_name_pass on tb_user(username,password);</p><p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p></blockquote><h4 id="_2-6-6-前缀索引" tabindex="-1"><a class="header-anchor" href="#_2-6-6-前缀索引" aria-hidden="true">#</a> 2.6.6 前缀索引</h4><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p><strong>创建前缀索引的语法：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_xxxx <span class="token keyword">on</span> table_name<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例：</p><p>为tb_user表的email字段，建立长度为5的前缀索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_email_5 <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>email<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+us+'" alt="image-20231206114603448"></p><p><strong>前缀长度</strong></p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p><strong>前缀索引的查询流程</strong></p><img src="'+ks+'" alt="image-20220426145536751" style="zoom:50%;"><h4 id="_2-6-7-单列索引与联合索引" tabindex="-1"><a class="header-anchor" href="#_2-6-7-单列索引与联合索引" aria-hidden="true">#</a> 2.6.7 单列索引与联合索引</h4><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>我们先来看看 tb_user 表中目前的索引情况:</p><img src="'+ms+'" alt="image-20220426145743018" style="zoom:50%;"><p>在查询出来的索引中，既有单列索引，又有联合索引。</p><p>接下来，我们来执行一条SQL语句，看看其执行计划：</p><img src="'+gs+`" alt="image-20220426145819299" style="zoom:50%;"><p>通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p><p>紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>create unique index idx_user_phone_name on tb_user(phone,name);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+bs+'" alt="image-20220426145904194" style="zoom:50%;"><p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。</p><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><img src="'+vs+`" alt="image-20220426145933220" style="zoom:50%;"><h3 id="_2-7-索引设计原则" tabindex="-1"><a class="header-anchor" href="#_2-7-索引设计原则" aria-hidden="true">#</a> 2.7 索引设计原则</h3><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p><p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，可以更好地确定哪个索引最有效地用于查询。</p><h2 id="三、进阶篇-sql优化" tabindex="-1"><a class="header-anchor" href="#三、进阶篇-sql优化" aria-hidden="true">#</a> 三、进阶篇-SQL优化</h2><h3 id="_3-1-插入数据" tabindex="-1"><a class="header-anchor" href="#_3-1-插入数据" aria-hidden="true">#</a> 3.1 插入数据</h3><p>一次性插入多条记录，可以从以下三个方面进行优化</p><ul><li>批量插入数据</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">Insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>手动控制事务</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> 
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>主键顺序插入，性能要高于乱序插入。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3 
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-大批量插入数据" tabindex="-1"><a class="header-anchor" href="#_3-2-大批量插入数据" aria-hidden="true">#</a> 3.2 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：</p><img src="`+hs+`" alt="image-20220426150616520" style="zoom:50%;"><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile </span>
mysql –<span class="token operator">-</span><span class="token keyword">local</span><span class="token operator">-</span><span class="token keyword">infile</span> <span class="token operator">-</span>u root <span class="token operator">-</span>p 
<span class="token comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 </span>
<span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token comment">-- 执行load指令将准备好的数据，加载到表结构中 </span>
<span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">&#39;/root/sql1.log&#39;</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;,&#39;</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;\\n&#39;</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>主键顺序插入性能高于乱序插入</p></blockquote><h3 id="_3-3-主键优化" tabindex="-1"><a class="header-anchor" href="#_3-3-主键优化" aria-hidden="true">#</a> 3.3 主键优化</h3><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p><h4 id="_3-3-1-数据组织方式" tabindex="-1"><a class="header-anchor" href="#_3-3-1-数据组织方式" aria-hidden="true">#</a> 3.3.1 数据组织方式</h4><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(<code>index organized table IOT</code>)。</p><img src="`+_s+'" alt="image-20220426150834107" style="zoom:50%;"><p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p><img src="'+ys+'" alt="image-20220426150905721" style="zoom:50%;"><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。</p><h4 id="_3-3-2-页分裂" tabindex="-1"><a class="header-anchor" href="#_3-3-2-页分裂" aria-hidden="true">#</a> 3.3.2 页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><h5 id="_3-3-2-1-主键顺序插入效果" tabindex="-1"><a class="header-anchor" href="#_3-3-2-1-主键顺序插入效果" aria-hidden="true">#</a> 3.3.2.1 主键顺序插入效果</h5><p>①. 从磁盘中申请页， 主键顺序插入</p><img src="'+ws+'" alt="image-20220426151017038" style="zoom:50%;"><p>②. 第一个页没有满，继续往第一页插入</p><img src="'+fs+'" alt="image-20220426151103028" style="zoom:50%;"><p>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><img src="'+xs+'" alt="image-20220426151138823" style="zoom:50%;"><p>④. 当第二页写满了，再往第三页写入</p><img src="'+Es+'" alt="image-20220426151214000" style="zoom:50%;"><h5 id="_3-3-2-2-主键乱序插入效果" tabindex="-1"><a class="header-anchor" href="#_3-3-2-2-主键乱序插入效果" aria-hidden="true">#</a> 3.3.2.2 主键乱序插入效果</h5><p>①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p><img src="'+Ls+'" alt="image-20220426151343299" style="zoom:50%;"><p>②. 此时再插入id为50的记录，我们来看看会发生什么现象，会再次开启一个页，写入新的页中吗？</p><img src="'+Ss+'" alt="image-20220426151436767" style="zoom:50%;"><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><img src="'+qs+'" alt="image-20220426151507616" style="zoom:50%;"><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><img src="'+Ts+'" alt="image-20220426151533629" style="zoom:50%;"><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><img src="'+Is+'" alt="image-20220426151559527" style="zoom:50%;"><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p><img src="'+Ds+'" alt="image-20220426151629960" style="zoom:50%;"><p>上述的这种现象，称之为 &quot;页分裂&quot;，是比较耗费性能的操作。</p><h4 id="_3-3-3-页合并" tabindex="-1"><a class="header-anchor" href="#_3-3-3-页合并" aria-hidden="true">#</a> 3.3.3 页合并</h4><p>目前表中已有数据的索引结构(叶子节点)如下：</p><img src="'+Rs+'" alt="image-20220426151753238" style="zoom:50%;"><p>当我们对已有数据进行删除时，具体的效果如下:</p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><img src="'+As+'" alt="image-20220426151816649" style="zoom:50%;"><p>当我们继续删除2#的数据记录</p><img src="'+Bs+'" alt="image-20220426151833513" style="zoom:50%;"><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><img src="'+Ns+'" alt="image-20220426151913875" style="zoom:50%;"><p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p><img src="'+Os+'" alt="image-20220426151931681" style="zoom:50%;"><p>这个里面所发生的合并页的这个现象，就称之为 &quot;页合并&quot;。</p><blockquote><p>知识小贴士：</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p></blockquote><h4 id="_3-3-4-索引设计原则" tabindex="-1"><a class="header-anchor" href="#_3-3-4-索引设计原则" aria-hidden="true">#</a> 3.3.4 索引设计原则</h4><ul><li><p>满足业务需求的情况下，尽量降低主键的长度。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p></li><li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p></li><li><p>业务操作时，避免对主键的修改。</p></li></ul><img src="'+Ms+'" alt="image-20220426152045680" style="zoom:50%;"><h3 id="_3-4-order-by-优化" tabindex="-1"><a class="header-anchor" href="#_3-4-order-by-优化" aria-hidden="true">#</a> 3.4 order by 优化</h3><p>MySQL的排序，有两种方式：</p><p><strong>Using filesort :</strong> 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p><strong>Using index :</strong> 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p><p>接下来，我们来做一个测试：</p><h4 id="_3-4-1-查看索引" tabindex="-1"><a class="header-anchor" href="#_3-4-1-查看索引" aria-hidden="true">#</a> 3.4.1 查看索引</h4><img src="'+Cs+`" alt="image-20220426152313693" style="zoom:50%;"><h4 id="_3-4-2-执行排序sql" tabindex="-1"><a class="header-anchor" href="#_3-4-2-执行排序sql" aria-hidden="true">#</a> 3.4.2 执行排序SQL</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Us+`" alt="image-20220426152358277" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">,</span> phone <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Qs+`" alt="image-20220426152439578" style="zoom:50%;"><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p><h4 id="_3-4-3-创建索引" tabindex="-1"><a class="header-anchor" href="#_3-4-3-创建索引" aria-hidden="true">#</a> 3.4.3 创建索引</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 创建索引 </span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age_phone_aa <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age<span class="token punctuation">,</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-4-4-执行升序排序" tabindex="-1"><a class="header-anchor" href="#_3-4-4-执行升序排序" aria-hidden="true">#</a> 3.4.4 执行升序排序</h4><p>创建索引后，根据age, phone进行升序排序</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+zs+`" alt="image-20220426153204338" style="zoom:50%;"><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token punctuation">,</span> phone<span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Ps+`" alt="image-20220426153230444" style="zoom:50%;"><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了。</p><h4 id="_3-4-5-进行降序排序" tabindex="-1"><a class="header-anchor" href="#_3-4-5-进行降序排序" aria-hidden="true">#</a> 3.4.5 进行降序排序</h4><p>创建索引后，根据age, phone进行降序排序</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">desc</span> <span class="token punctuation">,</span> phone <span class="token keyword">desc</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Vs+`" alt="image-20220426153351875" style="zoom:50%;"><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><h4 id="_3-4-6-失效情况" tabindex="-1"><a class="header-anchor" href="#_3-4-6-失效情况" aria-hidden="true">#</a> 3.4.6 失效情况</h4><p>根据phone，age进行升序排序，phone在前，age在后。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> phone <span class="token punctuation">,</span> age<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Hs+`" alt="image-20220426153508957" style="zoom:50%;"><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><p>根据age, phone进行降序一个升序，一个降序</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">asc</span> <span class="token punctuation">,</span> phone <span class="token keyword">desc</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Gs+'" alt="image-20220426153619040" style="zoom:50%;"><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort。</p><p><img src="'+Ws+`" alt="image-20231206152314963"></p><p>为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序，phone 倒序排序。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age_phone_ad <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age <span class="token keyword">asc</span> <span class="token punctuation">,</span>phone <span class="token keyword">desc</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+Fs+`" alt="image-20231206152342481"></p><p>然后再次执行如下SQL</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">asc</span> <span class="token punctuation">,</span> phone <span class="token keyword">desc</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+Ks+'" alt="image-20231206152421253"></p><p>升序/降序联合索引结构图示:</p><img src="'+Xs+'" alt="image-20220426153729688" style="zoom:50%;"><img src="'+Ys+'" alt="image-20220426153740747" style="zoom:50%;"><h4 id="_3-4-7-总结" tabindex="-1"><a class="header-anchor" href="#_3-4-7-总结" aria-hidden="true">#</a> 3.4.7 总结</h4><p>由上述的测试,我们得出order by优化原则:</p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</p><h3 id="_3-5-group-by-优化" tabindex="-1"><a class="header-anchor" href="#_3-5-group-by-优化" aria-hidden="true">#</a> 3.5 group by 优化</h3><p>分组操作，我们主要来看看索引对于分组操作的影响。</p><p>首先我们先将 tb_user 表的索引全部删除掉 。</p><img src="'+Js+`" alt="image-20220426154028829" style="zoom:50%;"><p>接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> profession <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+js+`" alt="image-20220426154100621" style="zoom:50%;"><p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_pro_age_sta <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>profession <span class="token punctuation">,</span> age <span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>紧接着，再执行前面相同的SQL查看执行计划。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> profession <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Zs+'" alt="image-20220426154150695" style="zoom:50%;"><p>再执行如下的分组查询SQL，查看执行计划：</p><img src="'+$s+'" alt="image-20220426154257324" style="zoom:50%;"><img src="'+sn+'" alt="image-20220426154316395" style="zoom:50%;"><p>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是根据profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的。</p><h5 id="_3-5-1-总结" tabindex="-1"><a class="header-anchor" href="#_3-5-1-总结" aria-hidden="true">#</a> 3.5.1 总结：</h5><p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><ul><li><p>在分组操作时，可以通过索引来提高效率。</p></li><li><p>分组操作时，索引的使用也是满足最左前缀法则的。</p></li></ul><h3 id="_3-6-limit-优化" tabindex="-1"><a class="header-anchor" href="#_3-6-limit-优化" aria-hidden="true">#</a> 3.6 limit 优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>我们一起来看看执行limit分页查询耗时对比：</p><img src="'+nn+`" alt="image-20220426154659445" style="zoom:50%;"><p>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。</p><p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: 一般分页查询时，通过创建 <em>覆盖索引</em> 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_sku t <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_sku <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">2000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> a <span class="token keyword">where</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-7-count-优化" tabindex="-1"><a class="header-anchor" href="#_3-7-count-优化" aria-hidden="true">#</a> 3.7 count 优化</h3><h4 id="_3-7-1-概述" tabindex="-1"><a class="header-anchor" href="#_3-7-1-概述" aria-hidden="true">#</a> 3.7.1 概述</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p><ul><li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；但是如果是带条件的count，MyISAM也慢。</p></li><li><p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p></li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</p><h4 id="_3-7-2-count用法" tabindex="-1"><a class="header-anchor" href="#_3-7-2-count用法" aria-hidden="true">#</a> 3.7.2 count用法</h4><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（数字）</p><table><thead><tr><th>count用法</th><th>含义</th></tr></thead><tbody><tr><td>count(主键)</td><td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)</td></tr><tr><td>count(字段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr><tr><td>count(数字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</td></tr><tr><td>count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr></tbody></table><blockquote><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，</p><p>所以尽量使用 count(*)。</p></blockquote><h3 id="_3-8-update-优化" tabindex="-1"><a class="header-anchor" href="#_3-8-update-优化" aria-hidden="true">#</a> 3.8 update 优化</h3><p>我们主要需要注意一下update语句执行时的注意事项。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;javaEE&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p><p>但是当我们在执行如下SQL时。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;SpringBoot&#39;</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;PHP&#39;</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</p><blockquote><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p></blockquote><h2 id="四、进阶篇-视图-存储-触发器" tabindex="-1"><a class="header-anchor" href="#四、进阶篇-视图-存储-触发器" aria-hidden="true">#</a> 四、进阶篇-视图/存储/触发器</h2><p>TODO</p><h2 id="五、进阶篇-锁" tabindex="-1"><a class="header-anchor" href="#五、进阶篇-锁" aria-hidden="true">#</a> 五、进阶篇-锁</h2><h3 id="_5-1-概述" tabindex="-1"><a class="header-anchor" href="#_5-1-概述" aria-hidden="true">#</a> 5.1 概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li><p>全局锁：锁定数据库中的所有表。</p></li><li><p>表级锁：每次操作锁住整张表。</p></li><li><p>行级锁：每次操作锁住对应的行数据。</p></li></ul><h3 id="_5-2-全局锁" tabindex="-1"><a class="header-anchor" href="#_5-2-全局锁" aria-hidden="true">#</a> 5.2 全局锁</h3><h4 id="_5-2-1-介绍" tabindex="-1"><a class="header-anchor" href="#_5-2-1-介绍" aria-hidden="true">#</a> 5.2.1 介绍</h4><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>为什么全库逻辑备份，就需要加全就锁呢？</p><p><strong>【我们一起先来分析一下不加全局锁，可能存在的问题】</strong></p><p>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。</p><img src="`+an+'" alt="image-20220426155608697" style="zoom:50%;"><ul><li><p>在进行数据备份时，先备份了tb_stock库存表。</p></li><li><p>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</p></li><li><p>然后再执行备份 tb_order表的逻辑。</p></li><li><p>业务中执行插入订单日志操作。</p></li><li><p>最后，又备份了tb_orderlog表。</p></li></ul><p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)。</p><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p><strong>【再来分析一下加了全局锁后的情况】</strong></p><img src="'+en+`" alt="image-20220426155839152" style="zoom:50%;"><p>对数据库进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p><h4 id="_5-2-2-语法" tabindex="-1"><a class="header-anchor" href="#_5-2-2-语法" aria-hidden="true">#</a> 5.2.2 语法</h4><p>1). 加全局锁</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2). 数据备份</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysqldump <span class="token parameter variable">-uroot</span> –p1234 itcast <span class="token operator">&gt;</span> itcast.sql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数据备份的相关指令, 在后面MySQL管理章节, 还会详细讲解.</p><p>3). 释放锁</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_5-2-3-特点" tabindex="-1"><a class="header-anchor" href="#_5-2-3-特点" aria-hidden="true">#</a> 5.2.3 特点</h4><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 <code>--single-transaction</code> 参数来完成不加锁的一致性数据备份。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysqldump --single-transaction <span class="token parameter variable">-uroot</span> –p123456 itcast <span class="token operator">&gt;</span> itcast.sql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-3-表级锁" tabindex="-1"><a class="header-anchor" href="#_5-3-表级锁" aria-hidden="true">#</a> 5.3 表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li><p>表锁</p></li><li><p>元数据锁（meta data lock，MDL）</p></li><li><p>意向锁</p></li></ul><h4 id="_5-3-1-表锁" tabindex="-1"><a class="header-anchor" href="#_5-3-1-表锁" aria-hidden="true">#</a> 5.3.1 表锁</h4><p>对于表锁，分为两类：</p><ul><li><p>表共享读锁（read lock）</p></li><li><p>表独占写锁（write lock）</p></li></ul><p><strong>语法：</strong></p><ul><li><p>加锁：lock tables 表名... read/write。</p></li><li><p>释放锁：unlock tables / 客户端断开连接 。</p></li></ul><p><strong>特点:</strong></p><p>A. 读锁</p><p>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</p><img src="`+tn+'" alt="image-20220426160414695" style="zoom:50%;"><p>B. 写锁</p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p><img src="'+pn+'" alt="image-20220426160456612" style="zoom:50%;"><blockquote><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p></blockquote><h4 id="_5-3-2-元数据锁" tabindex="-1"><a class="header-anchor" href="#_5-3-2-元数据锁" aria-hidden="true">#</a> 5.3.2 元数据锁</h4><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p><p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><p>常见的SQL操作时，所添加的元数据锁：</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read /write</td><td>SHARED_READ_ONLY /SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select ... lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select ... for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table ...</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><h5 id="_5-3-2-1-什么是元数据锁" tabindex="-1"><a class="header-anchor" href="#_5-3-2-1-什么是元数据锁" aria-hidden="true">#</a> 5.3.2.1 什么是元数据锁</h5>',585),Da={href:"https://bugs.mysql.com/bug.php?id=989",target:"_blank",rel:"noopener noreferrer"},Ra=t(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># session1:</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
 
<span class="token comment"># session2:</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">;</span>
 
<span class="token comment"># 如果user1在一个表上有一个活动的事务，然后user2删除这个表，那么user1会提交，那么在binlog中我们有如下内容(binlog记录的操作顺序顺序)：</span>
<span class="token number">1.</span> 
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">;</span>
 
<span class="token number">2.</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很显然mysql执行时会先删除表t，然后执行insert 会报1032 error。</p><p>再举一个简单的例子，如果你在查询一个表的过程中，另外一个session对该表删除了一个列，那前面的查询到底该显示什么呢？如果在RR隔离级别下，事物中再次执行相同的语句还会和之前结果一致吗？</p><p>答案是否定的，RR隔离级别下，会话A在2次查询期间，会话B对表结构做了修改，两次查询结果就会不一致，无法满足可重复读的要求。</p><p>为了防止这种情况，所以在5.5.3版本引入了MDL锁(表查询开始MySQL会在表上加一个锁，来防止被别的session修改了表定义，)。其实5.5也有类似保护元数据的机制，只是没有明确提出MDL概念而已。但是5.5之前版本(比如5.1)与5.5之后版本在保护元数据这块有一个显著的不同点是，5.1对于元数据的保护是语句级别的，5.5对于Metadata的保护是事务级别的。所谓语句级别，即语句执行完成后，无论事务是否提交或回滚，其表结构可以被其他会话更新；而事务级别则是在事务结束后才释放MDL。引入MDL锁主要是为了解决两个问题：</p><ul><li><p><strong>事务隔离问题</strong>：比如在可重复隔离级别下，会话A在2次查询期间，会话B对表结构做了修改，两次查询结果就会不一致，无法满足可重复读的要求。</p></li><li><p><strong>数据复制问题</strong>：比如会话A执行了多条更新语句期间，另外一个会话B做了表结构变更并且先提交，就会导致slave在重做时，先重做alter，再重做update时就会出现复制错误的现象。也就是上面提到的bug#989。</p></li><li><p><strong>DDL操作与MetaData Lock</strong></p><ul><li><p>Metadata lock 机制是为了保证数据一致性存在的，在有session操作时候某张表时，需要首先获得Metadata lock ,然后操作，如果这个时候，又来了一个session要DDL操作同一个表，就会出现 <code>waiting for table metadata lock</code></p></li><li><p>自动提交模式下，单语句就是一个事务，执行完了，事务也就结束了。</p></li><li><p>preparestatement 会获得 metalock，一旦 prepare 完毕， metalock 就释放了。</p></li><li><p>online DDL应该是指在<code>alter table</code>进行的时候， 插入/修改/删除数据的sql语句(DML)不会<code>Waiting for table metadata lock</code>。一旦<code>alter table TableA</code>的操作停滞在<code>Waiting for table metadata lock</code>的状态，后续对TableA的任何操作（包括读）都无法进行，也会在Opening tables的阶段进入<code>Waiting for table metadata lock</code>的队列。</p></li></ul></li></ul><h5 id="_5-3-2-2-metadata-lock和行锁" tabindex="-1"><a class="header-anchor" href="#_5-3-2-2-metadata-lock和行锁" aria-hidden="true">#</a> 5.3.2.2 metadata lock和行锁</h5><p>元数据锁是server层的锁，表级锁，每执行一条DML、DDL语句时都会申请metadata锁，DML操作需要metadata读锁，DDL操作需要metadata写锁，metadata加锁过程是系统自动控制，无法直接干预，读锁和写锁的阻塞关系如下：</p><ol><li>读锁和写锁之间相互阻塞，即同一个表上的DML和DDL之间互相阻塞。</li><li>写锁和写锁之间互相阻塞，即两个session不能对表同时做表定义变更，需要串行操作。</li><li>读锁和读锁之间不会产生阻塞。也就是增删改查不会因为metadata lock产生阻塞，可以并发执行，日常工作中大家看到的DML之间的锁等待是innodb行锁引起的，和metadata lock无关。</li></ol><p>申请metadata锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到metadata锁锁后，直到事务执行完才会将锁释放。（这里有种特殊情况如果事务中包含DDL操作，mysql会在DDL操作语句执行前，隐式提交commit，以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放）。</p><p>熟悉innodb行锁的同学这里可能有点疑困惑，因为行锁分类和metadata lock很类似，也主要分为读锁和写锁，或者叫共享锁和排他锁，读写锁之间阻塞关系也一致。二者最重要的区别一个是表锁，一个是行锁，且行锁中的读写操作对应在metadata lock中都属于读锁。</p><p>注意： 支持事务的InnoDB引擎表和不支持事务的MyISAM引擎表，都会出现Metadata Lock Wait等待现象。一旦出现Metadata Lock Wait等待现象，后续所有对该表的访问都会阻塞在该等待上，导致连接堆积，业务受影响。</p><p>metadata lock锁通常发生在DDL操作挂起的时候，原因是有未提交的事务对该表进行DML操作。而MySQL的会话那么多，不知道哪个会话的操作没有及时提交影响了DDL。通常我们排查这类问题，往往需要从information_schema.innodb_trx表中查询当前在执行的事务，但当SQL已经执行过了，没有commit，这个时候这个表中是看不到SQL的。</p><p>大家也许会奇怪，以前听说普通查询不加锁的，怎么这里又说要加表锁，我们做一个简单测试：</p><p>【<strong>模拟与查找MDL锁</strong>】</p><p>在MySQL5.7中，performance_schema库中新增了metadata_locks表，专门记录MDL的相关信息。首先要开启metadata_locks锁记录，执行如下SQL开启：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> performance_schema<span class="token punctuation">.</span>setup_instruments
<span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">&#39;YES&#39;</span><span class="token punctuation">,</span> TIMED <span class="token operator">=</span> <span class="token string">&#39;YES&#39;</span>
<span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">&#39;wait/lock/metadata/sql/mdl&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>session1</strong>：查询前，先看一下<strong>metadata_locks表</strong>，这个表<strong>位于performance_schema下</strong>，记录了<strong>metadata lock的加锁信息。</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; select * from performance_schema.metadata_locks;
+-------------+--------------------+----------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
| OBJECT_TYPE | OBJECT_SCHEMA      | OBJECT_NAME    | OBJECT_INSTANCE_BEGIN | LOCK_TYPE   | LOCK_DURATION | LOCK_STATUS | SOURCE            | OWNER_THREAD_ID | OWNER_EVENT_ID |
+-------------+--------------------+----------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
| TABLE       | performance_schema | metadata_locks |         2459204563344 | SHARED_READ | TRANSACTION   | GRANTED     | sql_parse.cc:6020 |              36 |              3 |
+-------------+--------------------+----------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**session2：**执行简单查询。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; begin;
 
mysql&gt; SELECT * from students;   # 注意事务未提交
+----+-----------+------+--------+--------+--------+-----------+
| id | name      | age  | height | gender | cls_id | is_delete |
+----+-----------+------+--------+--------+--------+-----------+
|  1 | 小明      |   18 | 180.00 | 女     |      1 |           |
|  2 | 小月月    |   18 | 180.00 | 女     |      1 |          |
|  3 | 彭于晏    |   29 | 185.00 | 男     |      1 |           |
|  4 | 刘德华    |   59 | 185.00 | 男     |      1 |           |
|  5 | 黄蓉      |   38 | 160.00 | 女     |      1 |           |
|  6 | 凤姐      |   28 | 150.00 | 保密   |      2 |          |
|  7 | 王祖贤    |   18 | 172.00 | 女     |      1 |          |
|  8 | 周杰伦    |   36 |   NULL | 男     |      1 |           |
|  9 | 程坤      |   27 | 181.00 | 男     |      2 |           |
| 10 | 刘亦菲    |   25 | 166.00 | 女     |      2 |           |
| 11 | 金星      |   33 | 162.00 | 中性   |      3 |          |
| 12 | 静香      |   12 | 180.00 | 女     |      4 |           |
| 13 | 郭靖      |   12 | 170.00 | 男     |      4 |           |
| 14 | 周杰      |   34 | 176.00 | 女     |      5 |           |
+----+-----------+------+--------+--------+--------+-----------+
14 rows in set (0.00 sec) 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>session1</strong>： 在会话1中查看<strong>metadata_locks表</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; select * from performance_schema.metadata_locks;
+-------------+--------------------+----------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
| OBJECT_TYPE | OBJECT_SCHEMA      | OBJECT_NAME    | OBJECT_INSTANCE_BEGIN | LOCK_TYPE   | LOCK_DURATION | LOCK_STATUS | SOURCE            | OWNER_THREAD_ID | OWNER_EVENT_ID |
+-------------+--------------------+----------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
| TABLE       | report-vision      | students       |         2459204563152 | SHARED_READ | TRANSACTION   | GRANTED     | sql_parse.cc:6020 |              37 |             17 |
| TABLE       | performance_schema | metadata_locks |         2459204563440 | SHARED_READ | TRANSACTION   | GRANTED     | sql_parse.cc:6020 |              36 |              4 |
+-------------+--------------------+----------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
2 rows in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时再次查看metadata_lock表，发现多了一条students的加锁记录，加锁类型为SHARED_READ,且状态是已授予（GRANTED)。大家通常理解的查询不加锁，是指不在表上加innodb行锁。</p><p>如果在session2执行select期间且事务未提交，另外一个session执行了一个DDL操作，此时就会产生互斥的metadata lock：</p><p><strong>session3</strong>：执行删除该表操作（DDL），发现该语句执行状态挂起</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; drop table students;
 
阻塞中......
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>session1</strong>：查询所有会话 发现发生MDL锁</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show processlist;
+----+------+-----------------+---------------+---------+------+---------------------------------+---------------------+
| Id | User | Host            | db            | Command | Time | State                           | Info                |
+----+------+-----------------+---------------+---------+------+---------------------------------+---------------------+
|  2 | root | localhost:64908 | NULL          | Sleep   | 4991 |                                 | NULL                |
|  3 | root | localhost:64940 | report-vision | Sleep   | 4991 |                                 | NULL                |
|  4 | root | localhost:64970 | report-vision | Sleep   | 4981 |                                 | NULL                |
|  5 | root | localhost:65012 | report-vision | Sleep   |  433 |                                 | NULL                |
|  6 | root | localhost:65449 | report-vision | Sleep   | 4799 |                                 | NULL                |
|  7 | root | localhost:65454 | report-vision | Sleep   | 4797 |                                 | NULL                |
|  8 | root | localhost:50270 | report-vision | Sleep   |  438 |                                 | NULL                |
|  9 | root | localhost:51163 | report-vision | Sleep   | 3869 |                                 | NULL                |
| 11 | root | localhost:59351 | NULL          | Query   |    0 | starting                        | show processlist    |
| 12 | root | localhost:59625 | report-vision | Sleep   |  121 |                                 | NULL                |
| 13 | root | localhost:59689 | report-vision | Query   |   14 | Waiting for table metadata lock | drop table students |
+----+------+-----------------+---------------+---------+------+---------------------------------+---------------------+
11 rows in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，id为13的线程还未执行drop操作，状态为<code>Waiting for table metadata lock</code>，也就是在等待session2的事务提交操作完成。</p><p><strong>session1</strong>：查看metadata_locks表记录 发现students表有MDL锁冲突</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; select * from performance_schema.metadata_locks;
+-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+-------------------+-----------------+----------------+
| OBJECT_TYPE | OBJECT_SCHEMA      | OBJECT_NAME    | OBJECT_INSTANCE_BEGIN | LOCK_TYPE           | LOCK_DURATION | LOCK_STATUS | SOURCE            | OWNER_THREAD_ID | OWNER_EVENT_ID |
+-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+-------------------+-----------------+----------------+
| TABLE       | report-vision      | students       |         2459204563152 | SHARED_READ         | TRANSACTION   | GRANTED     | sql_parse.cc:6020 |              37 |             17 |
| GLOBAL      | NULL               | NULL           |         2459204563440 | INTENTION_EXCLUSIVE | STATEMENT     | GRANTED     | sql_base.cc:5497  |              38 |              6 |
| SCHEMA      | report-vision      | NULL           |         2459204563728 | INTENTION_EXCLUSIVE | TRANSACTION   | GRANTED     | sql_base.cc:5482  |              38 |              6 |
| TABLE       | report-vision      | students       |         2459204564400 | EXCLUSIVE           | TRANSACTION   | PENDING     | sql_parse.cc:6020 |              38 |              6 |
| TABLE       | performance_schema | metadata_locks |         2459204563920 | SHARED_READ         | TRANSACTION   | GRANTED     | sql_parse.cc:6020 |              36 |              6 |
+-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+-------------------+-----------------+----------------+
5 rows in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 session2 的事务提交后：</p><p>session2：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>session3：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; drop table students;
Query OK, 0 rows affected (4 min 11.77 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-3-2-3-元数据锁可能造成系统崩溃" tabindex="-1"><a class="header-anchor" href="#_5-3-2-3-元数据锁可能造成系统崩溃" aria-hidden="true">#</a> 5.3.2.3 元数据锁可能造成系统崩溃</h5><p>举一个简单例子，session1启动一个事务，对表students执行一个简单的查询；session2对students加一个字段；session3来对students做一个查询；session4来对students做一个update，各个session串行操作。</p><p><strong>session1：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)
 
mysql&gt; SELECT * from students where id=1;
+----+--------+------+--------+--------+--------+-----------+
| id | name   | age  | height | gender | cls_id | is_delete |
+----+--------+------+--------+--------+--------+-----------+
|  1 | 小明   |   18 | 180.00 | 女     |      1 |           |
+----+--------+------+--------+--------+--------+-----------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>session2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; alter table students add column col1 int;​
 
阻塞中...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>session3:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; select sleep(10) from students;  # 开始执行后还会阻塞一段时间
 
 
阻塞中...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>session4:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; update students set name=&#39;aaaa&#39; where id=1;
 
阻塞中...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是由于session1的一个事务没有提交，导致session2的DDL操作被阻塞，session3和session4本身不会被session1阻塞，但由于在锁队列中，session2排队更早，它准备加的是metadata lock写锁，阻塞了session3和session4的读锁。如果students是一个执行频繁的表，<code>show processlist</code>会发现大量<code>waiting for table metadata lock</code>的线程，数据库连接很快就会消耗完，导致业务系统无法正常响应。</p><p>此时如果session1提交，是session2的alter语句先执行还是session3和session4先执行呢？</p><p>之前一直以为先到的先执行，当然是session2先执行，但经过测试，在5.7中，session3和session4先执行，session2最后执行（如果为drop语句依然是session2最先执行），也就会出现alter(或其他DDL语句)长时间无法执行的情况；而在8.0中，session2先执行，session3和session4后执行，由于5.6以后DDL是online的（drop 相关的DDL除外），session2并不会阻塞session3和session4，感觉这样才是合理的，alter不会被‘饿死’。</p><h5 id="_5-3-2-4-如何快速找到阻塞源头" tabindex="-1"><a class="header-anchor" href="#_5-3-2-4-如何快速找到阻塞源头" aria-hidden="true">#</a> 5.3.2.4 如何快速找到阻塞源头？</h5><p>监控元数据锁</p><p>快速解决问题永远是第一位的，一旦出现长时间的metadata lock，尤其是在访问频繁的业务表上产生，通常会导致表无法访问，读写全被阻塞，此时找到阻塞源头是第一位的。这里最重要的表就是前面提到过的performance_schema.metadata_locks表。</p><p>metadata_locks是5.7中被引入，记录了metadata lock的相关信息，包括持有对象、类型、状态等信息。但5.7默认设置是关闭的（8.0默认打开），需要通过下面命令打开设置：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> performance_schema<span class="token punctuation">.</span>setup_instruments <span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">&#39;YES&#39;</span><span class="token punctuation">,</span> TIMED <span class="token operator">=</span> <span class="token string">&#39;YES&#39;</span><span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">&#39;wait/lock/metadata/sql/mdl&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果要永久生效，需要在配置文件中加入如下内容：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>[mysqld]
<span class="token key attr-name">performance-schema-instrument</span><span class="token punctuation">=</span><span class="token value attr-value">&#39;wait/lock/metadata/sql/mdl=ON&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>单纯查询这个表无法得出具体的阻塞关系，也无法得知什么语句造成的阻塞，这里要关联另外两个表performance_schema.thread和performance_schema.events_statements_history,thread表可以将线程id和show processlist中id关联，events_statements_history表可以得到事务的历史sql，关联得到一条监控元数据锁的sql语句。</p><p>关联后的完整sql如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> locked_schema<span class="token punctuation">,</span>
locked_table<span class="token punctuation">,</span>
locked_type<span class="token punctuation">,</span>
waiting_processlist_id<span class="token punctuation">,</span>
waiting_age<span class="token punctuation">,</span>
waiting_query<span class="token punctuation">,</span>
waiting_state<span class="token punctuation">,</span>
blocking_processlist_id<span class="token punctuation">,</span>
blocking_age<span class="token punctuation">,</span>
substring_index<span class="token punctuation">(</span>sql_text<span class="token punctuation">,</span><span class="token string">&quot;transaction_begin;&quot;</span> <span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> blocking_query<span class="token punctuation">,</span>
sql_kill_blocking_connection
<span class="token keyword">FROM</span> 
<span class="token punctuation">(</span> 
<span class="token keyword">SELECT</span> 
b<span class="token punctuation">.</span>OWNER_THREAD_ID <span class="token keyword">AS</span> granted_thread_id<span class="token punctuation">,</span>
a<span class="token punctuation">.</span>OBJECT_SCHEMA <span class="token keyword">AS</span> locked_schema<span class="token punctuation">,</span>
a<span class="token punctuation">.</span>OBJECT_NAME <span class="token keyword">AS</span> locked_table<span class="token punctuation">,</span>
<span class="token string">&quot;Metadata Lock&quot;</span> <span class="token keyword">AS</span> locked_type<span class="token punctuation">,</span>
c<span class="token punctuation">.</span>PROCESSLIST_ID <span class="token keyword">AS</span> waiting_processlist_id<span class="token punctuation">,</span>
c<span class="token punctuation">.</span>PROCESSLIST_TIME <span class="token keyword">AS</span> waiting_age<span class="token punctuation">,</span>
c<span class="token punctuation">.</span>PROCESSLIST_INFO <span class="token keyword">AS</span> waiting_query<span class="token punctuation">,</span>
c<span class="token punctuation">.</span>PROCESSLIST_STATE <span class="token keyword">AS</span> waiting_state<span class="token punctuation">,</span>
d<span class="token punctuation">.</span>PROCESSLIST_ID <span class="token keyword">AS</span> blocking_processlist_id<span class="token punctuation">,</span>
d<span class="token punctuation">.</span>PROCESSLIST_TIME <span class="token keyword">AS</span> blocking_age<span class="token punctuation">,</span>
d<span class="token punctuation">.</span>PROCESSLIST_INFO <span class="token keyword">AS</span> blocking_query<span class="token punctuation">,</span>
concat<span class="token punctuation">(</span><span class="token string">&#39;KILL &#39;</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span>PROCESSLIST_ID<span class="token punctuation">)</span> <span class="token keyword">AS</span> sql_kill_blocking_connection
<span class="token keyword">FROM</span> performance_schema<span class="token punctuation">.</span>metadata_locks a <span class="token keyword">JOIN</span> performance_schema<span class="token punctuation">.</span>metadata_locks b <span class="token keyword">ON</span> a<span class="token punctuation">.</span>OBJECT_SCHEMA <span class="token operator">=</span> b<span class="token punctuation">.</span>OBJECT_SCHEMA <span class="token operator">AND</span> a<span class="token punctuation">.</span>OBJECT_NAME <span class="token operator">=</span> b<span class="token punctuation">.</span>OBJECT_NAME
<span class="token operator">AND</span> a<span class="token punctuation">.</span>lock_status <span class="token operator">=</span> <span class="token string">&#39;PENDING&#39;</span>
<span class="token operator">AND</span> b<span class="token punctuation">.</span>lock_status <span class="token operator">=</span> <span class="token string">&#39;GRANTED&#39;</span>
<span class="token operator">AND</span> a<span class="token punctuation">.</span>OWNER_THREAD_ID <span class="token operator">&lt;&gt;</span> b<span class="token punctuation">.</span>OWNER_THREAD_ID
<span class="token operator">AND</span> a<span class="token punctuation">.</span>lock_type <span class="token operator">=</span> <span class="token string">&#39;EXCLUSIVE&#39;</span>
<span class="token keyword">JOIN</span> performance_schema<span class="token punctuation">.</span>threads c <span class="token keyword">ON</span> a<span class="token punctuation">.</span>OWNER_THREAD_ID <span class="token operator">=</span> c<span class="token punctuation">.</span>THREAD_ID <span class="token keyword">JOIN</span> performance_schema<span class="token punctuation">.</span>threads d <span class="token keyword">ON</span> b<span class="token punctuation">.</span>OWNER_THREAD_ID <span class="token operator">=</span> d<span class="token punctuation">.</span>THREAD_ID
<span class="token punctuation">)</span> t1<span class="token punctuation">,</span>
<span class="token punctuation">(</span>
<span class="token keyword">SELECT</span> thread_id<span class="token punctuation">,</span> group_concat<span class="token punctuation">(</span> <span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> EVENT_NAME <span class="token operator">=</span> <span class="token string">&#39;statement/sql/begin&#39;</span> <span class="token keyword">THEN</span> <span class="token string">&quot;transaction_begin&quot;</span> <span class="token keyword">ELSE</span> sql_text <span class="token keyword">END</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> event_id SEPARATOR <span class="token string">&quot;;&quot;</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> sql_text
<span class="token keyword">FROM</span>
performance_schema<span class="token punctuation">.</span>events_statements_history
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> thread_id
<span class="token punctuation">)</span> t2
<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>granted_thread_id <span class="token operator">=</span> t2<span class="token punctuation">.</span>thread_id \\G
 
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
               locked_schema: report<span class="token operator">-</span>vision
                locked_table: students
                 locked_type: Metadata <span class="token keyword">Lock</span>
      waiting_processlist_id: <span class="token number">13</span>
                 waiting_age: <span class="token number">938</span>
               waiting_query: <span class="token keyword">alter</span> <span class="token keyword">table</span> students <span class="token keyword">add</span> <span class="token keyword">column</span> col1 <span class="token keyword">int</span>
               waiting_state: Waiting <span class="token keyword">for</span> <span class="token keyword">table</span> metadata <span class="token keyword">lock</span>
     blocking_processlist_id: <span class="token number">12</span>
                blocking_age: <span class="token number">947</span>
              blocking_query: <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> students <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span>
sql_kill_blocking_connection: <span class="token keyword">KILL</span> <span class="token number">12</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据显示结果，processlist_id为12的线程阻塞了13的线程，我们需要kill 12即可解锁。</p><p>实际上，MySQL也提供了一个类似的视图来解决metadata lock问题，视图名称为sys.schema_table_lock_waits，但此视图查询结果有bug，不是很准确，建议大家还是参考上面sql。</p><h5 id="_5-3-2-5-如何避免元数据锁阻塞" tabindex="-1"><a class="header-anchor" href="#_5-3-2-5-如何避免元数据锁阻塞" aria-hidden="true">#</a> 5.3.2.5 如何避免元数据锁阻塞</h5><p>MDL锁一旦发生会对业务造成极大影响，因为后续所有对该表的访问都会被阻塞，造成连接积压。我们日常要尽量避免 MDL 锁阻塞的发生，下面给出几点优化建议可供参考：</p><ul><li>开启 metadata_locks 表记录 MDL 锁。</li><li>设置参数 lock_wait_timeout 为较小值，使被阻塞端主动停止。</li><li>规范使用事务，及时提交事务，避免使用大事务。</li><li>增强监控告警，及时发现 MDL 锁。</li><li>DDL 操作及备份操作放在业务低峰期执行。</li><li>对于表结构经常变化且不关心原有表名只查询实时最新数据的特殊业务场景，可以在每次变更表结构时，用不同的表名（表名为添加后缀，如时间戳或uuid的表名）保存最新数据，随机定时异步删除原有的表名。来避免DDL操作与DML操作阻塞。</li></ul><h4 id="_5-3-3-意向锁" tabindex="-1"><a class="header-anchor" href="#_5-3-3-意向锁" aria-hidden="true">#</a> 5.3.3 意向锁</h4><h5 id="_5-3-3-1-意向锁概述" tabindex="-1"><a class="header-anchor" href="#_5-3-3-1-意向锁概述" aria-hidden="true">#</a> 5.3.3.1 意向锁概述</h5><p>需要强调一下，意向锁是一种不与行级锁冲突表级锁，这一点非常重要。意向锁分为两种：</p><p>【意向共享锁】（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span>
<span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>【意向排他锁】（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span>
<span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>即：意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><h5 id="_5-3-3-2-加锁示例" tabindex="-1"><a class="header-anchor" href="#_5-3-3-2-加锁示例" aria-hidden="true">#</a> 5.3.3.2 加锁示例</h5><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><img src="`+on+'" alt="image-20220426161203823" style="zoom:50%;"><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。</p><img src="'+ln+'" alt="image-20220426161235688" style="zoom:50%;"><p>有了意向锁之后 :</p><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p><img src="'+cn+'" alt="image-20220426161359156" style="zoom:50%;"><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p><img src="'+dn+`" alt="image-20220426161508026" style="zoom:50%;"><h5 id="_5-3-3-3-意向锁要解决的问题" tabindex="-1"><a class="header-anchor" href="#_5-3-3-3-意向锁要解决的问题" aria-hidden="true">#</a> 5.3.3.3 意向锁要解决的问题</h5><p>我们先来看一下百度百科上对意向锁存在意义的描述：</p><blockquote><p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p></blockquote><p>设想这样一张 users 表： MySql，InnoDB，Repeatable-Read：users（id PK，name）</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>ROADHOG</td></tr><tr><td>2</td><td>Reinhardt</td></tr><tr><td>3</td><td>Tracer</td></tr><tr><td>4</td><td>Genji</td></tr><tr><td>5</td><td>Hanzo</td></tr><tr><td>6</td><td>Mccree</td></tr></tbody></table><p>事务 A 获取了某一行的排他锁，并未提交：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>事务 B 想要获取 users 表的表锁：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> users <span class="token keyword">READ</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为共享锁与排他锁互斥，所以事务 B 在视图对 users 表加共享锁的时候，必须保证：</p><ul><li>当前没有其他事务持有 users 表的排他锁。</li><li>当前没有其他事务持有 users 表中任意一行的排他锁 。</li></ul><p>为了检测是否满足第二个条件，事务 B 必须在确保 users表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了</p><h5 id="_5-3-3-4-意向锁的兼容性" tabindex="-1"><a class="header-anchor" href="#_5-3-3-4-意向锁的兼容性" aria-hidden="true">#</a> 5.3.3.4 意向锁的兼容性</h5><p>意向锁是怎么解决这个问题的呢？首先，我们需要知道意向锁之间的兼容互斥性：</p><table><thead><tr><th></th><th>意向共享锁（IS）</th><th>意向排他锁（IX）</th></tr></thead><tbody><tr><td><strong>意向共享锁（IS）</strong></td><td>兼容</td><td>兼容</td></tr><tr><td><strong>意向排他锁（IX）</strong></td><td>兼容</td><td>兼容</td></tr></tbody></table><p>即意向锁之间是互相兼容的，emmm......那你存在的意义是啥？</p><p>虽然意向锁和自家兄弟互相兼容，但是它会与普通的排他 / 共享锁互斥：</p><table><thead><tr><th></th><th>意向共享锁（IS）</th><th>意向排他锁（IX）</th></tr></thead><tbody><tr><td><strong>共享锁（S）</strong></td><td>兼容</td><td>互斥</td></tr><tr><td><strong>排他锁（X）</strong></td><td>互斥</td><td>互斥</td></tr></tbody></table><p><strong>注意：这里的排他/共享锁指的都是表锁！！！，意向锁不会与行级的共享/排他锁互斥！！！</strong></p><p>现在我们回到刚才 users 表的例子：</p><p><strong>事务 A</strong> 获取了某一行的排他锁，并未提交：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM users WHERE id = 6 FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时 users 表存在两把锁：users 表上的<strong>意向排他锁</strong>与 id 为 6 的数据行上的<strong>排他锁</strong>。</p><p><strong>事务 B</strong> 想要获取 users 表的共享锁：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>LOCK TABLES users READ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时事务 B 检测事务 A 持有 users 表的<strong>意向排他锁</strong>，就可以得知事务 A 必然持有该表中某些数据行的<strong>排他锁</strong>，那么事务 B 对 users 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p><h5 id="_5-3-3-5-意向锁的并发性" tabindex="-1"><a class="header-anchor" href="#_5-3-3-5-意向锁的并发性" aria-hidden="true">#</a> 5.3.3.5 意向锁的并发性</h5><p>这就牵扯到我前面多次强调的一件事情：</p><p><strong>意向锁不会与行级的共享/排他锁互斥！！！ 意向锁不会与行级的共享/排他锁互斥！！！ 意向锁不会与行级的共享/排他锁互斥！！！</strong></p><p>重要的话要加粗说三遍，正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性（不然我们直接用普通的表锁就行了）。</p><p>最后我们扩展一下上面 users 表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>ROADHOG</td></tr><tr><td>2</td><td>Reinhardt</td></tr><tr><td>3</td><td>Tracer</td></tr><tr><td>4</td><td>Genji</td></tr><tr><td>5</td><td>Hanzo</td></tr><tr><td>6</td><td>Mccree</td></tr></tbody></table><p>事务 A 先获取了某一行的<strong>排他锁</strong>，并未提交：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM users WHERE id = 6 FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>事务 A 获取了 users 表上的<strong>意向排他锁</strong>。</li><li>事务 A 获取了 id 为 6 的数据行上的<strong>排他锁</strong>。</li></ol><p>之后事务 B 想要获取 users 表的<strong>共享锁</strong>：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> users <span class="token keyword">READ</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>事务 B 检测到事务 A 持有 users 表的<strong>意向排他锁</strong>。</li><li>事务 B 对 users 表的加锁请求被阻塞（排斥）。</li></ol><p>最后事务 C 也想获取 users 表中某一行的<strong>排他锁</strong>：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>事务 C 申请 users 表的<strong>意向排他锁</strong>。</li><li>事务 C 检测到事务 A 持有 users 表的<strong>意向排他锁</strong>。</li><li>因为意向锁之间并不互斥，所以事务 C 获取到了 users 表的<strong>意向排他锁</strong>。</li><li>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终事务 C 成功获取到了该数据行上的<strong>排他锁</strong>。</li></ol><h5 id="_5-3-3-6-总结" tabindex="-1"><a class="header-anchor" href="#_5-3-3-6-总结" aria-hidden="true">#</a> 5.3.3.6 总结</h5><ol><li>InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁共存。</li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外，意向锁会与 共享锁 / 排他锁 互斥。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</li><li>意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ol><blockquote><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p></blockquote><h3 id="_5-4-行级锁" tabindex="-1"><a class="header-anchor" href="#_5-4-行级锁" aria-hidden="true">#</a> 5.4 行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。行级锁主要分为三类：行锁、间隙锁、临健锁。<strong>在不同的事务隔离级别下，对行级锁的支持也是不同的</strong>。在读以提交（Read Commit）级别，行级锁的种类只有行锁（Record Lock），在可重复读（Repeatable Read）隔离级别下，行级锁的种类除了行锁(Record Lock), 还有间隙锁(Gap Lock)、临健锁(Next-Key Lock)</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li><p><strong>行锁（Record Lock）</strong>：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p><img src="`+rn+'" alt="image-20220426161744776" style="zoom:50%;"></li><li><p><strong>间隙锁（Gap Lock）</strong>：锁定索引记录间隙（不含该记录本身），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持。</p><img src="'+un+'" alt="image-20220426161827629" style="zoom:50%;"></li><li><p><strong>临键锁（Next-Key Lock）</strong>：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。 <img src="'+kn+`" alt="image-20220426161908510" style="zoom:50%;"></p></li></ul><h4 id="_5-4-1-行锁" tabindex="-1"><a class="header-anchor" href="#_5-4-1-行锁" aria-hidden="true">#</a> 5.4.1 行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</p></li></ul><p>两种行锁的兼容情况如下:</p><table><thead><tr><th style="text-align:center;"></th><th>S(共享锁)</th><th>X(排他锁)</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>S(共享锁)</strong></td><td>兼容</td><td>冲突</td></tr><tr><td style="text-align:center;"><strong>X(排他锁)</strong></td><td>冲突</td><td>冲突</td></tr></tbody></table><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><p>举个例子，当一个事务执行了下面这条语句：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql &gt; begin;
mysql &gt; select * from t_test where id = 1 for update;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>事务会对表中主键 id = 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改和删除了。</p><p><img src="`+mn+'" alt="img"></p><p>当事务执行 commit 后，事务过程中生成的锁都会被释放</p><p>常见的SQL语句，在执行时，所加的行锁如下：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT ...</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE ...</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE ...</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT ... LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT ... FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p><strong>演示</strong></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key(临健锁) 锁进行搜索和索引扫描，以防止幻读。</p><ul><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</p></li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数据准备</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n<span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n<span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n<span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4<span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;tom&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;cat&#39;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">&#39;rose&#39;</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">&#39;jetty&#39;</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">&#39;lily&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">&#39;luci&#39;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>演示行锁的时候，我们就通过上面这张表来演示一下。</p><ol><li>普通的select语句，执行时，不会加锁。</li></ol><p><img src="'+gn+'" alt="image-20231207191323869"></p><ol start="2"><li>select...lock in share mode，加共享锁，共享锁与共享锁之间兼容。</li></ol><p><img src="'+bn+'" alt="image-20231207191418600"></p><ol start="3"><li>共享锁与排他锁之间互斥。</li></ol><p><img src="'+vn+'" alt="image-20231207191518513"></p><p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互斥。</p><ol start="4"><li>排它锁与排他锁之间互斥</li></ol><p><img src="'+hn+'" alt="image-20231207191604414"></p><p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。</p><ol start="5"><li>无索引行锁升级为表锁</li></ol><p>stu表中数据如下:</p><p><img src="'+_n+'" alt="image-20231207191720661"></p><p>我们在两个客户端中执行如下操作:</p><p><img src="'+yn+'" alt="image-20231207191739044"></p><p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？</p><p>原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。</p><p>接下来，我们再针对name字段建立索引，索引建立之后，再次做一个测试：</p><p><img src="'+wn+'" alt="image-20231207191818491"></p><p>此时我们可以看到，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3的数据时，更新成功，并未进入阻塞状态。 这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。</p><h4 id="_5-4-2-间隙锁-临健锁" tabindex="-1"><a class="header-anchor" href="#_5-4-2-间隙锁-临健锁" aria-hidden="true">#</a> 5.4.2 间隙锁&amp;临健锁</h4><p><strong>间隙锁(Gap Locks)是封锁索引记录中的间隔</strong>，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。</p><p><strong>产生间隙锁的条件（RR事务隔离级别下；）：</strong></p><ol><li>使用普通索引锁定；</li><li>使用多列唯一索引；</li><li>使用唯一索引锁定多行记录。</li></ol><p>以上情况，都会产生间隙锁，下面是小编看了官方文档理解的：</p><blockquote><p>对于使用唯一索引来搜索并给某一行记录加锁的语句，不会产生间隙锁。（这不包括搜索条件仅包括多列唯一索引的一些列的情况；在这种情况下，会产生间隙锁。）例如，如果id列具有唯一索引，则下面的语句仅对具有id值100的行使用记录锁，并不会产生间隙锁：</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> child <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">100</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这条语句，就只会产生记录锁，不会产生间隙锁。</p><p><strong>打开间隙锁设置</strong></p><p>首先查看 innodb_locks_unsafe_for_binlog 是否禁用：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;innodb_locks_unsafe_for_binlog&#39;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>TODO  mysql执行结果\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>innodb_locks_unsafe_for_binlog：默认值为OFF，即启用间隙锁。因为此参数是只读模式，如果想要禁用间隙锁，需要修改 my.cnf（windows是my.ini） 重新启动才行。</p><div class="language-ini line-numbers-mode" data-ext="ini"><pre class="language-ini"><code><span class="token comment"># 在 my.cnf 里面的[mysqld]添加</span>\n<span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span>\n<span class="token key attr-name">innodb_locks_unsafe_for_binlog</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-4-2-1-唯一索引的间隙锁" tabindex="-1"><a class="header-anchor" href="#_5-4-2-1-唯一索引的间隙锁" aria-hidden="true">#</a> 5.4.2.1 唯一索引的间隙锁</h5><p>测试环境： MySQL，InnoDB，默认的隔离级别（RR）</p><p>数据准备：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>\n\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;小罗&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;5&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;小黄&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;7&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;小明&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;11&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;小红&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在进行测试之前，我们先来看看test表中存在的隐藏间隙：</p><ol><li>(-infinity, 1]</li><li>(1, 5]</li><li>(5, 7]</li><li>(7, 11]</li><li>(11, +infinity]</li></ol><p><strong>【只使用记录锁，不会产生间隙锁】</strong></p><p>我们现在进行以下几个事务的测试：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">/* 开启事务1 */</span>\n<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>\n<span class="token comment">/* 查询 id = 5 的数据并加记录锁 */</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>\n<span class="token comment">/* 延迟30秒执行，防止锁释放 */</span>\n<span class="token keyword">SELECT</span> SLEEP<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span>\n\n<span class="token comment">/* 事务2插入一条 name = &#39;小张&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;小张&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务3插入一条 name = &#39;小张&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">&#39;小东&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 提交事务1，释放事务1的锁 */</span>\n<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上诉的案例，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以以上的例子，只会对 id = 5 的数据加上记录锁，而不会产生间隙锁。</p><p><strong>【产生间隙锁】</strong></p><p>我们继续在 id 唯一索引列上做以下的测试：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">/* 开启事务1 */</span>\n<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>\n<span class="token comment">/* 查询 id 在 7 - 11 范围的数据并加记录锁 */</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">BETWEEN</span> <span class="token number">5</span> <span class="token operator">AND</span> <span class="token number">7</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>\n<span class="token comment">/* 延迟30秒执行，防止锁释放 */</span>\n<span class="token keyword">SELECT</span> SLEEP<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span>\n\n<span class="token comment">/* 事务2插入一条 id = 3，name = &#39;小张1&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;小张1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务3插入一条 id = 4，name = &#39;小白&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;小白&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务4插入一条 id = 6，name = &#39;小东&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">&#39;小东&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务5插入一条 id = 8， name = &#39;大罗&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">&#39;大罗&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务6插入一条 id = 9， name = &#39;大东&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">&#39;大东&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务7插入一条 id = 11， name = &#39;李西&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">&#39;李西&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务8插入一条 id = 12， name = &#39;张三&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">&#39;张三&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 提交事务1，释放事务1的锁 */</span>\n<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面我们可以看到，(5, 7]、(7, 11] 这两个区间，都不可插入数据，其它区间，都可以正常插入数据。所以我们可以得出结论：<strong>当我们给 (5, 7] 这个区间加锁的时候，会锁住 (5, 7]、(7, 11] 这两个区间。</strong></p><p>我们再来测试如果我们锁住不存在的数据时，会怎样：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">/* 开启事务1 */</span>\n<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>\n<span class="token comment">/* 查询 id = 3 这一条不存在的数据并加记录锁 */</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>\n<span class="token comment">/* 延迟30秒执行，防止锁释放 */</span>\n<span class="token keyword">SELECT</span> SLEEP<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span>\n\n<span class="token comment">/* 事务2插入一条 id = 3，name = &#39;小张1&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;小张1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务3插入一条 id = 4，name = &#39;小白&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;小白&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务4插入一条 id = 6，name = &#39;小东&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">&#39;小东&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务5插入一条 id = 8， name = &#39;大罗&#39; 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">&#39;大罗&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 提交事务1，释放事务1的锁 */</span>\n<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁。</p><p><strong>结论</strong></p><ol><li>对于指定查询某一条记录的加锁语句，<strong>如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁</strong>，如：WHERE <code>id</code> = 5 FOR UPDATE;</li><li>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE <code>id</code> BETWEEN 5 AND 7 FOR UPDATE;</li></ol><h5 id="_5-4-2-2-普通索引的间隙锁" tabindex="-1"><a class="header-anchor" href="#_5-4-2-2-普通索引的间隙锁" aria-hidden="true">#</a> 5.4.2.2 普通索引的间隙锁</h5><p><strong>数据准备</strong></p><p>创建 test1 表：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 注意：number 不是唯一值</span>\n<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;数字&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这张表上，我们有 id number 这两个字段，id 是我们的主键，我们在 number 上，建立了一个普通索引，为了方便我们后面的测试。现在我们要先加一些数据：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在进行测试之前，我们先来看看test1表中 number 索引存在的隐藏间隙：</p><ol><li>(-infinity, 1]</li><li>(1, 3]</li><li>(3, 8]</li><li>(8, 12]</li><li>(12, +infinity]</li></ol><p><strong>【案例分析】</strong></p><p>我们执行以下的事务（事务1最后提交），分别执行下面的语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">/* 开启事务1 */</span>\n<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>\n<span class="token comment">/* 查询 number = 5 的数据并加记录锁 */</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>\n<span class="token comment">/* 延迟30秒执行，防止锁释放 */</span>\n<span class="token keyword">SELECT</span> SLEEP<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span>\n\n<span class="token comment">/* 事务2插入一条 number = 0 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务3插入一条 number = 1 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 被阻塞</span>\n\n<span class="token comment">/* 事务4插入一条 number = 2 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 被阻塞</span>\n\n<span class="token comment">/* 事务5插入一条 number = 4 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 被阻塞</span>\n\n<span class="token comment">/* 事务6插入一条 number = 8 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务7插入一条 number = 9 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务8插入一条 number = 10 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 提交事务1 */</span>\n<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现有些语句可以正常执行，有些语句被阻塞了。我们再来看看我们表中的数据：</p><p><img src="'+fn+'" alt="执行之后的数据"></p><p>这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。我们再进行以下的测试，方便我们更好的理解间隙锁的区域（我们要将数据还原成原来的那样）：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">/* 开启事务1 */</span>\n<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>\n<span class="token comment">/* 查询 number = 5 的数据并加记录锁 */</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>\n<span class="token comment">/* 延迟30秒执行，防止锁释放 */</span>\n<span class="token keyword">SELECT</span> SLEEP<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">/* 事务1插入一条 id = 2， number = 1 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务2插入一条 id = 3， number = 2 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务3插入一条 id = 6， number = 8 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 事务4插入一条 id = 8， number = 8 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务5插入一条 id = 9， number = 9 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务6插入一条 id = 10， number = 12 的数据 */</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 正常执行</span>\n\n<span class="token comment">/* 事务7修改 id = 11， number = 12 的数据 */</span>\n<span class="token keyword">UPDATE</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">SET</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">WHERE</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">11</span> <span class="token operator">AND</span> <span class="token identifier"><span class="token punctuation">`</span>number<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment"># 阻塞</span>\n\n<span class="token comment">/* 提交事务1 */</span>\n<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来看看结果：</p><p><img src="'+xn+'" alt="执行后的数据"></p><p>这里有一个奇怪的现象：</p><ul><li>事务3添加 id = 6，number = 8 的数据，给阻塞了；</li><li>事务4添加 id = 8，number = 8 的数据，正常执行了。</li><li>事务7将 id = 11，number = 12 的数据修改为 id = 11， number = 5的操作，给阻塞了；</li></ul><p>这是为什么呢？我们来看看下边的图，大家就明白了。</p><p><img src="'+En+`" alt="img"></p><p>隐藏的间隙锁图</p><p>从图中可以看出，当 number 相同时，会根据主键 id 来排序，所以：</p><ol><li>事务3添加的 id = 6，number = 8，这条数据是在 （3, 8） 的区间里边，所以会被阻塞；</li><li>事务4添加的 id = 8，number = 8，这条数据则是在（8, 12）区间里边，所以不会被阻塞；</li><li>事务7的修改语句相当于在 （3, 8） 的区间里边插入一条数据，所以也被阻塞了。</li></ol><p><strong>结论</strong></p><ol><li>在普通索引列上，<strong>不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；</strong></li><li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。</li></ol><h5 id="_5-4-2-3-总结" tabindex="-1"><a class="header-anchor" href="#_5-4-2-3-总结" aria-hidden="true">#</a> 5.4.2.3 总结</h5><ol><li>记录锁、间隙锁、临键锁，都属于排它锁；</li><li>记录锁就是锁住一行记录；</li><li>间隙锁只有在事务隔离级别 RR 中才会产生；</li><li>唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁；</li><li>普通索引不管是锁住单条，还是多条记录，都会产生间隙锁；</li><li>间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其它事务在这个区域内插入、修改、删除数据，这是为了防止出现 幻读 现象；</li><li>普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序（多普通索引情况还未研究）；</li><li>事务级别是RC（读已提交）级别的话，间隙锁将会失效。</li></ol><h4 id="_5-4-3-案例分析" tabindex="-1"><a class="header-anchor" href="#_5-4-3-案例分析" aria-hidden="true">#</a> 5.4.3 案例分析</h4><p>next-key lock的加锁规则</p><p>总结的加锁规则里面，包含了两个 “ “ 原则 ” ” 、两个 “ “ 优化 ” ” 和一个 “bug” 。</p><ul><li>原则 1 ：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。</li><li>原则 2 ：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终都要回溯到主键上，在主键上也要加一把锁。</li><li>优化 1 ：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。也就是说如果InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁</li><li>优化 2 ：索引上（不一定是唯一索引）的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ul><p><strong>【案例分析前的数据准备】</strong></p><p>我们以表test作为例子，建表语句和初始化语句如下：其中id为主键索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test<span class="token punctuation">(</span>
id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
col1 <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
col2 <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
KEYc <span class="token punctuation">(</span>col1<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>

<span class="token keyword">insert</span> <span class="token keyword">into</span> test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-4-3-1-唯一索引等值查询间隙锁" tabindex="-1"><a class="header-anchor" href="#_5-4-3-1-唯一索引等值查询间隙锁" aria-hidden="true">#</a> 5.4.3.1 唯一索引等值查询间隙锁</h5><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>begin;<br>update test set col2 =col2+1where id=7;</td><td></td><td></td></tr><tr><td>.</td><td>insert into testvalues(8,8,8)(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2 =col2+1 where id=10;</td></tr></tbody></table><p>由于表 test 中没有 id=7 的记录</p><p>根据原则 1 ，加锁单位是 next-key lock ， session A 加锁范围就是 (5,10] ；</p><p>同时根据优化 2 ，这是一个等值查询 (id=7) ，而 id=10 不满足查询条件， next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)</p><h5 id="_5-4-3-2-非唯一索引等值查询锁" tabindex="-1"><a class="header-anchor" href="#_5-4-3-2-非唯一索引等值查询锁" aria-hidden="true">#</a> 5.4.3.2 非唯一索引等值查询锁</h5><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>begin; <br>select id from test where col1 = 5 lock in share mode;</td><td></td><td></td></tr><tr><td></td><td>update test col2 =col2+1where id=5;<br>(Query OK)</td><td></td></tr><tr><td></td><td></td><td>insert into test values(7,7,7)<br>(blocked)</td></tr></tbody></table><p>这里 session A 要给索引 col1 上 col1=5 的这一行加上读锁.</p><ol><li>根据原则 1，加锁单位是 next-key lock，左开右闭，5是闭上的，因此会给 (0,5]加上 next-key lock。</li><li>要注意col1是普通索引，因此仅访问 col1=5 这一条记录是不能马上停下来的(可能有col1=5的其他记录)，需要向右遍历，查到c=10 才放弃。根据第二个原则，需要对所有访问进行加锁，因此需要给区间(5,10]加上next-key lock。</li><li>但是同时这个符合优化 2 ：等值判断，向右遍历，最后一个值不满足 col1=5 这个等值条件，因此退化成间隙锁 (5,10)。</li><li>根据原则 2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，因此，在主键索引上没有添加任何锁，这解释了为什么会话B的更新语句可以执行成功。</li></ol><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住 这个例子说明，锁是加在索引上的。</p><p>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>如果你要用 lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，因为覆盖索引不会访问主键索引，不会给主键索引上加锁</p><h5 id="_5-4-3-3-主键索引范围查询锁" tabindex="-1"><a class="header-anchor" href="#_5-4-3-3-主键索引范围查询锁" aria-hidden="true">#</a> 5.4.3.3 主键索引范围查询锁</h5><p>上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">for</span> <span class="token keyword">update</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tets <span class="token keyword">where</span> id<span class="token operator">&gt;=</span><span class="token number">10</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">11</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><table><thead><tr><th>Session A</th><th>Session B</th><th>Session C</th></tr></thead><tbody><tr><td>begin; select * from test where id&gt;= 10 andid&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into testvalues(8,8,8)(Query OK) insert into testvalues(13,13,13);(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set clo2=col2+1where id=15;(blocked)</td></tr></tbody></table><p>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10] 。 根据优化 1 ，主键id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。 　　它是范围查询，范围查找就往后继续找，找到 id=15 这一行停下来，不满足条件，因此需要加 next-key lock (10,15] 。　　session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15] 。首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p><h5 id="_5-4-3-4-非唯一索引范围查询锁" tabindex="-1"><a class="header-anchor" href="#_5-4-3-4-非唯一索引范围查询锁" aria-hidden="true">#</a> 5.4.3.4 非唯一索引范围查询锁</h5><p>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><table><thead><tr><th>Session A</th><th>Session B</th><th>Session C</th></tr></thead><tbody><tr><td>begin;<br>select * from test where col1&gt;= 10 andcol1&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8)(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set clo2=col2+1where id=15;(blocked)</td></tr></tbody></table><p>在第一次用 col1=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 col1 是非唯一索引，没有优化规则，也就是 说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和(10,15] 这两个 next-key lock 。 　　这里需要扫描到 col1=15 才停止扫描，是合理的，因为 InnoDB 要扫到 col1=15，才知道不需要继续往后找了。</p><h5 id="_5-4-3-5-唯一索引范围查询锁-bug" tabindex="-1"><a class="header-anchor" href="#_5-4-3-5-唯一索引范围查询锁-bug" aria-hidden="true">#</a> 5.4.3.5 唯一索引范围查询锁 bug</h5><table><thead><tr><th>Session A</th><th>Session B</th><th>Session C</th></tr></thead><tbody><tr><td>begin;<br>select * from test where id&gt; 10 and id&lt;=15 for update;</td><td></td><td></td></tr><tr><td></td><td>update test set clo2=col2+1 where id=20;<br>(blocked)</td><td></td></tr><tr><td></td><td></td><td>insert into test values(16,16,16);<br>(blocked)</td></tr></tbody></table><p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p><p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15 ，就可以确定不用往后再找了。</p><h5 id="_5-4-3-6-非唯一索引上存在-等值-的例子" tabindex="-1"><a class="header-anchor" href="#_5-4-3-6-非唯一索引上存在-等值-的例子" aria-hidden="true">#</a> 5.4.3.6 非唯一索引上存在“等值”的例子</h5><p>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个c=10的行但是它们的主键值 id 是不同的（分别是 10 和 30 ），因此这两个c=10 的记录之间，也是有间隙的。</p><table><thead><tr><th>Session A</th><th>Session B</th><th>Session C</th></tr></thead><tbody><tr><td>begin;<br>delete from test wherecol1=10;</td><td></td><td></td></tr><tr><td>.</td><td>insert into test values(12,12,12);(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2=col2+1 where col2=15;(blocked)</td></tr></tbody></table><p>这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select ... for update 是类似的，也就是我在文章开始总结的两个 “ 原则 ” 、两个 “ 优化 ” 和一个 “bug” 。</p><p>这时， session A 在遍历的时候，先访问第一个 col1=10 的记录。同样地，根据原则 1 ，这里加的是(col1=5,id=5) 到 (col1=10,id=10) 这个 next-key lock 。</p><p>由于c是普通索引，所以继续向右查找，直到碰到 (col1=15,id=15) 这一行循环才结束。根据优化 2 ，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1=10,id=10) 到 (col1=15,id=15) 的间隙锁。</p><p><img src="`+Ln+'" alt="mysql间隙锁加锁的规则有哪些"></p><p>这个 delete 语句在索引 c 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都是虚线，表示开区间，即 (col1=5,id=5) 和 (col1=15,id=15) 这两行上都没有锁</p><h5 id="_5-3-4-7-limit-语句加锁" tabindex="-1"><a class="header-anchor" href="#_5-3-4-7-limit-语句加锁" aria-hidden="true">#</a> 5.3.4.7 limit 语句加锁</h5><p>例子 6 也有一个对照案例，场景如下所示：</p><table><thead><tr><th>Session A</th><th>Session B</th></tr></thead><tbody><tr><td>begin;<br>delete from test where col1=10 limit 2;</td><td></td></tr><tr><td></td><td>insert into test values(12,12,12);<br>(Query OK)</td></tr></tbody></table><p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样。</p><p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（ col1=5,id=5)到（ col1=10,id=30) 这个前开后闭区间，如下图所示：</p><p><img src="'+Sn+`" alt="mysql间隙锁加锁的规则有哪些"></p><p>这个例子对我们实践的指导意义就是， 在删除数据的时候尽量加 limit 。 　　这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p><h5 id="_5-4-3-8-一个死锁的例子" tabindex="-1"><a class="header-anchor" href="#_5-4-3-8-一个死锁的例子" aria-hidden="true">#</a> 5.4.3.8 一个死锁的例子</h5><table><thead><tr><th>Session A</th><th>Session B</th></tr></thead><tbody><tr><td>begin;<br>select id from test where col1=10 lockin share mode;</td><td></td></tr><tr><td></td><td>update test set col2=col2+1 where c=10;(blocked)</td></tr><tr><td>insert into test values(8,8,8);</td><td></td></tr><tr><td></td><td>ERROR 1213(40001):Deadlock found when trying togetlock;try restarting transaction</td></tr></tbody></table><p>session A 启动事务后执行查询语句加 lock in share mode ，在索引 col1 上加了 next-keylock(5,10] 和间隙锁 (10,15) （索引向右遍历退化为间隙锁）；</p><p>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10]，进入锁等待；实际上分成了两步，先是加(5,10) 的间隙锁，加锁成功；然后加 col1=10 的行锁，因为sessionA上已经给这行加上了读锁，此时申请死锁时会被阻塞</p><p>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚</p><h5 id="_5-4-3-9-order-by索引排序的间隙锁1" tabindex="-1"><a class="header-anchor" href="#_5-4-3-9-order-by索引排序的间隙锁1" aria-hidden="true">#</a> 5.4.3.9 order by索引排序的间隙锁1</h5><p>如下面一条语句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test <span class="token keyword">where</span> id<span class="token operator">&gt;</span><span class="token number">9</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">12</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">desc</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下图为这个表的索引id的示意图。</p><p><img src="`+qn+'" alt="请添加图片描述"></p><ol><li>首先这个查询语句的语义是 order by id desc，要拿到满足条件的所有行，优化器必须先找到 “第一个 id&lt;12 的值”。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id=12 的这个值，只是最终没找到，但找到了 (10,15) 这个间隙。（ id=15 不满足条件，所以 next-key lock 退化为了间隙锁 (10,15) 。</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，又因为区间是左开右闭的，所以会加一个next-key lock (0,5] 。 也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是 “ 等值查询 ” 的方法</li></ol><h5 id="_5-4-3-10-order-by索引排序的间隙锁2" tabindex="-1"><a class="header-anchor" href="#_5-4-3-10-order-by索引排序的间隙锁2" aria-hidden="true">#</a> 5.4.3.10 order by索引排序的间隙锁2</h5><table><thead><tr><th>Session A</th><th>Session B</th></tr></thead><tbody><tr><td>begin;<br>select * from test where col1&gt;=15 and c&lt;=20 order by col1 desc lock in share mode;</td><td></td></tr><tr><td></td><td>insert into testvalues(6,6,6);<br>(blocked)</td></tr></tbody></table><p>1.由于是 order by col1 desc ，第一个要定位的是索引 col1 上 “ 最右边的 ”col1=20 的行。这是一个非唯一索引的等值查询：左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1=25不满足条件，退化为间隙锁 所以会加上间隙锁(20,25) 和 next-key lock (15,20]</p><p>2.在索引 col1 上向左遍历，要扫描到 col1=10 才停下来。同时又因为左开右闭区间，所以 next-keylock 会加到(5,10] ，这正是阻塞session B 的 insert 语句的原因。</p><p>3.在扫描过程中， col1=20 、 col1=15 、 col1=10 这三行都存在值，由于是 select * ，所以会在主键id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：</p><ul><li>索引 col1 上 (5, 25) ；</li><li>主键索引上 id=15 、 20 两个行锁。</li></ul><h5 id="_5-4-3-11-update修改数据的例子-先插入后删除" tabindex="-1"><a class="header-anchor" href="#_5-4-3-11-update修改数据的例子-先插入后删除" aria-hidden="true">#</a> 5.4.3.11 update修改数据的例子-先插入后删除</h5><table><thead><tr><th>Session A</th><th>Session B</th></tr></thead><tbody><tr><td>begin;<br>select col1 from test where col1&gt;5 lock in share mode;</td><td></td></tr><tr><td></td><td>update test set col1=1 where col1=5<br>(Query oK)<br>update test set col1=5 where col1=1;<br>(blocked)</td></tr></tbody></table><p>注意：根据 col1&gt;5 查到的第一个记录是 col1=10 ，因此不会加 (0,5] 这个 next-key lock 。 session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。 之后 session B 的第一个 update 语句，要把 col1=5 改成 col1=1 ，你可以理解为两步：</p><ol><li>插入 (col1=1, id=5) 这个记录；</li><li>删除 (col1=5, id=5) 这个记录。</li></ol><p>通过这个操作， session A 的加锁范围变成了图 7 所示的样子： <img src="'+Tn+'" alt="请添加图片描述"></p><p>好，接下来 session B 要执行 update t set col1 = 5 where col1 = 1 这个语句了，一样地可以拆成两步： 3. 插入 (col1=5, id=5) 这个记录； 4. 删除 (col1=1, id=5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了</p><h2 id="六、进阶篇-innodb引擎" tabindex="-1"><a class="header-anchor" href="#六、进阶篇-innodb引擎" aria-hidden="true">#</a> 六、进阶篇-InnoDB引擎</h2><h3 id="_6-1-逻辑存储结构" tabindex="-1"><a class="header-anchor" href="#_6-1-逻辑存储结构" aria-hidden="true">#</a> 6.1 逻辑存储结构</h3><p>InnoDB的逻辑存储结构如下图所示:</p><img src="'+In+'" alt="image-20220427080239097" style="zoom:50%;"><p>**表空间 ：**表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>**段：**分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p>**区：**表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><p>**页：**是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p>**行：**InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段：</p><ul><li><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</p></li><li><p>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p></li></ul><h3 id="_6-2-架构" tabindex="-1"><a class="header-anchor" href="#_6-2-架构" aria-hidden="true">#</a> 6.2 架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><img src="'+Dn+`" alt="image-20220427080814476" style="zoom:50%;"><h4 id="_6-2-1-内存结构" tabindex="-1"><a class="header-anchor" href="#_6-2-1-内存结构" aria-hidden="true">#</a> 6.2.1 内存结构</h4><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p><h5 id="_6-2-1-1-buffer-pool" tabindex="-1"><a class="header-anchor" href="#_6-2-1-1-buffer-pool" aria-hidden="true">#</a> 6.2.1.1 Buffer Pool</h5><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li><p>free page：空闲page，未被使用。</p></li><li><p>clean page：被使用page，数据没有被修改过。</p></li><li><p>dirty page：脏页，被使用page，数据被修改过，内存中的数据与磁盘的数据产生了不一致。</p></li></ul><p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> show variables like &#39;innodb_buffer_pool_size&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Rn+'" alt="image-20220427081105843" style="zoom:50%;"><h5 id="_6-2-1-2-change-buffer" tabindex="-1"><a class="header-anchor" href="#_6-2-1-2-change-buffer" aria-hidden="true">#</a> 6.2.1.2 Change Buffer</h5><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义是什么呢?</p><p>先来看一幅图，这个是二级索引的结构图：</p><img src="'+An+'" alt="image-20220427081201997" style="zoom:50%;"><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><h5 id="_6-2-1-3-adaptive-hash-index" tabindex="-1"><a class="header-anchor" href="#_6-2-1-3-adaptive-hash-index" aria-hidden="true">#</a> 6.2.1.3 Adaptive Hash Index</h5><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</strong></p><p>参数： adaptive_hash_index</p><h5 id="_6-2-1-4-log-buffer" tabindex="-1"><a class="header-anchor" href="#_6-2-1-4-log-buffer" aria-hidden="true">#</a> 6.2.1.4 Log Buffer</h5><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p><p>参数:</p><p>innodb_log_buffer_size：缓冲区大小</p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><ul><li><p>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p></li><li><p>0: 每秒将日志写入并刷新到磁盘一次。</p></li><li><p>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p></li></ul><img src="'+Bn+'" alt="image-20220427081356587" style="zoom:50%;"><h4 id="_6-2-2-磁盘结构" tabindex="-1"><a class="header-anchor" href="#_6-2-2-磁盘结构" aria-hidden="true">#</a> 6.2.2 磁盘结构</h4><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：</p><img src="'+Nn+'" alt="image-20220427081505911" style="zoom:50%;"><h5 id="_6-2-2-1-system-tablespace" tabindex="-1"><a class="header-anchor" href="#_6-2-2-1-system-tablespace" aria-hidden="true">#</a> 6.2.2.1 System Tablespace</h5><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><p>参数：innodb_data_file_path</p><img src="'+On+'" alt="image-20220427081601090" style="zoom:50%;"><p>系统表空间，默认的文件名叫 ibdata1。</p><h5 id="_6-2-2-2-file-per-table-tablespaces" tabindex="-1"><a class="header-anchor" href="#_6-2-2-2-file-per-table-tablespaces" aria-hidden="true">#</a> 6.2.2.2 File-Per-Table Tablespaces</h5><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：innodb_file_per_table ，该参数默认开启。</p><img src="'+Mn+'" alt="image-20220427081942107" style="zoom:50%;"><p>那也就是说，我们每创建一个表，都会产生一个表空间文件，如图：</p><img src="'+Cn+`" alt="image-20220427082018336" style="zoom:50%;"><h5 id="_6-2-2-3-general-tablespaces" tabindex="-1"><a class="header-anchor" href="#_6-2-2-3-general-tablespaces" aria-hidden="true">#</a> 6.2.2.3 General Tablespaces</h5><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>A. 创建表空间</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Un+`" alt="image-20220427082223707" style="zoom:50%;"><p>B. 创建表时指定表空间</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE xxx ... TABLESPACE ts_name;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+Qn+'" alt="image-20220427082337252" style="zoom:50%;"><h5 id="_6-2-2-4-undo-tablespaces" tabindex="-1"><a class="header-anchor" href="#_6-2-2-4-undo-tablespaces" aria-hidden="true">#</a> 6.2.2.4 Undo Tablespaces</h5><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p><p>这里要需要说明一下，在MySQL5.6.3之前的版本中，这个<code>undo tablespace</code>是和<code>system tablespace</code>系统表空间存放在一起的，也就是没有单独的<code>undo log</code>文件，直接存放在<code>ibdata1</code>文件里边，在<code>MySQL5.6.3</code>之后的版本中，MySQL支持将undo log tablespace单独剥离出来，但这个特性依然很鸡肋：</p><ol><li>要在安装数据库的时候，就指定好独立undo tablespace，在安装完成后不可更改；</li><li>undo tablespace的space id必须从1开始，无法增加或者删除undo tablespace；</li></ol><p>到了<code>MySQL5.7</code>版本，终于引入期待已久的功能：即在线truncate undo tablespace（解决了第一个鸡肋点，可以在安装数据库之后更改undo tablespace）</p><p>在<code>MySQL8.0</code>中，InnoDB再进一步，对undo log做了进一步的改进：</p><ol><li><strong>从8.0.3版本开始，默认undo tablespace的个数从0调整为2</strong>，也就是在8.0版本中，独立undo tablespace被默认打开。修改该参数为0会报warning并在未来不再支持；</li><li>无需从space_id 1开始创建undo tablespace，这样解决了In-place upgrade或者物理恢复到一个打开了Undo tablespace的实例所产生的space id冲突。不过依然要求undo tablespace的space id是连续分配的；</li></ol><h5 id="_6-2-2-5-temporary-tablespaces" tabindex="-1"><a class="header-anchor" href="#_6-2-2-5-temporary-tablespaces" aria-hidden="true">#</a> 6.2.2.5 Temporary Tablespaces</h5><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><h5 id="_6-2-2-6-doublewrite-buffer-files" tabindex="-1"><a class="header-anchor" href="#_6-2-2-6-doublewrite-buffer-files" aria-hidden="true">#</a> 6.2.2.6 Doublewrite Buffer Files</h5><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><img src="'+zn+'" alt="image-20220427082511506" style="zoom:50%;"><h5 id="_6-2-2-7-redo-log" tabindex="-1"><a class="header-anchor" href="#_6-2-2-7-redo-log" aria-hidden="true">#</a> 6.2.2.7 Redo Log</h5><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：</p><img src="'+Pn+'" alt="image-20220427082652621" style="zoom:50%;"><h4 id="_6-2-3-后台线程" tabindex="-1"><a class="header-anchor" href="#_6-2-3-后台线程" aria-hidden="true">#</a> 6.2.3 后台线程</h4><p>前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。</p><img src="'+Vn+'" alt="image-20220427082857707" style="zoom:50%;"><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</p><p>1). Master Thread</p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p>2). IO Thread</p><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IOThread主要负责这些IO请求的回调。</p><p>TODO</p><h3 id="_6-3-事务原理" tabindex="-1"><a class="header-anchor" href="#_6-3-事务原理" aria-hidden="true">#</a> 6.3 事务原理</h3><h4 id="_6-3-1-事务基础" tabindex="-1"><a class="header-anchor" href="#_6-3-1-事务基础" aria-hidden="true">#</a> 6.3.1 事务基础</h4><p>1). 事务</p><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>2). 特性</p><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul><p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><img src="'+Hn+'" alt="image-20220427083211638" style="zoom:50%;"><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，加上MVCC来保证的。</p><img src="'+Gn+'" alt="image-20220427083250837" style="zoom:50%;"><p>我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</p><h4 id="_6-3-2-redo-log" tabindex="-1"><a class="header-anchor" href="#_6-3-2-redo-log" aria-hidden="true">#</a> 6.3.2 redo log</h4><h5 id="_6-3-2-1-redo-log-概述" tabindex="-1"><a class="header-anchor" href="#_6-3-2-1-redo-log-概述" aria-hidden="true">#</a> 6.3.2.1 redo log 概述</h5><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>如果没有redo log，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><img src="'+Wn+'" alt="image-20220427083538516" style="zoom:50%;"><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redo log如何解决这个问题。</p><img src="'+Fn+'" alt="image-20220427083611859" style="zoom:50%;"><p>有了redo log之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。而如果脏页成功刷写到磁盘或者涉及到的数据已经盘，此时redo log日志文件就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的。</p><p>那为什么每一次提交事务，要刷新redo log到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h5 id="_6-3-2-2-redo-log日志刷盘策略" tabindex="-1"><a class="header-anchor" href="#_6-3-2-2-redo-log日志刷盘策略" aria-hidden="true">#</a> 6.3.2.2 redo log日志刷盘策略</h5><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 一 定的频率刷到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><p><img src="'+Kn+`" alt="请添加图片描述"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 文件系统缓存（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。 针对这种情况，InnoDB给出innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步）</li><li>设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</li><li>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;innodb_flush_log_at_trx_commit&#39;</span><span class="token punctuation">;</span>
<span class="token comment">/*
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| innodb_flush_log_at_trx_commit | 1     |
+--------------------------------+-------+
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，InnoDB存储引擎有一个后台线程，每隔1秒，就会把 redo log buffer 中的内容写到文件系统缓存( page cache ) ，然后调用刷盘操作。</p><p><img src="`+Xn+'" alt="请添加图片描述"></p><p>也就是说，一个没有提交事务的redo log 记录，也可能会刷盘。因为在事务执行过程redo log记录是会写入redo log buffer中，这些redo log记录会被后台线程刷盘。</p><p><img src="'+Yn+'" alt="请添加图片描述"></p><p>除了后台线程每秒1次的轮询操作，还有一种情况，当redoa log buffer占用的空间即将达到innodb_log_buffer_size(这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p><h5 id="_6-3-2-3-redo-log不同刷盘策略演示" tabindex="-1"><a class="header-anchor" href="#_6-3-2-3-redo-log不同刷盘策略演示" aria-hidden="true">#</a> 6.3.2.3 redo log不同刷盘策略演示</h5><p><strong>innodb_flush_log_at_trx_commit=1</strong></p><p><img src="'+Jn+'" alt="请添加图片描述"></p><blockquote><p>小结: innodb_flush_log_at_trx_commit=1 为1时，只要事务提交成功,redo log记录就一定在硬盘里，不会有任何数据丢失。 如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失，但是效率最差的。 建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些</p></blockquote><p><strong>innodb_flush_log_at_trx_commit=2</strong></p><p><img src="'+jn+'" alt="请添加图片描述"></p><p><strong>innodb_flush_log_at_trx_commit=0</strong></p><p><img src="'+Zn+'" alt="请添加图片描述"></p><blockquote><p>小结: innodb_flush_log_at_trx_commit=o 为0时,master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。( master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性) 数值0话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，也无法保证D。</p></blockquote><blockquote><p>总结：虽然用户可以通过设置参数innodb_flush_log_at_trx_commit为0或2来提高事务提交的性能，但需清楚，这种设置方法丧失了事务的ACID特性。</p><p>0 最快，2其次，性能相对1提高了接近50%。</p></blockquote><h5 id="_6-3-2-4-redo-log-buffer写流程" tabindex="-1"><a class="header-anchor" href="#_6-3-2-4-redo-log-buffer写流程" aria-hidden="true">#</a> 6.3.2.4 redo log buffer写流程</h5><p>MySQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Nini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，画个图表示它们的关系就是这样:</p><p><img src="'+$n+'" alt="请添加图片描述"></p><p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处，所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到 log buffer中的哪个位置，如图所示:</p><p><img src="'+sa+'" alt="请添加图片描述"></p><p>一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log bulffer中。假设有两个名为T1、T2的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下; 事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2 事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2</p><p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况:</p><p><img src="'+na+'" alt="请添加图片描述"></p><p>不同的事务可能是并发执行的，所以T1、T2之间的mtr可能是交替执行的。每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图(为了美观，把一个mtr中产生的所有的redo日志当作一个整体来画):</p><p><img src="'+aa+'" alt="请添加图片描述"></p><p>有的mtr产生的redo日志量非常大，比如1mtr_t1_2产生的redo日志占用空间比较大，占用了3个block来存储。</p><h5 id="_6-3-2-5-redo-log-block的结构图" tabindex="-1"><a class="header-anchor" href="#_6-3-2-5-redo-log-block的结构图" aria-hidden="true">#</a> 6.3.2.5 redo log block的结构图</h5><p>一个redo log block是由日志头、日志体、日志尾组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据就是512-12-8=492字节。</p><blockquote><p>为什么一个block设计成512字节? 这个和磁盘的扇区有关，机械磁盘默认的扇区就是512字节，如果要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这时就要涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，而扇区B写入失败，那么就会出现非原子性的写入，而如果每次只写入和扇区的大小一样的512字节,那么每次的写入都是原子性的</p></blockquote><p><img src="'+ea+'" alt="请添加图片描述"></p><p>真正的redo日志都是存储到占用496字节大小的log block body中，图中的log block header和log block trailer存储的是一些管理信息。我们来看看这些所谓的管理信息都有什么</p><p><img src="'+ta+`" alt="请添加图片描述"></p><p><strong>log block header的属性分别如下:</strong></p><ul><li>LOG_BLOCK_HDR_NO : log buffer是由log block组成，在内部log buffer就好似一个数组，因此LOG_BLOCK_HDR_NO用来标记这个数组中的位置。其是递增并且循环使用的，占用4个字节，但是由于第—位用来判新是否是flush bit，所以最大的值为2G。</li><li>LOG_BLOCK_HDR_DATA_LEN∶表示block中已经使用了多少字节，初始值为12(因为log block body从第12个字节处开始)。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果log block body已经被全部写满,那么本属性的值被设置为512</li><li>LOG_BLOCK_FIRST_REC_GROUP :一条redo日志也可以称之为一条redo日志记录（redo log record)，一个mtr会生产多条redo日志记录，这些redo日志记录被称之为一个redo日志记录组(redo log record group)。LOG_BLOCK_FIRST_REC_GROUP就代表该block中第一个mtr生成的redo日志记录组的偏移量(其实也就是这个block里第一个mtr生成的第一条redo日志的偏移量)。如果该值的大小和LOG_BLOCK_HDR_DATA_LEN相同，则表示当前log block不包含新的日志。</li></ul><p>LOG_BLOCK_CHECKPOINT_NO:占用4字节，表示该log block最后被写入时的checkpoint。 log block trailer中属性的意思如下:</p><ul><li>LOG_BLOCK_CHECKSUN:表示block的校验值，用于正确性校验（其值和LOG_BLOCK_HDR_NO相同)，暂时不关心它。</li></ul><h4 id="_6-3-3-undo-log" tabindex="-1"><a class="header-anchor" href="#_6-3-3-undo-log" aria-hidden="true">#</a> 6.3.3 undo log</h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo log</p><h5 id="_6-3-3-1-如何理解undo日志" tabindex="-1"><a class="header-anchor" href="#_6-3-3-1-如何理解undo日志" aria-hidden="true">#</a> 6.3.3.1 如何理解Undo日志</h5><p>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如 服务器本身的错误 ， 操作系统错误 ，甚至是突然 断电 导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前事务的执行。</li></ul><p>以上情况出现，需要把数据改回原先的样子，这个过程称之为回滚 ，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求</p><p>每当我们要对一条记录做改动时(这里的改动可以指INSERT、DELETE、UPDATE ），都需要&quot;留一手&quot;—&gt;把回滚时所需的东西记下来。比如:</p><ul><li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删除就好了（对于每个INSERT，InnoDB存储引擎会完成一个DELETE)</li><li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE，InnoDB存储引擎会执行一个INSERT)</li><li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul><p>MySQL把这些为了回滚而记录的这些内容称之为撒销日志或者回滚日志(即undo log)。注意，由于查询操作( SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志</p><p>此外，undo log 会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护</p><h5 id="_6-3-3-2-undo-log的作用" tabindex="-1"><a class="header-anchor" href="#_6-3-3-2-undo-log的作用" aria-hidden="true">#</a> 6.3.3.2 undo log的作用</h5><p>作用1：回滚数据</p><p>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p><p>作用2：MVCC</p><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取</p><h5 id="_6-3-3-2-undo-log的存储结构" tabindex="-1"><a class="header-anchor" href="#_6-3-3-2-undo-log的存储结构" aria-hidden="true">#</a> 6.3.3.2 undo log的存储结构</h5><p><strong>【回滚段与undo页】</strong></p><p>InnoDB对undo log的管理采用段的方式，也就是回滚段（rollback segment） 。每个回滚段记录了1024个 undo log segment，而在每个undo log segment段中进行undo页的申请。</p><ul><li>在 InnoDB1.1版本之前(不包括1.1版本)，只有一个rollback segment，因此支持同时在线的事务限制为1024。虽然对绝大多数的应用来说都已经够用。</li><li>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到 了 128*1024</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;innodb_undo_logs&#39;</span><span class="token punctuation">;</span>
<span class="token comment">/*
+------------------+-------+
| Variable_name | Value |
+------------------+-------+
| innodb_undo_logs | 128 |
+------------------+-------+
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然InnoDB1.1版本支持了128个rollback segment，但是这些rollback segment都存储于共享表空间ibdata中。从InnoDB1.2版本开始，可通过参数对rollback segment做进一步的设置。这些参数包括:</p><ul><li>innodb_undo_directory:设置rollback segment文件所在的路径。这意味若rollback segment可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为“.”，表示当前InnoDB存储引擎的目录</li><li>innodb_undo_logs:设置rollback segment的个数，默认值为128。在InnoDB1.2版本中，该参数用来替换之前版本的参数innodb_rollback_segments。</li><li>innodb_undo_tablespaces:设置构成rollback segment文件的数目，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件</li></ul><p>undo log相关参数一般很少改动。</p><p><strong>【undo页的重用】</strong></p><p>当开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们知道mysql默认一页的大小是16k。为每一个事务分配一个页，是非常浪费的（除非你的事务非常长)，假设你的应用的TPS(每秒处理的事务数目)为1000，那么1s就需要1000个页大概需要16M的存储，1分钟大概需要1G的存储。如果照这样下去除非MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。</p><p>于是undo页就被设计的可以重用了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3 /4，如果小于3/4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是离散的，所以清理对应的磁盘空间时，效率不高。</p><p><strong>【回滚段与事务】</strong></p><ol><li>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</li><li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</li><li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用</li><li>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间</li><li>当事务提交时， lnnoDB存储引擎会做以下两件事情： <ol><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ol></li></ol><p><strong>【回滚段中的数据分类】</strong></p><ul><li><p>未提交的回滚数据(uncommitted undo information) 该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖</p></li><li><p>已经提交但未过期的回滚数据(committed undo information) 该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响</p></li><li><p>事务已经提交并过期的数据(expired undo information) 事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖&quot;事务已经提交并过期的数据&quot;</p></li></ul><p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断</p><h5 id="_6-3-3-3-undo-log的类型" tabindex="-1"><a class="header-anchor" href="#_6-3-3-3-undo-log的类型" aria-hidden="true">#</a> 6.3.3.3 undo log的类型</h5><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><p>insert undo log insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作</p></li><li><p>update undo log update undo log记录的是对delete和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除</p></li></ul><h5 id="_6-3-3-4-undo-log的生命周期" tabindex="-1"><a class="header-anchor" href="#_6-3-3-4-undo-log的生命周期" aria-hidden="true">#</a> 6.3.3.4 undo log的生命周期</h5><p><strong>【简要生成过程】</strong></p><p>以下是undo+redo事务的简化i过程</p><p>假设有2个数值，分别为A=1和B=2，然后将A修改为3,B修改为4</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code> <span class="token operator">-</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span>
<span class="token number">2</span>．记录A<span class="token operator">=</span><span class="token number">1</span>到undo log<span class="token punctuation">;</span>
 <span class="token operator">-</span> <span class="token keyword">update</span> A <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token number">4.</span>记录A<span class="token operator">=</span><span class="token number">3</span> 到redo log<span class="token punctuation">;</span>
<span class="token number">5</span>．记录B<span class="token operator">=</span><span class="token number">2</span>到undo log<span class="token punctuation">;</span>
 <span class="token operator">-</span> <span class="token keyword">update</span> B <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token number">7.</span>记录B <span class="token operator">=</span><span class="token number">4</span>到redo log<span class="token punctuation">;</span>
<span class="token number">8</span>．将redo log刷新到磁盘
 <span class="token operator">-</span> <span class="token keyword">commit</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响</li><li>如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化</li><li>若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘</li></ul><p>只有Buffer Pool的流程：</p><p><img src="`+pa+'" alt="请添加图片描述"></p><p>有了Redo Log和Undo Log之后：</p><p><img src="'+oa+'" alt="请添加图片描述"></p><p>在更新Buffer Pool中的数据之前，需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，就可以通过Undo Log来回滚到事务开始前。</p><p><strong>【详细生成过程】</strong></p><p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p><ul><li>DB_ROW_ID:如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键</li><li>DB_TRX_ID:每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中</li><li>DB_ROLL_PTR;回滚指针，本质上就是指句undo log的指针 <img src="'+la+`" alt="请添加图片描述"></li></ul><p>当我们执行INSERT时：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&quot;tom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…。那么在进行rollback的时候，通过主键直接把对应的数据删除即可</p><p><img src="`+ia+`" alt="请添加图片描述"></p><p>当我们执行UPDATE时：</p><p>对于更新的操作会产生update undo log，并且会分更新主键的和不更新主键的，假设现在执行:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> name<span class="token operator">=</span> <span class="token string">&quot;Sun&quot;</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+ca+`" alt="请添加图片描述"></p><p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log (undo no=0) .假设现在执行:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> <span class="token keyword">user</span> <span class="token keyword">SET</span> id<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+da+'" alt="请添加图片描述"></p><p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增</p><p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log,undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到原始数据</p><p><strong>【undo log是如何回滚的】</strong></p><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom</li><li>通过undo no=0的日志把id=1的数据删除</li></ol><p><strong>【undo log的删除】</strong></p><ul><li><p>针对于insert undo log 因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删 除，不需要进行purge操作。</p></li><li><p>针对于update undo log 该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p></li></ul><blockquote><p>补充:purge线程两个主要作用是:清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种&quot;假删除&quot;;只是做了个标记，真正的删除工作需要后台purge线程去完成</p></blockquote><h5 id="_6-3-3-5-小结" tabindex="-1"><a class="header-anchor" href="#_6-3-3-5-小结" aria-hidden="true">#</a> 6.3.3.5 小结</h5><p><img src="'+ra+'" alt="请添加图片描述"></p><ul><li>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子</li><li>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程</li></ul><h3 id="_6-4-mvcc" tabindex="-1"><a class="header-anchor" href="#_6-4-mvcc" aria-hidden="true">#</a> 6.4 MVCC</h3><h4 id="_6-4-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_6-4-1-基本概念" aria-hidden="true">#</a> 6.4.1 基本概念</h4><h5 id="_6-4-1-1-当前读" tabindex="-1"><a class="header-anchor" href="#_6-4-1-1-当前读" aria-hidden="true">#</a> 6.4.1.1 当前读</h5><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ... for update、update、insert、delete(排他锁)都是一种当前读。</p><p>测试：</p><img src="'+ua+'" alt="image-20220427084241423" style="zoom:50%;"><p>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p><h5 id="_6-4-1-2-快照读" tabindex="-1"><a class="header-anchor" href="#_6-4-1-2-快照读" aria-hidden="true">#</a> 6.4.1.2 快照读</h5><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><p>测试:</p><img src="'+ka+'" alt="image-20220427084502280" style="zoom:50%;"><p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><h5 id="_6-4-1-3-mvcc" tabindex="-1"><a class="header-anchor" href="#_6-4-1-3-mvcc" aria-hidden="true">#</a> 6.4.1.3 MVCC</h5><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从而来介绍一下MVCC的原理。</p><h4 id="_6-4-2-隐藏字段" tabindex="-1"><a class="header-anchor" href="#_6-4-2-隐藏字段" aria-hidden="true">#</a> 6.4.2 隐藏字段</h4><h5 id="_6-4-2-1-介绍" tabindex="-1"><a class="header-anchor" href="#_6-4-2-1-介绍" aria-hidden="true">#</a> 6.4.2.1 介绍</h5><img src="'+ma+`" alt="image-20220427084719578" style="zoom:50%;"><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><table><thead><tr><th><strong>隐藏字段</strong></th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p><h5 id="_6-4-2-2-测试" tabindex="-1"><a class="header-anchor" href="#_6-4-2-2-测试" aria-hidden="true">#</a> 6.4.2.2 测试</h5><p>查看有主键的表 stu</p><p>进入服务器中的 <code>/var/lib/mysql/itcast/</code> , 查看stu的表结构信息, 通过如下指令:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ibd2sdi stu.ibd 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID隐藏字段。</p><img src="`+ga+'" alt="image-20220427090457189" style="zoom:50%;"><img src="'+ba+`" alt="image-20220427090527928" style="zoom:50%;"><p>查看没有主键的表 employee</p><p>建表语句：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>create table employee (id int , name varchar(10));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ibd2sdi employee.ibd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有指定主键的。</p><h4 id="_6-4-3-undo-log" tabindex="-1"><a class="header-anchor" href="#_6-4-3-undo-log" aria-hidden="true">#</a> 6.4.3 undo log</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><h5 id="_6-4-3-1-版本链" tabindex="-1"><a class="header-anchor" href="#_6-4-3-1-版本链" aria-hidden="true">#</a> 6.4.3.1 版本链</h5><p>有一张表原始数据为：</p><img src="`+va+'" alt="image-20220427090814049" style="zoom:50%;"><blockquote><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</p><p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p></blockquote><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步</p><img src="'+ha+'" alt="image-20220427090918139" style="zoom:50%;"><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><img src="'+_a+'" alt="image-20220427091020709" style="zoom:50%;"><p>B.第二步</p><img src="'+ya+'" alt="image-20220427091058108" style="zoom:50%;"><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><img src="'+wa+'" alt="image-20220427091138980" style="zoom:50%;"><p>C. 第三步</p><img src="'+fa+'" alt="image-20220427091218848" style="zoom:50%;"><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><img src="'+xa+'" alt="image-20220427091253293" style="zoom:50%;"><blockquote><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条</p><p>记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote><h4 id="_6-4-4-readview" tabindex="-1"><a class="header-anchor" href="#_6-4-4-readview" aria-hidden="true">#</a> 6.4.4 readview</h4><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undo log版本链对应事务ID。</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id ==creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事务更改的。</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了。</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在ReadView生成后才开启。</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果trx_id不在m_ids中，是可以访问该版本的</td><td>成立，说明数据已经提交。</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</p></li><li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul><p><strong>【ReadView的规则】</strong></p><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问</li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。 <ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h4 id="_6-4-5-原理分析" tabindex="-1"><a class="header-anchor" href="#_6-4-5-原理分析" aria-hidden="true">#</a> 6.4.5 原理分析</h4><h5 id="_6-4-5-1-rc隔离级别" tabindex="-1"><a class="header-anchor" href="#_6-4-5-1-rc隔离级别" aria-hidden="true">#</a> 6.4.5.1 RC隔离级别</h5><p>RC隔离级别下，在事务中每一次执行快照读时都会生成ReadView。</p><p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p><img src="'+Ea+'" alt="image-20220427093322038" style="zoom:50%;"><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><p>先来看第一次快照读具体的读取过程：</p><img src="'+a+'" alt="image-20220427093417945" style="zoom:50%;"><img src="'+e+'" alt="image-20220427093449949" style="zoom:50%;"><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配，在遇到第一条复合的记录后，就直接返回了</p><p>这里返回的是0x00002对应的记录</p><blockquote><p>这么多判断就是为了判断一件事：</p><p><strong>当前记录对应的事物id是否是活跃的事物id，如果活跃，就不可以访问，反之，可以访问</strong></p></blockquote><p>B. 再来看第二次快照读具体的读取过程:</p><img src="'+a+'" alt="image-20220427093417945" style="zoom:50%;"><img src="'+e+'" alt="image-20220427093449949" style="zoom:50%;"><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配，在遇到第一条复合的记录后，就直接返回了</p><p>这里返回的是0x00003对应的记录</p><h5 id="_6-4-5-2-rr隔离级别" tabindex="-1"><a class="header-anchor" href="#_6-4-5-2-rr隔离级别" aria-hidden="true">#</a> 6.4.5.2 RR隔离级别</h5><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><img src="'+La+'" alt="image-20220427095606457" style="zoom:50%;"><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><img src="'+Sa+`" alt="image-20220427095709975" style="zoom:50%;"><h2 id="七、进阶篇-mysql管理" tabindex="-1"><a class="header-anchor" href="#七、进阶篇-mysql管理" aria-hidden="true">#</a> 七、进阶篇-MySQL管理</h2><h3 id="系统数据库" tabindex="-1"><a class="header-anchor" href="#系统数据库" aria-hidden="true">#</a> 系统数据库</h3><p>Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便 DBA 和开发人员利用 performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h3 id="常用工具" tabindex="-1"><a class="header-anchor" href="#常用工具" aria-hidden="true">#</a> 常用工具</h3><h4 id="nysql" tabindex="-1"><a class="header-anchor" href="#nysql" aria-hidden="true">#</a> nysql</h4><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法 ：
	mysql [options] [database] 
选项 ：
	-u, --user=name #指定用户名 
	-p, --password[=name] #指定密码 
	-h, --host=name #指定服务器IP或域名 
	-P, --port=port #指定连接端口 
	-e, --execute=name #执行SQL语句并退出
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><h4 id="mysqladmin" tabindex="-1"><a class="header-anchor" href="#mysqladmin" aria-hidden="true">#</a> mysqladmin</h4><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>通过帮助文档查看选项： 
mysqladmin --help
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+qa+`" alt="image-20220427101337195" style="zoom:50%;"><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法:
	mysqladmin [options] command ... 

选项:
	-u, --user=name #指定用户名 
	-p, --password[=name] #指定密码 
	-h, --host=name #指定服务器IP或域名 
	-P, --port=port #指定连接端口 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqlbinlog" tabindex="-1"><a class="header-anchor" href="#mysqlbinlog" aria-hidden="true">#</a> mysqlbinlog</h4><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法 ：
	mysqlbinlog [options] log-files1 log-files2 ... 
选项 ：
	-d, --database=name 指定数据库名称，只列出指定的数据库相关操作。 
	-o, --offset=# 忽略掉日志中的前n行命令。 
	-r,--result-file=name 将输出的文本格式日志输出到指定文件。 
	-s, --short-form 显示简单格式， 省略掉一些信息。 
	--start-datatime=date1 --stop-datetime=date2 指定日期间隔内的所有日志。 
	--start-position=pos1 --stop-position=pos2 指定位置间隔内的所有日志。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqlshow" tabindex="-1"><a class="header-anchor" href="#mysqlshow" aria-hidden="true">#</a> mysqlshow</h4><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>语法 ：
	mysqlshow <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>db_name <span class="token punctuation">[</span>table_name <span class="token punctuation">[</span>col_name<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> 

选项 ：
	<span class="token comment">--count 显示数据库及表的统计信息（数据库，表 均可以不指定） </span>
	<span class="token operator">-</span>i 显示指定数据库或者指定表的状态信息 

示例：
	<span class="token comment">#查询test库中每个表中的字段书，及行数 </span>
	mysqlshow <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test <span class="token comment">--count </span>
	
	<span class="token comment">#查询test库中book表的详细情况 </span>
	mysqlshow <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test book <span class="token comment">--count</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqldump" tabindex="-1"><a class="header-anchor" href="#mysqldump" aria-hidden="true">#</a> mysqldump</h4><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>语法 ：
	mysqldump [options] db_name [tables] 
	mysqldump [options] --database/-B db1 [db2 db3...] 
	mysqldump [options] --all-databases/-A 
	
连接选项 ： 
	-u, --user=name 指定用户名 
	-p, --password[=name] 指定密码 
	-h, --host=name 指定服务器ip或域名 
	-P, --port=# 指定连接端口 

输出选项： 
	--add-drop-database 在每个数据库创建语句前加上 drop database 语句 
	--add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不 开启 (--skip-add-drop-table) 
	-n, --no-create-db 不包含数据库的创建语句 
	-t, --no-create-info 不包含数据表的创建语句 
	-d --no-data 不包含数据 
	-T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一 个.txt文件，数据文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysqlimport-source" tabindex="-1"><a class="header-anchor" href="#mysqlimport-source" aria-hidden="true">#</a> mysqlimport/source</h4><p><strong>mysqlimport</strong>： 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>语法 ：
	mysqlimport <span class="token punctuation">[</span>options<span class="token punctuation">]</span> db_name textfile1 <span class="token punctuation">[</span>textfile2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> 
示例 ：
	mysqlimport <span class="token operator">-</span>uroot <span class="token operator">-</span>p2143 test <span class="token operator">/</span>tmp<span class="token operator">/</span>city<span class="token punctuation">.</span>txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>source</strong>：如果需要导入sql文件,可以使用mysql中的source 指令 :</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>语法 ：
	source <span class="token operator">/</span>root<span class="token operator">/</span>xxxxx<span class="token punctuation">.</span><span class="token keyword">sql</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,653);function Aa(Ba,Na){const p=l("ExternalLinkIcon");return i(),c("div",null,[Ia,n("p",null,[s("在MySQL5.5.3之前，有一个著名的bug#989(bug链接: "),n("a",Da,[s("MySQL Bugs: #989: If DROP TABLE while there's an active transaction, wrong binlog order"),d(p)]),s(")，大致如下:")]),Ra])}const Ca=o(Ta,[["render",Aa],["__file","mysql-advance.html.vue"]]);export{Ca as default};
