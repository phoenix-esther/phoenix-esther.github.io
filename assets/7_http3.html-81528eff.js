import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c as _,a as t,b as e,d as n,e as s}from"./app-e53dd85b.js";const T="/assets/img-01-6256b476.png",h="/assets/img-02-d4d1721f.png",a="/assets/img-03-e971ca9f.png",c="/assets/img-04-94bbb084.png",d="/assets/img-05-f4beba20.png",p="/assets/img-06-d44f776c.png",P="/assets/img-07-c5692a22.webp",m="/assets/img-08-e9c525ef.png",g="/assets/img-09-35db6c8d.png",u={},C=t("h1",{id:"http-3-强势来袭",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#http-3-强势来袭","aria-hidden":"true"},"#"),e(" HTTP/3 强势来袭")],-1),E=t("p",null,"HTTP/3 现在（2022 年 5 月）还没正式推出，不过自 2017 年起，HTTP/3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。",-1),H=t("p",null,"所以，这次 HTTP/3 介绍不会涉及到包格式，只说它的特性。",-1),B=t("p",null,[t("img",{src:T,alt:"img"})],-1),f={id:"美中不足的-http-2",tabindex:"-1"},I=t("a",{class:"header-anchor",href:"#美中不足的-http-2","aria-hidden":"true"},"#",-1),S={href:"https://xiaolincoding.com/network/2_http/http3.html#%E7%BE%8E%E4%B8%AD%E4%B8%8D%E8%B6%B3%E7%9A%84-http-2",target:"_blank",rel:"noopener noreferrer"},A=t("p",null,"HTTP/2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP/1.1 的性能，而美中不足的是 HTTP/2 协议是基于 TCP 实现的，于是存在的缺陷有三个。",-1),U=t("ul",null,[t("li",null,"队头阻塞；"),t("li",null,"TCP 与 TLS 的握手时延迟；"),t("li",null,"网络迁移需要重新连接；")],-1),b={id:"队头阻塞",tabindex:"-1"},Q=t("a",{class:"header-anchor",href:"#队头阻塞","aria-hidden":"true"},"#",-1),k={href:"https://xiaolincoding.com/network/2_http/http3.html#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E",target:"_blank",rel:"noopener noreferrer"},D=t("p",null,"HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。",-1),x=t("p",null,"比如下图中，Stream 2 有一个 TCP 报文丢失了，那么即使收到了 Stream 3 和 Stream 4 的 TCP 报文，应用层也是无法读取读取的，相当于阻塞了 Stream 3 和 Stream 4 请求。",-1),L=t("p",null,[t("img",{src:h,alt:"img"})],-1),F=t("p",null,"因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。",-1),K=t("p",null,"举个例子，如下图：",-1),w=t("p",null,[t("img",{src:a,alt:"img"})],-1),R=t("p",null,"图中发送方发送了很多个 Packet，每个 Packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 Packet 3 在网络中丢失了，即使 Packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 Packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。",-1),V={id:"tcp-与-tls-的握手时延迟",tabindex:"-1"},N=t("a",{class:"header-anchor",href:"#tcp-与-tls-的握手时延迟","aria-hidden":"true"},"#",-1),q={href:"https://xiaolincoding.com/network/2_http/http3.html#tcp-%E4%B8%8E-tls-%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6%E8%BF%9F",target:"_blank",rel:"noopener noreferrer"},v=t("p",null,"发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。",-1),G=t("p",null,[t("img",{src:c,alt:"img"})],-1),W=t("p",null,"另外，TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生“减速”效果。",-1),y={id:"网络迁移需要重新连接",tabindex:"-1"},O=t("a",{class:"header-anchor",href:"#网络迁移需要重新连接","aria-hidden":"true"},"#",-1),j={href:"https://xiaolincoding.com/network/2_http/http3.html#%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5",target:"_blank",rel:"noopener noreferrer"},z=t("p",null,"一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。",-1),J=t("p",null,[e("这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP/2 在怎么设计都无法逃脱。要解决这个问题，就必须把"),t("strong",null,"传输层协议替换成 UDP"),e("，这个大胆的决定，HTTP/3 做了！")],-1),M=t("p",null,[t("img",{src:d,alt:"img"})],-1),X={id:"quic-协议的特点",tabindex:"-1"},Y=t("a",{class:"header-anchor",href:"#quic-协议的特点","aria-hidden":"true"},"#",-1),Z={href:"https://xiaolincoding.com/network/2_http/http3.html#quic-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9",target:"_blank",rel:"noopener noreferrer"},$=t("p",null,"我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。",-1),tt=t("p",null,"而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。",-1),et=t("p",null,[e("当然，HTTP/3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应用层」实现了 "),t("strong",null,"QUIC 协议"),e("，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。")],-1),ot=t("p",null,"QUIC 协议的优点有很多，这里举例几个，比如：",-1),nt=t("ul",null,[t("li",null,"无队头阻塞；"),t("li",null,"更快的连接建立；"),t("li",null,"连接迁移；")],-1),st={id:"无队头阻塞",tabindex:"-1"},rt=t("a",{class:"header-anchor",href:"#无队头阻塞","aria-hidden":"true"},"#",-1),it={href:"https://xiaolincoding.com/network/2_http/http3.html#%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E",target:"_blank",rel:"noopener noreferrer"},lt=t("p",null,"QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。",-1),_t=t("p",null,"由于 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。",-1),Tt=t("p",null,"不过 QUIC 协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。",-1),ht=t("p",null,"而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。",-1),at=t("p",null,"所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。",-1),ct=t("p",null,[t("img",{src:p,alt:"img"})],-1),dt={id:"更快的连接建立",tabindex:"-1"},pt=t("a",{class:"header-anchor",href:"#更快的连接建立","aria-hidden":"true"},"#",-1),Pt={href:"https://xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B",target:"_blank",rel:"noopener noreferrer"},mt=t("p",null,"对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、OpenSSL 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。",-1),gt=t("p",null,"HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。",-1),ut=t("p",null,[e("但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 "),t("strong",null,"QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果"),e("。")],-1),Ct=t("p",null,"如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT：",-1),Et=t("p",null,[t("img",{src:P,alt:"img"})],-1),Ht={id:"连接迁移",tabindex:"-1"},Bt=t("a",{class:"header-anchor",href:"#连接迁移","aria-hidden":"true"},"#",-1),ft={href:"https://xiaolincoding.com/network/2_http/http3.html#%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB",target:"_blank",rel:"noopener noreferrer"},It=t("p",null,"在前面我们提到，基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。",-1),St=t("p",null,[t("img",{src:m,alt:"img"})],-1),At=t("p",null,"那么当移动设备的网络从 4G 切换到 WiFi 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。",-1),Ut=t("p",null,[e("而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过"),t("strong",null,"连接 ID"),e(" 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了"),t("strong",null,"连接迁移"),e("的功能。")],-1),bt={id:"http-3-协议",tabindex:"-1"},Qt=t("a",{class:"header-anchor",href:"#http-3-协议","aria-hidden":"true"},"#",-1),kt={href:"https://xiaolincoding.com/network/2_http/http3.html#http-3-%E5%8D%8F%E8%AE%AE",target:"_blank",rel:"noopener noreferrer"},Dt=s('<p>了解完 QUIC 协议的特点后，我们再来看看 HTTP/3 协议在 HTTP 这一层做了什么变化。</p><p>HTTP/3 同 HTTP/2 一样采用二进制帧的结构，不同的地方在于 HTTP/2 的二进制帧里需要定义 Stream，而 HTTP/3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP/3 的帧的结构也变简单了。</p><p><img src="'+g+'" alt="img"></p><p>从上图可以看到，HTTP/3 帧头只有两个字段：类型和长度。</p><p>根据帧类型的不同，大体上分为数据帧和控制帧两大类，Headers 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</p><p>HTTP/3 在头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。与 HTTP/2 中的 HPACK 编码方式相似，HTTP/3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。</p><p>对于静态表的变化，HTTP/2 中的 HPACK 的静态表只有 61 项，而 HTTP/3 中的 QPACK 的静态表扩大到 91 项。</p><p>HTTP/2 和 HTTP/3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。</p><p>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。</p><p>可以看到，<strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong>。</p><p>HTTP/3 的 QPACK 解决了这一问题，那它是如何解决的呢？</p><p>QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p><ul><li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li><li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li></ul><p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>',14),xt={id:"总结",tabindex:"-1"},Lt=t("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#",-1),Ft={href:"https://xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"},Kt=s("<p>HTTP/2 虽然具有多个流并发传输的能力，但是传输层是 TCP 协议，于是存在以下缺陷：</p><ul><li><strong>队头阻塞</strong>，HTTP/2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；</li><li><strong>TCP 和 TLS 握手时延</strong>，TCP 三次握手和 TLS 四次握手，共有 3-RTT 的时延；</li><li><strong>连接迁移需要重新连接</strong>，移动设备从 4G 网络环境切换到 WiFi 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；</li></ul><p>HTTP/3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。</p><p>QUIC 协议的特点：</p><ul><li><strong>无队头阻塞</strong>，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；</li><li><strong>建立连接速度快</strong>，因为 QUIC 内部包含 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li><li><strong>连接迁移</strong>，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</li></ul><p>另外 HTTP/3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP/2 的 HPACK 队头阻塞问题。</p><p><strong>期待，HTTP/3 正式推出的那一天！</strong></p>",7);function wt(Rt,Vt){const o=i("ExternalLinkIcon");return l(),_("div",null,[C,E,H,B,t("h2",f,[I,e(),t("a",S,[e("#"),n(o)]),e("美中不足的 HTTP/2")]),A,U,t("h3",b,[Q,e(),t("a",k,[e("#"),n(o)]),e("队头阻塞")]),D,x,L,F,K,w,R,t("h3",V,[N,e(),t("a",q,[e("#"),n(o)]),e("TCP 与 TLS 的握手时延迟")]),v,G,W,t("h3",y,[O,e(),t("a",j,[e("#"),n(o)]),e("网络迁移需要重新连接")]),z,J,M,t("h2",X,[Y,e(),t("a",Z,[e("#"),n(o)]),e("QUIC 协议的特点")]),$,tt,et,ot,nt,t("h3",st,[rt,e(),t("a",it,[e("#"),n(o)]),e("无队头阻塞")]),lt,_t,Tt,ht,at,ct,t("h3",dt,[pt,e(),t("a",Pt,[e("#"),n(o)]),e("更快的连接建立")]),mt,gt,ut,Ct,Et,t("h3",Ht,[Bt,e(),t("a",ft,[e("#"),n(o)]),e("连接迁移")]),It,St,At,Ut,t("h2",bt,[Qt,e(),t("a",kt,[e("#"),n(o)]),e("HTTP/3 协议")]),Dt,t("h2",xt,[Lt,e(),t("a",Ft,[e("#"),n(o)]),e("总结")]),Kt])}const vt=r(u,[["render",wt],["__file","7_http3.html.vue"]]);export{vt as default};
