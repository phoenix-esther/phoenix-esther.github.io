const t=JSON.parse('{"key":"v-09a161f3","path":"/middleware/kafka/kafka-producer.html","title":"Kafka 生产者","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"生产者发送消息的流程","slug":"生产者发送消息的流程","link":"#生产者发送消息的流程","children":[{"level":3,"title":"发送原理","slug":"发送原理","link":"#发送原理","children":[]},{"level":3,"title":"生产者重要参数列表","slug":"生产者重要参数列表","link":"#生产者重要参数列表","children":[]}]},{"level":2,"title":"异步发送API","slug":"异步发送api","link":"#异步发送api","children":[]}],"git":{"createdTime":1660123310000,"updatedTime":1660123310000,"contributors":[{"name":"诗人都藏在水底","email":"895252461@qq.com","commits":1}]},"readingTime":{"minutes":2,"words":599},"localizedDate":"2022年8月10日","filePathRelative":"middleware/kafka/kafka-producer.md","excerpt":"<h1> Kafka 生产者</h1>\\n<h2> 生产者发送消息的流程</h2>\\n<h3> 发送原理</h3>\\n<p>在消息发送的过程中，涉及到了<strong>两个线程——main 线程和 Sender 线程</strong>。在 main 线程中创建了<strong>一个双端队列 RecordAccumulator</strong>。main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka Broker。</p>\\n<p></p>\\n<h3> 生产者重要参数列表</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>参数名称</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>bootstrap.servers</td>\\n<td>生产者连接集群所需的 broker 地址清单。 例如 hadoop102:9092,hadoop103:9092,hadoop104:9092，可以设置 1 个或者多个，中间用逗号隔开。注意这里并非需要所有的 broker 地址，因为生产者从给定的 broker里查找到其他 broker 信息。</td>\\n</tr>\\n<tr>\\n<td>key.serializer 和 value.serializer</td>\\n<td>指定发送消息的 key 和 value 的序列化类型。一定要写全类名。</td>\\n</tr>\\n<tr>\\n<td>buffer.memory</td>\\n<td>RecordAccumulator 缓冲区总大小，默认 32m。</td>\\n</tr>\\n<tr>\\n<td>batch.size</td>\\n<td>缓冲区一批数据最大值，默认 16k。适当增加该值，可以提高吞吐量，但是如果该值设置太大，会导致数据传输延迟增加。</td>\\n</tr>\\n<tr>\\n<td>linger.ms</td>\\n<td>如果数据迟迟未达到 batch.size，sender 等待 linger.time之后就会发送数据。单位 ms，默认值是 0ms，表示没有延迟。生产环境建议该值大小为 5-100ms 之间。</td>\\n</tr>\\n<tr>\\n<td>acks</td>\\n<td>0：生产者发送过来的数据，不需要等数据落盘应答。1：生产者发送过来的数据，Leader 收到数据后应答。-1（all）：生产者发送过来的数据，Leader+和 isr 队列里面的所有节点收齐数据后应答。默认值是-1，-1 和all 是等价的。</td>\\n</tr>\\n<tr>\\n<td>max.in.flight.requests.per.connection</td>\\n<td>允许最多没有返回 ack 的次数，默认为 5，开启幂等性要保证该值是 1-5 的数字。</td>\\n</tr>\\n<tr>\\n<td>retries</td>\\n<td>当消息发送出现错误的时候，系统会重发消息。retries 表示重试次数。默认是 int 最大值，2147483647。如果设置了重试，还想保证消息的有序性，需要设置MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION=1否则在重试此失败消息的时候，其他的消息可能发送成功了。</td>\\n</tr>\\n<tr>\\n<td>retry.backoff.ms</td>\\n<td>两次重试之间的时间间隔，默认是 100ms。</td>\\n</tr>\\n<tr>\\n<td>enable.idempotence</td>\\n<td>是否开启幂等性，默认 true，开启幂等性。</td>\\n</tr>\\n<tr>\\n<td>compression.type</td>\\n<td>生产者发送的所有数据的压缩方式。默认是 none，也就是不压缩。支持压缩类型：none、gzip、snappy、lz4 和 zstd。</td>\\n</tr>\\n</tbody>\\n</table>"}');export{t as data};
