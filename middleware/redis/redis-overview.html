<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Redis | Java 成神之路</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="modulepreload" href="/assets/app.02d01547.js"><link rel="modulepreload" href="/assets/redis-overview.html.a605093f.js"><link rel="modulepreload" href="/assets/redis-overview.html.7becadfa.js"><link rel="prefetch" href="/assets/index.html.e572e1ac.js"><link rel="prefetch" href="/assets/spring-cloud-alibaba-seate.html.9d6ccab5.js"><link rel="prefetch" href="/assets/spring-cloud-overview.html.41ca776f.js"><link rel="prefetch" href="/assets/gitbook.html.8f972892.js"><link rel="prefetch" href="/assets/mysql-advance.html.40a14146.js"><link rel="prefetch" href="/assets/mysql-apply.html.b83d4288.js"><link rel="prefetch" href="/assets/mysql-base.html.a75e792f.js"><link rel="prefetch" href="/assets/mysql-devops.html.004288cb.js"><link rel="prefetch" href="/assets/java-base.html.38d38369.js"><link rel="prefetch" href="/assets/java-collection-list.html.9a575d99.js"><link rel="prefetch" href="/assets/java-collection-map.html.338179d6.js"><link rel="prefetch" href="/assets/java-collection-overview.html.15141f82.js"><link rel="prefetch" href="/assets/java-concurrent-base.html.ed5e5fba.js"><link rel="prefetch" href="/assets/Java-concurrent-container.html.5f60af47.js"><link rel="prefetch" href="/assets/java-concurrent-lock.html.f2638008.js"><link rel="prefetch" href="/assets/java-concurrent-pool.html.6ec0b53a.js"><link rel="prefetch" href="/assets/java-concurrent-tools.html.ad9685aa.js"><link rel="prefetch" href="/assets/java-bio.html.12acd21b.js"><link rel="prefetch" href="/assets/java-io-base.html.870751b1.js"><link rel="prefetch" href="/assets/java-nio.html.fd4ba37b.js"><link rel="prefetch" href="/assets/Java内存模型.html.9919949c.js"><link rel="prefetch" href="/assets/JVM内存结构.html.4e0b6aaa.js"><link rel="prefetch" href="/assets/JVM垃圾回收.html.21ce9d46.js"><link rel="prefetch" href="/assets/JVM概览.html.7cfe7d7a.js"><link rel="prefetch" href="/assets/JVM类加载器.html.f1a86c0e.js"><link rel="prefetch" href="/assets/JVM类文件结构.html.9cff5990.js"><link rel="prefetch" href="/assets/JVM调优.html.5621d142.js"><link rel="prefetch" href="/assets/java-lambda.html.66d17311.js"><link rel="prefetch" href="/assets/java-stream.html.a55c4601.js"><link rel="prefetch" href="/assets/kafka-broker.html.1a105294.js"><link rel="prefetch" href="/assets/kafka-consumer.html.1c26aff7.js"><link rel="prefetch" href="/assets/kafka-overview.html.6eaa6a37.js"><link rel="prefetch" href="/assets/kafka-producer.html.edab3aa5.js"><link rel="prefetch" href="/assets/spring-kafka.html.c6b1e017.js"><link rel="prefetch" href="/assets/redis-cluster.html.7b9c557a.js"><link rel="prefetch" href="/assets/tomcat.html.a7c3a897.js"><link rel="prefetch" href="/assets/data-structure-list.html.07a50a57.js"><link rel="prefetch" href="/assets/data-structure-overview.html.2dea5787.js"><link rel="prefetch" href="/assets/data-structure-tree.html.a5071f3a.js"><link rel="prefetch" href="/assets/design-adapter.html.92eb88f5.js"><link rel="prefetch" href="/assets/design-chain.html.f45c6b88.js"><link rel="prefetch" href="/assets/design-composite.html.368d42e0.js"><link rel="prefetch" href="/assets/design-decorator.html.54578231.js"><link rel="prefetch" href="/assets/design-overview.html.f940fc29.js"><link rel="prefetch" href="/assets/design-proxy.html.b336fd7e.js"><link rel="prefetch" href="/assets/design-strategy.html.ddfd96ac.js"><link rel="prefetch" href="/assets/滑动窗口.html.b72954d1.js"><link rel="prefetch" href="/assets/linux-overview.html.6220e8b9.js"><link rel="prefetch" href="/assets/servlet-base.html.4704337c.js"><link rel="prefetch" href="/assets/temp.html.69aef9b3.js"><link rel="prefetch" href="/assets/BeanPostProcessor-base.html.1c90a02e.js"><link rel="prefetch" href="/assets/BeanPostProcessor-ConfigurationClassPostProcessor.html.5fa33d60.js"><link rel="prefetch" href="/assets/spring-source-overview.html.9075561f.js"><link rel="prefetch" href="/assets/spring-boot-condition.html.4ef9c766.js"><link rel="prefetch" href="/assets/spring-cloud-commons-base.html.08d23870.js"><link rel="prefetch" href="/assets/spring-cloud-loadbalancer.html.20cc973e.js"><link rel="prefetch" href="/assets/nacos-client-discovery.html.ba4b4d05.js"><link rel="prefetch" href="/assets/nacos-overview.html.49af9859.js"><link rel="prefetch" href="/assets/spring-cloud-openfeign.html.0435cd83.js"><link rel="prefetch" href="/assets/spring-cloud-ribbon.html.a7014d19.js"><link rel="prefetch" href="/assets/sentinel-source.html.de7a8eec.js"><link rel="prefetch" href="/assets/git.html.109aac2c.js"><link rel="prefetch" href="/assets/junit5.html.f0cbabd7.js"><link rel="prefetch" href="/assets/log-framework.html.0c194d25.js"><link rel="prefetch" href="/assets/maven.html.c8ac9994.js"><link rel="prefetch" href="/assets/1.Hello World.html.44e110e7.js"><link rel="prefetch" href="/assets/2.Global Config.html.048d8386.js"><link rel="prefetch" href="/assets/index.html.3329f7a3.js"><link rel="prefetch" href="/assets/reactor.html.b6c07b51.js"><link rel="prefetch" href="/assets/spring-source-web-init.html.c7028c0b.js"><link rel="prefetch" href="/assets/404.html.265028f6.js"><link rel="prefetch" href="/assets/index.html.78297618.js"><link rel="prefetch" href="/assets/spring-cloud-alibaba-seate.html.3fcb3fb7.js"><link rel="prefetch" href="/assets/spring-cloud-overview.html.b29728ff.js"><link rel="prefetch" href="/assets/gitbook.html.447fb73b.js"><link rel="prefetch" href="/assets/mysql-advance.html.b23ff5c5.js"><link rel="prefetch" href="/assets/mysql-apply.html.fb46b886.js"><link rel="prefetch" href="/assets/mysql-base.html.9fbcda97.js"><link rel="prefetch" href="/assets/mysql-devops.html.38ef80a9.js"><link rel="prefetch" href="/assets/java-base.html.af8a22d9.js"><link rel="prefetch" href="/assets/java-collection-list.html.d892a5d2.js"><link rel="prefetch" href="/assets/java-collection-map.html.2fe8e387.js"><link rel="prefetch" href="/assets/java-collection-overview.html.0806c70b.js"><link rel="prefetch" href="/assets/java-concurrent-base.html.6629e92c.js"><link rel="prefetch" href="/assets/Java-concurrent-container.html.47a7468f.js"><link rel="prefetch" href="/assets/java-concurrent-lock.html.d6eecae0.js"><link rel="prefetch" href="/assets/java-concurrent-pool.html.1c9718b5.js"><link rel="prefetch" href="/assets/java-concurrent-tools.html.afc298c7.js"><link rel="prefetch" href="/assets/java-bio.html.91cdceb7.js"><link rel="prefetch" href="/assets/java-io-base.html.3a22ac12.js"><link rel="prefetch" href="/assets/java-nio.html.bcb19e66.js"><link rel="prefetch" href="/assets/Java内存模型.html.b966a445.js"><link rel="prefetch" href="/assets/JVM内存结构.html.7a78d036.js"><link rel="prefetch" href="/assets/JVM垃圾回收.html.d9385c32.js"><link rel="prefetch" href="/assets/JVM概览.html.d1dfe759.js"><link rel="prefetch" href="/assets/JVM类加载器.html.407d2672.js"><link rel="prefetch" href="/assets/JVM类文件结构.html.db77112d.js"><link rel="prefetch" href="/assets/JVM调优.html.43a72e59.js"><link rel="prefetch" href="/assets/java-lambda.html.f61c3b1b.js"><link rel="prefetch" href="/assets/java-stream.html.8e3042a3.js"><link rel="prefetch" href="/assets/kafka-broker.html.c99dfb68.js"><link rel="prefetch" href="/assets/kafka-consumer.html.be5dc5dc.js"><link rel="prefetch" href="/assets/kafka-overview.html.05ceebda.js"><link rel="prefetch" href="/assets/kafka-producer.html.ae473230.js"><link rel="prefetch" href="/assets/spring-kafka.html.ab992adb.js"><link rel="prefetch" href="/assets/redis-cluster.html.159edd91.js"><link rel="prefetch" href="/assets/tomcat.html.44ba6b61.js"><link rel="prefetch" href="/assets/data-structure-list.html.52540621.js"><link rel="prefetch" href="/assets/data-structure-overview.html.1137a496.js"><link rel="prefetch" href="/assets/data-structure-tree.html.46adf610.js"><link rel="prefetch" href="/assets/design-adapter.html.44b03d32.js"><link rel="prefetch" href="/assets/design-chain.html.1e28422f.js"><link rel="prefetch" href="/assets/design-composite.html.9221cae7.js"><link rel="prefetch" href="/assets/design-decorator.html.083acddc.js"><link rel="prefetch" href="/assets/design-overview.html.958d8bed.js"><link rel="prefetch" href="/assets/design-proxy.html.29d1600e.js"><link rel="prefetch" href="/assets/design-strategy.html.fa019104.js"><link rel="prefetch" href="/assets/滑动窗口.html.153f5894.js"><link rel="prefetch" href="/assets/linux-overview.html.57b8affb.js"><link rel="prefetch" href="/assets/servlet-base.html.926bb737.js"><link rel="prefetch" href="/assets/temp.html.24a50968.js"><link rel="prefetch" href="/assets/BeanPostProcessor-base.html.7e56af71.js"><link rel="prefetch" href="/assets/BeanPostProcessor-ConfigurationClassPostProcessor.html.5f55ae7f.js"><link rel="prefetch" href="/assets/spring-source-overview.html.107d3c17.js"><link rel="prefetch" href="/assets/spring-boot-condition.html.709747fa.js"><link rel="prefetch" href="/assets/spring-cloud-commons-base.html.bd81ee10.js"><link rel="prefetch" href="/assets/spring-cloud-loadbalancer.html.bd3a85c7.js"><link rel="prefetch" href="/assets/nacos-client-discovery.html.9c41f1f4.js"><link rel="prefetch" href="/assets/nacos-overview.html.e61ef88e.js"><link rel="prefetch" href="/assets/spring-cloud-openfeign.html.cde35177.js"><link rel="prefetch" href="/assets/spring-cloud-ribbon.html.1eff3153.js"><link rel="prefetch" href="/assets/sentinel-source.html.c20616c9.js"><link rel="prefetch" href="/assets/git.html.39951b55.js"><link rel="prefetch" href="/assets/junit5.html.6b07d0fa.js"><link rel="prefetch" href="/assets/log-framework.html.c089b31f.js"><link rel="prefetch" href="/assets/maven.html.aaeb5e04.js"><link rel="prefetch" href="/assets/1.Hello World.html.c7cc29eb.js"><link rel="prefetch" href="/assets/2.Global Config.html.353cfd07.js"><link rel="prefetch" href="/assets/index.html.2089be29.js"><link rel="prefetch" href="/assets/reactor.html.524307fe.js"><link rel="prefetch" href="/assets/spring-source-web-init.html.28198657.js"><link rel="prefetch" href="/assets/404.html.3b85ff6e.js"><link rel="prefetch" href="/assets/404.3596b09e.js"><link rel="prefetch" href="/assets/Layout.4a040395.js">
    <link rel="stylesheet" href="/assets/style.2a2d75aa.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Java 成神之路</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java 笔记"><span class="title">Java 笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java 笔记"><span class="title">Java 笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java 基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-base/java-base.html" class="" aria-label="Java 基础知识"><!--[--><!--]--> Java 基础知识 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java IO</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-io/java-io-base.html" class="" aria-label="Java IO 基础知识"><!--[--><!--]--> Java IO 基础知识 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java 集合</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-collection/java-collection-overview.html" class="" aria-label="Java 集合概览"><!--[--><!--]--> Java 集合概览 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-collection/java-collection-list.html" class="" aria-label="Java List集合"><!--[--><!--]--> Java List集合 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java 并发</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-concurrent/java-concurrent-base.html" class="" aria-label="Java 并发基础"><!--[--><!--]--> Java 并发基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>JVM 详解</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM概览.html" class="" aria-label="JVM概览"><!--[--><!--]--> JVM概览 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM内存结构.html" class="" aria-label="JVM内存结构"><!--[--><!--]--> JVM内存结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM垃圾回收.html" class="" aria-label="JVM垃圾回收"><!--[--><!--]--> JVM垃圾回收 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM类文件结构.html" class="" aria-label="JVM类文件结构"><!--[--><!--]--> JVM类文件结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM类加载器.html" class="" aria-label="JVM类加载器"><!--[--><!--]--> JVM类加载器 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM内存模型.html" class="" aria-label="Java内存模型"><!--[--><!--]--> Java内存模型 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Spring 笔记"><span class="title">Spring 笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Spring 笔记"><span class="title">Spring 笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Spring IOC</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/spring/test02.html" class="" aria-label="Spring IOC详解"><!--[--><!--]--> Spring IOC详解 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Spring 后置处理器解析</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/spring/spring-bean-post-processor/BeanPostProcessor-base.html" class="" aria-label="Spring 后置处理器总览"><!--[--><!--]--> Spring 后置处理器总览 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Spring Cloud"><span class="title">Spring Cloud</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Spring Cloud"><span class="title">Spring Cloud</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-overview.md" class="" aria-label="Spring Cloud Overview"><!--[--><!--]--> Spring Cloud Overview <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-alibaba-nacos.md" class="" aria-label="Spring Cloud Nacos"><!--[--><!--]--> Spring Cloud Nacos <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-alibaba-sentinel.md" class="" aria-label="Spring Cloud Sentinel"><!--[--><!--]--> Spring Cloud Sentinel <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-alibaba-seate.md" class="" aria-label="Spring Cloud Seate"><!--[--><!--]--> Spring Cloud Seate <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-ribbon/spring-cloud-ribbon.md" class="" aria-label="Spring Cloud Ribbon"><!--[--><!--]--> Spring Cloud Ribbon <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>MySQL</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-base.html" class="" aria-label="MySQL 基础篇"><!--[--><!--]--> MySQL 基础篇 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-advance.html" class="" aria-label="MySQL 进阶篇"><!--[--><!--]--> MySQL 进阶篇 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-devops.html" class="" aria-label="MySQL 运维篇"><!--[--><!--]--> MySQL 运维篇 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-apply.html" class="" aria-label="MySQL 应用篇"><!--[--><!--]--> MySQL 应用篇 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="自我修养"><span class="title">自我修养</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="自我修养"><span class="title">自我修养</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/quality/design-mode/design-overview.html" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/quality/data-structure/data-structure-overview.html" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/quality/linux/linux-overview.html" class="" aria-label="Linux 总结"><!--[--><!--]--> Linux 总结 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="中间件"><span class="title">中间件</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="中间件"><span class="title">中间件</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/middleware/tomcat/tomcat.md" class="" aria-label="Tomcat 专题"><!--[--><!--]--> Tomcat 专题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/middleware/kafka/kafka-overview.md" class="" aria-label="Kafka 专题"><!--[--><!--]--> Kafka 专题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/middleware/redis/redis-overview.md" class="" aria-label="Redis 专题"><!--[--><!--]--> Redis 专题 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工具包"><span class="title">工具包</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工具包"><span class="title">工具包</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Junit 测试框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/tools/junit/junit5.md" class="" aria-label="Junit 5 使用总结"><!--[--><!--]--> Junit 5 使用总结 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><a href="/tools/log/log-framework.md" class="" aria-label="Java 日志框架"><!--[--><!--]--> Java 日志框架 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/tools/maven/maven.md" class="" aria-label="Maven 使用入门"><!--[--><!--]--> Maven 使用入门 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java 笔记"><span class="title">Java 笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java 笔记"><span class="title">Java 笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java 基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-base/java-base.html" class="" aria-label="Java 基础知识"><!--[--><!--]--> Java 基础知识 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java IO</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-io/java-io-base.html" class="" aria-label="Java IO 基础知识"><!--[--><!--]--> Java IO 基础知识 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java 集合</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-collection/java-collection-overview.html" class="" aria-label="Java 集合概览"><!--[--><!--]--> Java 集合概览 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-collection/java-collection-list.html" class="" aria-label="Java List集合"><!--[--><!--]--> Java List集合 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java 并发</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-concurrent/java-concurrent-base.html" class="" aria-label="Java 并发基础"><!--[--><!--]--> Java 并发基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>JVM 详解</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM概览.html" class="" aria-label="JVM概览"><!--[--><!--]--> JVM概览 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM内存结构.html" class="" aria-label="JVM内存结构"><!--[--><!--]--> JVM内存结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM垃圾回收.html" class="" aria-label="JVM垃圾回收"><!--[--><!--]--> JVM垃圾回收 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM类文件结构.html" class="" aria-label="JVM类文件结构"><!--[--><!--]--> JVM类文件结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM类加载器.html" class="" aria-label="JVM类加载器"><!--[--><!--]--> JVM类加载器 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/java/java-jvm/JVM内存模型.html" class="" aria-label="Java内存模型"><!--[--><!--]--> Java内存模型 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Spring 笔记"><span class="title">Spring 笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Spring 笔记"><span class="title">Spring 笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Spring IOC</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/spring/test02.html" class="" aria-label="Spring IOC详解"><!--[--><!--]--> Spring IOC详解 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Spring 后置处理器解析</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/spring/spring-bean-post-processor/BeanPostProcessor-base.html" class="" aria-label="Spring 后置处理器总览"><!--[--><!--]--> Spring 后置处理器总览 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Spring Cloud"><span class="title">Spring Cloud</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Spring Cloud"><span class="title">Spring Cloud</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-overview.md" class="" aria-label="Spring Cloud Overview"><!--[--><!--]--> Spring Cloud Overview <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-alibaba-nacos.md" class="" aria-label="Spring Cloud Nacos"><!--[--><!--]--> Spring Cloud Nacos <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-alibaba-sentinel.md" class="" aria-label="Spring Cloud Sentinel"><!--[--><!--]--> Spring Cloud Sentinel <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-alibaba-seate.md" class="" aria-label="Spring Cloud Seate"><!--[--><!--]--> Spring Cloud Seate <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud/spring-cloud-ribbon/spring-cloud-ribbon.md" class="" aria-label="Spring Cloud Ribbon"><!--[--><!--]--> Spring Cloud Ribbon <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>MySQL</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-base.html" class="" aria-label="MySQL 基础篇"><!--[--><!--]--> MySQL 基础篇 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-advance.html" class="" aria-label="MySQL 进阶篇"><!--[--><!--]--> MySQL 进阶篇 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-devops.html" class="" aria-label="MySQL 运维篇"><!--[--><!--]--> MySQL 运维篇 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/database/mysql/mysql-apply.html" class="" aria-label="MySQL 应用篇"><!--[--><!--]--> MySQL 应用篇 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="自我修养"><span class="title">自我修养</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="自我修养"><span class="title">自我修养</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/quality/design-mode/design-overview.html" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/quality/data-structure/data-structure-overview.html" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/quality/linux/linux-overview.html" class="" aria-label="Linux 总结"><!--[--><!--]--> Linux 总结 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="中间件"><span class="title">中间件</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="中间件"><span class="title">中间件</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/middleware/tomcat/tomcat.md" class="" aria-label="Tomcat 专题"><!--[--><!--]--> Tomcat 专题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/middleware/kafka/kafka-overview.md" class="" aria-label="Kafka 专题"><!--[--><!--]--> Kafka 专题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/middleware/redis/redis-overview.md" class="" aria-label="Redis 专题"><!--[--><!--]--> Redis 专题 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工具包"><span class="title">工具包</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工具包"><span class="title">工具包</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Junit 测试框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/tools/junit/junit5.md" class="" aria-label="Junit 5 使用总结"><!--[--><!--]--> Junit 5 使用总结 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><a href="/tools/log/log-framework.md" class="" aria-label="Java 日志框架"><!--[--><!--]--> Java 日志框架 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/tools/maven/maven.md" class="" aria-label="Maven 使用入门"><!--[--><!--]--> Maven 使用入门 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Tomcat 专题 <!----></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/middleware/tomcat/tomcat.html" class="sidebar-item" aria-label="Tomcat专题"><!--[--><!--]--> Tomcat专题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">Kafka 专题 <!----></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/middleware/kafka/kafka-overview.html" class="sidebar-item" aria-label="Kafka Overview"><!--[--><!--]--> Kafka Overview <!--[--><!--]--></a><!----></li><li><a href="/middleware/kafka/kafka-consumer.html" class="sidebar-item" aria-label="Kafka Consumer"><!--[--><!--]--> Kafka Consumer <!--[--><!--]--></a><!----></li><li><a href="/middleware/kafka/kafka-producer.html" class="sidebar-item" aria-label="Kafka 生产者"><!--[--><!--]--> Kafka 生产者 <!--[--><!--]--></a><!----></li><li><a href="/middleware/kafka/kafka-broker.html" class="sidebar-item" aria-label="Kafka Broker"><!--[--><!--]--> Kafka Broker <!--[--><!--]--></a><!----></li><li><a href="/middleware/kafka/spring-kafka.html" class="sidebar-item" aria-label="Spring Kafka"><!--[--><!--]--> Spring Kafka <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">Redis 专题 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/middleware/redis/redis-overview.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/middleware/redis/redis-overview.html#nosql概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="NoSQL概述"><!--[--><!--]--> NoSQL概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#" class="router-link-active router-link-exact-active sidebar-item" aria-label><!--[--><!--]-->  <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis简介"><!--[--><!--]--> Redis简介 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis安装" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis安装"><!--[--><!--]--> Redis安装 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis-配置文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis 配置文件"><!--[--><!--]--> Redis 配置文件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis实现原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis实现原理"><!--[--><!--]--> Redis实现原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis-基本数据类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis 基本数据类型"><!--[--><!--]--> Redis 基本数据类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis数据类型的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis数据类型的实现"><!--[--><!--]--> Redis数据类型的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis-特殊数据类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis 特殊数据类型"><!--[--><!--]--> Redis 特殊数据类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis-应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis 应用"><!--[--><!--]--> Redis 应用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis事物" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis事物"><!--[--><!--]--> Redis事物 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis持久化" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis持久化"><!--[--><!--]--> Redis持久化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis-集群模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis 集群模式"><!--[--><!--]--> Redis 集群模式 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis主从复制" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis主从复制"><!--[--><!--]--> Redis主从复制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#哨兵机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="哨兵机制"><!--[--><!--]--> 哨兵机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#cluster" class="router-link-active router-link-exact-active sidebar-item" aria-label="Cluster"><!--[--><!--]--> Cluster <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis发布订阅模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis发布订阅模型"><!--[--><!--]--> Redis发布订阅模型 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis常见问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis常见问题"><!--[--><!--]--> Redis常见问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/middleware/redis/redis-overview.html#redis-常见面试题" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redis 常见面试题"><!--[--><!--]--> Redis 常见面试题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/middleware/redis/redis-cluster.html" class="sidebar-item" aria-label="Redis Cluster"><!--[--><!--]--> Redis Cluster <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h2 id="nosql概述" tabindex="-1"><a class="header-anchor" href="#nosql概述" aria-hidden="true">#</a> NoSQL概述</h2><p>NoSQL = Not Only Sql</p><p>关系型数据库：行+列 同一个表下数据的结构是一样的</p><p>非关系型数据库：数据存储没有固定的格式，并且可以横向进行扩展</p><p>传统RDBMS和NoSQL</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>RDBMS
 - 组织化结构
 - 固定SQL
 - 数据和关系都存在单独的表中（行列）
 - DML（数据操作语言）、DDL（数据定义语言）等
 - 严格的一致性（ACID): 原子性、一致性、隔离性、持久性
 - 基础的事务
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>NoSQL
 - 不仅仅是数据
 - 没有固定查询语言
 - 键值对存储（redis）、列存储（HBase）、文档存储（MongoDB）、图形数据库（不是存图形，放的是关系）（Neo4j）
 - 最终一致性（BASE）：基本可用、软状态/柔性事务、最终一致性
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2><h2 id="redis简介" tabindex="-1"><a class="header-anchor" href="#redis简介" aria-hidden="true">#</a> Redis简介</h2><p><strong>Redis</strong>是个基于内存的数据结构的存储系统。</p><p><code>Redis</code>之父 <strong>Salvatore Sanfilippo</strong>，一名意大利程序员，大家更习惯称呼他 Antirez。Redis使用<code>ANSI C</code>语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>Redis也被称为数据结构服务器，因为值（value）可以是<code>字符串(String)</code>,<code>哈希(Hash)</code>, <code>列表(list)</code>,<code>集合(sets)</code>和<code>有序集合(sorted sets)</code>等类型。</p><h4 id="redis的优势" tabindex="-1"><a class="header-anchor" href="#redis的优势" aria-hidden="true">#</a> Redis的优势</h4><ul><li><p>高性能 – Redis读的速度是130000次/s，写的速度是100000次/s。</p></li><li><p>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p></li><li><p>原子性 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</p></li><li><p>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p></li></ul><h4 id="redis和其他key-value存储有什么不同" tabindex="-1"><a class="header-anchor" href="#redis和其他key-value存储有什么不同" aria-hidden="true">#</a> Redis和其他key-value存储有什么不同</h4><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p><h3 id="redis安装" tabindex="-1"><a class="header-anchor" href="#redis安装" aria-hidden="true">#</a> Redis安装</h3><h4 id="下载源码" tabindex="-1"><a class="header-anchor" href="#下载源码" aria-hidden="true">#</a> 下载源码</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> wget https://download.redis.io/redis-stable.tar.gz
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="编译redis" tabindex="-1"><a class="header-anchor" href="#编译redis" aria-hidden="true">#</a> 编译Redis</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 解压
tar zxvf redis-stable.tar.gz

// 编译之前需要安装make和gcc
sudo apt install make
sudo apt-get install gcc

// 编译
make
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译过程中报了个错误</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>cd src &amp;&amp; make all
make[1]: Entering directory &#39;/home/xuliang/developer/env/redis-stable/src&#39;
/bin/sh: 1: pkg-config: not found
    CC adlist.o
In file included from adlist.c:34:
zmalloc.h:50:10: fatal error: jemalloc/jemalloc.h: No such file or directory
   50 | #include &lt;jemalloc/jemalloc.h&gt;
      |          ^~~~~~~~~~~~~~~~~~~~~
compilation terminated.
make[1]: *** [Makefile:374: adlist.o] Error 1
make[1]: Leaving directory &#39;/home/xuliang/developer/env/redis-stable/src&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以尝试在编译的时候添加一个参数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>make MALLOC=libc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="启动服务" tabindex="-1"><a class="header-anchor" href="#启动服务" aria-hidden="true">#</a> 启动服务</h4><p>编译完成之后在src目录下会生成一下文件</p><table><thead><tr><th>文件名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>redis-server</td><td>Redis服务端</td><td></td></tr><tr><td>redis-sentinel</td><td>Redis Sentinel</td><td>redis-server的软连接</td></tr><tr><td>redis-cli</td><td>Redis命令行工具</td><td></td></tr><tr><td>redis-check-rdb</td><td>Redis RDB检查工具</td><td></td></tr><tr><td>redis-check-aof</td><td>Redis Append Only File 检查工具</td><td></td></tr><tr><td>redis-benchmark</td><td>Redis 基准/性能测试工具</td><td></td></tr></tbody></table><h3 id="redis-配置文件" tabindex="-1"><a class="header-anchor" href="#redis-配置文件" aria-hidden="true">#</a> Redis 配置文件</h3><h3 id="redis实现原理" tabindex="-1"><a class="header-anchor" href="#redis实现原理" aria-hidden="true">#</a> Redis实现原理</h3><p>TODO</p><h4 id="redis-特性" tabindex="-1"><a class="header-anchor" href="#redis-特性" aria-hidden="true">#</a> Redis 特性</h4><p>二进制安全</p><p>字节流</p><h2 id="redis-基本数据类型" tabindex="-1"><a class="header-anchor" href="#redis-基本数据类型" aria-hidden="true">#</a> Redis 基本数据类型</h2><p>Redis是一个开源，内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><h4 id="数据类型-string" tabindex="-1"><a class="header-anchor" href="#数据类型-string" aria-hidden="true">#</a> 数据类型-String</h4><ul><li>String类型是redis的最基础的数据结构，也是最经常使用到的类型。而且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以String类型是redis的基础。</li><li>String 类型的值最大能存储 512MB，这里的String类型可以是简单字符串、复杂的xml/json的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串</li></ul><h5 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h5><ul><li><p>缓存功能：String字符串是最常用的数据类型，不仅仅是redis，各个语言都是最基本类型，因此，利用redis作为缓存，配合其它数据库作为存储层，利用redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p></li><li><p>计数器：许多系统都会使用redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p></li><li><p>统计多单位的数量：eg，uid：gongming count：0 根据不同的uid更新count数量。</p></li><li><p>共享用户session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存cookie，这两种方式做有一定弊端，1）每次都重新登录效率低下 2）cookie保存在客户端，有安全隐患。这时可以利用redis将用户的session集中管理，在这种模式只需要保证redis的高可用，每次用户session的更新和获取都可以快速完成。大大提高效率。</p></li></ul><h5 id="命令介绍" tabindex="-1"><a class="header-anchor" href="#命令介绍" aria-hidden="true">#</a> 命令介绍</h5><p>​ TODO</p><h4 id="数据类型-list" tabindex="-1"><a class="header-anchor" href="#数据类型-list" aria-hidden="true">#</a> 数据类型-List</h4><ol><li>list类型是用来存储多个有序的字符串的，列表当中的每一个字符看做一个元素</li><li>一个列表当中可以存储有一个或者多个元素，redis的list支持存储2^32次方-1个元素。</li><li>redis可以从列表的两端进行插入（pubsh）和弹出（pop）元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。redis列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。</li><li>redis列表是链表型的数据结构，所以它的元素是有序的，而且列表内的元素是可以重复的。意味着它可以根据链表的下标获取指定的元素和某个范围内的元素集。</li></ol><h5 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1" aria-hidden="true">#</a> 应用场景</h5><ul><li><p>消息队列：reids的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</p></li><li><p>文章列表或者数据分页展示的应用。比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p></li></ul><h5 id="命令介绍-1" tabindex="-1"><a class="header-anchor" href="#命令介绍-1" aria-hidden="true">#</a> 命令介绍</h5><p>TODO</p><h4 id="数据类型-set" tabindex="-1"><a class="header-anchor" href="#数据类型-set" aria-hidden="true">#</a> 数据类型-Set</h4><ol><li>redis集合（set）类型和list列表类型类似，都可以用来存储多个字符串元素的集合。</li><li>但是和list不同的是set集合当中不允许重复的元素。而且set集合当中元素是没有顺序的，不存在元素下标。</li><li>redis的set类型是使用哈希表构造的，因此复杂度是O(1)，它支持集合内的增删改查，并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。</li></ol><h5 id="应用场景-2" tabindex="-1"><a class="header-anchor" href="#应用场景-2" aria-hidden="true">#</a> 应用场景</h5><ul><li><p>标签：比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。</p></li><li><p>共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。</p></li><li><p>统计网站的独立IP。利用set集合当中元素不唯一性，可以快速实时统计访问网站的独立IP。</p></li></ul><p>数据结构</p><p>set的底层结构相对复杂写，使用了intset和hashtable两种数据结构存储，intset可以理解为数组。</p><h5 id="命令介绍-2" tabindex="-1"><a class="header-anchor" href="#命令介绍-2" aria-hidden="true">#</a> 命令介绍</h5><p>TODO</p><h4 id="数据类型-hash" tabindex="-1"><a class="header-anchor" href="#数据类型-hash" aria-hidden="true">#</a> 数据类型-Hash</h4><p>Redis hash数据结构 是一个键值对（key-value）集合,它是一个 string 类型的 field 和 value 的映射表，redis本身就是一个key-value型数据库，因此hash数据结构相当于在value中又套了一层key-value型数据。所以redis中hash数据结构特别适合存储关系型对象</p><h5 id="应用场景-3" tabindex="-1"><a class="header-anchor" href="#应用场景-3" aria-hidden="true">#</a> 应用场景</h5><p>1、由于hash数据类型的key-value的特性，用来存储关系型数据库中表记录，是redis中哈希类型最常用的场景。一条记录作为一个key-value，把每列属性值对应成field-value存储在哈希表当中，然后通过key值来区分表当中的主键。</p><p>2、经常被用来存储用户相关信息。优化用户信息的获取，不需要重复从数据库当中读取，提高系统性能。</p><h4 id="数据类型-zset" tabindex="-1"><a class="header-anchor" href="#数据类型-zset" aria-hidden="true">#</a> 数据类型-ZSet</h4><p>redis有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，，利用该分数作为排序的依据。</p><h5 id="应用场景-4" tabindex="-1"><a class="header-anchor" href="#应用场景-4" aria-hidden="true">#</a> 应用场景</h5><p>1、 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p><p>2、用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p><h5 id="命令介绍-3" tabindex="-1"><a class="header-anchor" href="#命令介绍-3" aria-hidden="true">#</a> 命令介绍</h5><p>TODO</p><h2 id="redis数据类型的实现" tabindex="-1"><a class="header-anchor" href="#redis数据类型的实现" aria-hidden="true">#</a> Redis数据类型的实现</h2><p>在学习基本类型底层数据存储结构前，首先看下redis整体的存储结构。</p><p>redis内部整体的存储结构是一个大的hashmap，内部是数组实现的hash，key冲突通过挂链表去实现，每个dictEntry为一个key/value对象，value为定义的redisObject。</p><p>结构图如下：</p><p><img src="/assets/445b55f9987948319cb82467856bd20d.cbd333a3.jpeg" alt="一文搞懂redis"></p><p>dictEntry是存储key-&gt;value的地方，再让我们看一下dictEntry结构体：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*
 * 字典
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>
    <span class="token comment">// 键</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token comment">// 值</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token comment">// 指向具体redisObject</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        <span class="token comment">// </span>
        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token comment">// 指向下个哈希表节点，形成链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="redisobject" tabindex="-1"><a class="header-anchor" href="#redisobject" aria-hidden="true">#</a> redisObject</h4><p>我们接着再往下看redisObject究竟是什么结构的</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*
 * Redis 对象
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类型 4bits</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 编码方式 4bits</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// LRU 时间（相对于 server.lruclock） 24bits</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token comment">// 引用计数 Redis里面的数据可以通过引用计数进行共享 32bits</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token comment">// 指向对象的值 64-bit</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>*<strong>ptr字段</strong>：与对象的数据内容相关， 如果是整数， 直接存储数据； 否则表示指向数据的指针。 Redis在3.0之后对值对象是字符串且长度&lt;=39（3.2以后44）字节的数据， 内部编码为embstr类型， 字符串sds和redisObject一起分配， 从而只要一次内存操作即可。</p><p><strong>type字段</strong>：表示当前对象使用的数据类型， Redis主要支持5种数据类 型：string、 hash、 list、 set、 zset。 可以使用type{key}命令查看对象所属类型，type命令返回的是值对象类型， 键都是string类型。，但为了提高存储效率与程序执行效率，每种对象的底层数据结构实现都可能不止一种，</p><p><strong>refcount字段</strong>： 记录当前对象被引用的次数， 用于通过引用次数回收内存， 当refcount=0时， 可以安全回收当前对象空间。 使用object refcount{key}获取当前对象引用。 当对象为整数且范围在[0-9999]时， Redis可以使用共享对象的方式来节省内存。</p><p><strong>encoding字段</strong>： 表示Redis内部编码类型， encoding在Redis内部使用，代表当前对象内部采用哪种数据结构实现。 理解Redis内部编码方式对于优化内存非常重要， 同一个对象采用不同的编码实现内存占用存在明显差异。</p><p><strong>lru字段</strong>： 记录对象最后一次被访问的时间， 当配置了maxmemory和maxmemory-policy=volatile-lru或者allkeys-lru时， 用于辅助LRU算法删除键数据。 可以使用object idletime{key}命令在不更新lru字段情况下查看当前键的空闲时间。</p><p>redis对象底层的八种数据结构</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> REDIS_ENCODING_INT（long 类型的整数）
 REDIS_ENCODING_EMBSTR embstr （编码的简单动态字符串）
 REDIS_ENCODING_RAW （简单动态字符串）
 REDIS_ENCODING_HT （字典）
 REDIS_ENCODING_LINKEDLIST （双端链表）
 REDIS_ENCODING_ZIPLIST （压缩列表）
 REDIS_ENCODING_INTSET （整数集合）
 REDIS_ENCODING_SKIPLIST （跳跃表和字典）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好了，通过redisObject就可以具体指向redis数据类型了，总结一下每种数据类型都使用了哪些数据结构，如下图所示</p><img src="/assets/5855a269498f49b1be903c1029181052.0c259474.png" alt="一文搞懂redis" style="zoom:80%;"><p>前期准备知识已准备完毕，下面分每种基本类型来讲。</p><h4 id="string数据结构" tabindex="-1"><a class="header-anchor" href="#string数据结构" aria-hidden="true">#</a> String数据结构</h4><p>String类型的转换顺序</p><ul><li>当保存的值为整数且值的大小不超过long的范围，使用整数存储</li><li>当字符串长度不超过44字节时，使用EMBSTR 编码</li><li>大于44字符时，使用raw编码</li></ul><p>它只分配一次内存空间，redisObject和sds是连续的内存，查询效率会快很多，也正是因为redisObject和sds是连续在一起，伴随了一些缺点：当字符串增加的时候，它长度会增加，这个时候又需要重新分配内存，导致的结果就是整个redisObject和sds都需要重新分配空间，这样是会影响性能的，所以redis用embstr实现一次分配而后,只允许读，如果修改数据，那么它就会转成raw编码，不再用embstr编码了。</p><h5 id="sds结构" tabindex="-1"><a class="header-anchor" href="#sds结构" aria-hidden="true">#</a> SDS结构</h5><p>embstr和raw都为sds编码，看一下sds的结构体</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/* 针对不同长度整形做了相应的数据结构
 * Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. 
 */</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>由于redis底层使用c语言实现，可能会有疑问为什么不用c语言的字符串呢，而是用sds结构体。</strong></p><ol><li><p>低复杂度获取字符串长度：C字符串并不会记录自身长度，获取时需要遍历整串。</p></li><li><p>避免缓冲区溢出：C在对字符串操作时并不会检查内存是否够用，如字符串的拼接操作，SDS会首先检查内存。</p></li><li><p>减少修改字符串的内存重新分配次数：c语言字符串不记录字符串长度，如果要修改字符串要重新分配内存，如果不进行重新分配会造成内存缓冲区泄露；</p></li></ol><p>redis sds实现了空间预分配和惰性空间释放两种策略</p><ul><li>空间预分配：</li></ul><ol><li>如果sds修改后，sds长度（len的值）将于1mb，那么会分配与len相同大小的未使用空间，此时len与free值相同。例如，修改之后字符串长度为100字节，那么会给分配100字节的未使用空间。最终sds空间实际为 100 + 100 + 1(保存空字符&#39;\0&#39;)；</li><li>如果大于等于1mb，每次给分配1mb未使用空间。例如SDS修改后为30M，实际分配长度为30M+1M+1byte</li></ol><ul><li>惰性空间释放：</li></ul><p>对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用（sds也提供api，我们可以手动触发字符串缩短）；</p><ol><li>二进制安全：因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束；</li><li>遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</li></ol><p>学习完sds，我们回到上面讲到的，为什么小于44字节用embstr编码呢？再看一下rejectObject和sds定义的结构（短字符串的embstr用最小的sdshdr8）</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类型 4bits</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 编码方式 4bits</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// LRU 时间（相对于 server.lruclock） 24bits</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token comment">// 引用计数 Redis里面的数据可以通过引用计数进行共享 32bits</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token comment">// 指向对象的值 64-bit</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>redisObject占用空间</p><p>4 + 4 + 24 + 32 + 64 = 128bits = 16字节</p><p>sdshdr8占用空间</p><p>1（uint8_t） + 1（uint8_t）+ 1 （unsigned char）+ 1（buf[]中结尾的&#39;\0&#39;字符）= 4字节</p><p>初始最小分配为64字节，所以只分配一次空间的embstr最大为 64 - 16- 4 = 44字节</p><h4 id="list存储结构" tabindex="-1"><a class="header-anchor" href="#list存储结构" aria-hidden="true">#</a> List存储结构</h4><p>Redis3.2之前的底层实现方式：压缩列表ziplist 或者 双向循环链表linkedlist</p><p>当list存储的数据量比较少且同时满足下面两个条件时，list就使用ziplist存储数据：</p><ul><li>list中保存的每个元素的长度小于 64 字节；</li><li>列表中数据个数少于512个</li></ul><p>Redis3.2及之后的底层实现方式：quicklist</p><p>quicklist是一个双向链表，而且是一个基于ziplist的双向链表，quicklist的每个节点都是一个ziplist，结合了双向链表和ziplist的优点。</p><h5 id="压缩列表-ziplist" tabindex="-1"><a class="header-anchor" href="#压缩列表-ziplist" aria-hidden="true">#</a> 压缩列表 - zipList</h5><p>ziplist是一种压缩列表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储。但当数据量过大时就ziplist就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。如下图所示，redisObject对象结构中ptr所指向的就是一个ziplist。整个ziplist只需要malloc一次，它们在内存中是一块连续的区域。</p><p>ziplist结构如下：</p><p><img src="/assets/62449302ce4c476593f43d5293846594.af559fb1.png" alt="一文搞懂redis"></p><ul><li><p>zlbytes:用于记录整个压缩列表占用的内存字节数</p></li><li><p>zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节</p></li><li><p>zllen：记录了压缩列表包含的节点数量。</p></li><li><p>entryX：要说列表包含的各个节点</p></li><li><p>zlend：用于标记压缩列表的末端</p></li></ul><blockquote><p><code>为什么数据量大时不用ziplist？</code></p><p>因为ziplist是一段连续的内存，插入的时间复杂化度为O(n)，而且每当插入新的元素需要realloc做内存扩展；而且如果超出ziplist内存大小，还会做重新分配的内存空间，并将内容复制到新的地址。如果数量大的话，重新分配内存和拷贝内存会消耗大量时间。所以不适合大型字符串，也不适合存储量多的元素。</p></blockquote><h5 id="快速列表-quicklist" tabindex="-1"><a class="header-anchor" href="#快速列表-quicklist" aria-hidden="true">#</a> 快速列表 - quickList</h5><p>快速列表是ziplist和linkedlist的混合体，是将linkedlist按段切分，每一段用ziplist来紧凑存储，多个ziplist之间使用双向指针链接。</p><blockquote><p><code>为什么不直接使用linkedlist？</code></p><p>linkedlist的附加空间相对太高，prev和next指针就要占去16个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p></blockquote><p>quicklist结构:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{</span>
    <span class="token comment">// 指向quicklist的头部</span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    <span class="token comment">// 指向quicklist的尾部</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>
    <span class="token comment">// ziplist大小限定，由list-max-ziplist-size给定</span>
    <span class="token keyword">int</span> fill <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token comment">// 节点压缩深度设置，由list-compress-depth给定</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{</span>
    <span class="token comment">// 指向上一个ziplist节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token comment">// 指向下一个ziplist节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 数据指针，如果没有被压缩，就指向ziplist结构，反之指向quicklistLZF结构</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>
    <span class="token comment">// 表示指向ziplist结构的总长度(内存占用长度)</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>
    <span class="token comment">// ziplist数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token comment">/* count of items in ziplist */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">/* RAW==1 or LZF==2 */</span>
    <span class="token comment">// 预留字段，存放数据的方式，1--NONE，2--ziplist</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">/* NONE==1 or ZIPLIST==2 */</span>
    <span class="token comment">// 解压标记，当查看一个被压缩的数据时，需要暂时解压，标记此参数为1，之后再重新进行压缩</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* was this node previous compressed? */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* node can&#39;t compress; too small */</span>
    <span class="token comment">// 扩展字段</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">/* more bits to steal for future usage */</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistLZF</span> <span class="token punctuation">{</span>
    <span class="token comment">// LZF压缩后占用的字节数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span> <span class="token comment">/* LZF size in bytes*/</span>
    <span class="token comment">// 柔性数组，存放压缩后的ziplist字节数组</span>
    <span class="token keyword">char</span> compressed<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklistLZF<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构图如下：</p><p><img src="/assets/6f554343d9bb4533b62716a3731f2c20.c4b50c7b.jpeg" alt="一文搞懂redis"></p><p><strong>ziplist的长度</strong></p><p>quicklist内部默认单个ziplist长度为8k字节，超出了这个字节数，就会新起一个ziplist。关于长度可以使用list-max-ziplist-size决定。</p><p><strong>压缩深度</strong></p><p>我们上面说到了quicklist下是用多个ziplist组成的，同时为了进一步节约空间，Redis还会对ziplist进行压缩存储，使用LZF算法压缩，可以选择压缩深度。quicklist默认的压缩深度是0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。为了支持快速push/pop操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><h4 id="hash存储结构" tabindex="-1"><a class="header-anchor" href="#hash存储结构" aria-hidden="true">#</a> Hash存储结构</h4><p>当Hash中数据项比较少的情况下，Hash底层才用压缩列表ziplist进行存储数据，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>hash-max-ziplist-entries 512
hash-max-ziplist-value 64
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在List中已经介绍了ziplist，下面来介绍下dict。</p><p>看下数据结构</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="token keyword">int</span> iterators<span class="token punctuation">;</span> <span class="token comment">/* number of iterators currently running */</span>
<span class="token punctuation">}</span> dict<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>
    <span class="token comment">//指针数组，这个hash的桶</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
    <span class="token comment">//元素个数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictht<span class="token punctuation">;</span>

<span class="token comment">// dictEntry大家应该熟悉，在上面有讲，使用来真正存储key-&gt;value的地方</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>
    <span class="token comment">// 键</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token comment">// 值</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token comment">// 指向具体redisObject</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        <span class="token comment">// </span>
        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token comment">// 指向下个哈希表节点，形成链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到每个dict中都有两个hashtable</p><p>结构图如下：</p><p><img src="/assets/e8672ff02ef442cfa8a3d8b79e6dbefc.111db01d.jpeg" alt="一文搞懂redis"></p><p>虽然dict结构有两个hashtable，但是通常情况下只有一个hashtable是有值的。但是在dict扩容缩容的时候，需要分配新的hashtable，然后进行渐近式搬迁，这时候两个hashtable存储的旧的hashtable和新的hashtable。搬迁结束后，旧hashtable删除，新的取而代之。</p><p>下面让我们学习下rehash全貌。</p><p><strong>渐进式rehash</strong></p><p>所谓渐进式rehash是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个O(n)的操作。但是因为我们的redis是单线程的，无法承受这样的耗时过程，所以采用了渐进式rehash小步搬迁，虽然慢一点，但是可以搬迁完毕。</p><p>扩容条件</p><p>我们的扩容一般会在Hash表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在redis在做bgsave（RDB持久化操作的过程），为了减少内存页的过多分离（Copy On Write），redis不会去扩容。但是如果hash表的元素个数已经到达了第一维数组长度的5倍的时候，就会强制扩容，不管你是否在持久化。</p><p>不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。</p><p>缩容条件</p><p>当我们的hash表元素逐渐删除的越来越少的时候。redis于是就会对hash表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的10%，并且缩容不考虑是否在做redis持久化。</p><p>不用考虑bgsave主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p><p>rehash步骤</p><p>1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；</p><p>2、定时维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始；</p><p>3、在rehash进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一；</p><p>4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束；</p><p>（采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。特别的在进行rehash时只能对h[0]元素减少的操作，如查询和删除；而查询是在两个哈希表中查找的，而插入只能在ht[1]中进行，ht[1]也可以查询和删除。）</p><p>5、将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表。</p><p>过程如下图：</p><p><img src="/assets/9915e5388f744d7eb25056b0630aa4ae.8ee3aa98.png" alt="一文搞懂redis"></p><h4 id="set数据结构" tabindex="-1"><a class="header-anchor" href="#set数据结构" aria-hidden="true">#</a> Set数据结构</h4><p>Redis 的集合相当于Java中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合Set类型底层编码包括hashtable和inset。</p><p>当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合intset来实现set这种数据类型：</p><ul><li>存储的数据都是整数</li><li>存储的数据元素个数小于512个</li></ul><p>当不能同时满足这两个条件的时候，Redis 就使用dict来存储集合中的数据</p><p>hashtable在上面介绍过了，我们就只介绍inset。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span>
    <span class="token comment">// length就是数组的实际长度</span>
    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>
    <span class="token comment">// contents 数组是实际保存元素的地方，数组中的元素有以下两个特性：</span>
    <span class="token comment">// 1.没有重复元素</span>
    <span class="token comment">// 2.元素在数组中从小到大排列</span>
    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> intset<span class="token punctuation">;</span>

<span class="token comment">// encoding 的值可以是以下三个常量的其中一个</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INTSET_ENC_INT16</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">int16_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INTSET_ENC_INT32</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INTSET_ENC_INT64</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">int64_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>inset的查询</p><p>intset是一个有序集合，查找元素的复杂度为O(logN)（采用二分法），但插入时不一定为O(logN)，因为有可能涉及到升级操作。比如当集合里全是int16_t型的整数，这时要插入一个int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成int32_t类型，涉及到内存的重新分配，这时插入的复杂度就为O(N)了。是intset不支持降级操作。</p><p><strong>inset是有序不要和我们zset搞混，zset是设置一个score来进行排序，而inset这里只是单纯的对整数进行升序而已</strong></p><h4 id="zset数据结构" tabindex="-1"><a class="header-anchor" href="#zset数据结构" aria-hidden="true">#</a> Zset数据结构</h4><p>Zset有序集合和set集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数，作为排序的依据。</p><p>zet的底层编码有两种数据结构，一个ziplist，一个是skiplist。</p><p>Zset也使用了ziplist做了排序，所以下面讲一下ziplist如何做排序。</p><p><strong>ziplist做排序</strong></p><p>每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p><p>存储结构图如下一目了然：</p><p><img src="/assets/4fc80b617b5c4456a03b300e277d76d3.53127f9b.png" alt="一文搞懂redis"></p><p><strong>skiplist跳表</strong></p><p>结构体如下，skiplist是与dict结合来使用的，这个结构比较复杂。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*
 * 跳跃表
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>
    <span class="token comment">// 头节点，尾节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token comment">// 节点数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>
    <span class="token comment">// 目前表内节点的最大层数</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>

<span class="token comment">/*
 * 跳跃表节点
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>
    <span class="token comment">// member 对象</span>
    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>
    <span class="token comment">// 分值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token comment">// 后退指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>
    <span class="token comment">// 层</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>
        <span class="token comment">// 前进指针</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>
        <span class="token comment">// 这个层跨越的节点数量</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跳表是什么？</p><p>我们先看下链表</p><p><img src="/assets/aebaf3e9f44541a7a68f4442005c8611.3ca1299c.png" alt="一文搞懂redis"></p><p>如果想查找到node5需要从node1查到node5，查询耗时</p><p>但如果在node上加上索引：</p><p><img src="/assets/2e9614b46995452d89ff095ee9db7745.4f783dc6.png" alt="一文搞懂redis"></p><p>这样通过索引就能直接从node1查找到node5</p><p><strong>redis跳跃表</strong></p><p>让我们再看下redis的跳表结构（图太复杂，直接从网上找了张图说明）</p><p><img src="/assets/968c457844024f969274793ff36ed69c.931dce0d.jpeg" alt="一文搞懂redis"></p><ul><li>header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)；</li><li>tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)；</li><li>level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数；</li><li>length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</li></ul><p>结构右方的是四个 zskiplistNode结构,该结构包含以下属性</p><ul><li>层(level):</li></ul><p>节点中用L1、L2、L3等字样标记节点的各个层,L1代表第一层,L2代表第二层,以此类推。</p><p>每个层都带有两个属性:前进指针和跨度。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。</p><p>每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</p><ul><li>后退(backward)指针：</li></ul><p>节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。</p><ul><li>分值(score):</li></ul><p>各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</p><ul><li>成员对象(oj):</li></ul><p>各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p><h2 id="redis-特殊数据类型" tabindex="-1"><a class="header-anchor" href="#redis-特殊数据类型" aria-hidden="true">#</a> Redis 特殊数据类型</h2><h4 id="geospatial-地理位置" tabindex="-1"><a class="header-anchor" href="#geospatial-地理位置" aria-hidden="true">#</a> geospatial（地理位置）</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.geospatial将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。
  这些数据将会存储到sorted set这样的目的是为了方便使用GEORADIUS或者GEORADIUSBYMEMBER命令对数据进行半径查询等操作。
2.sorted set使用一种称为Geohash的技术进行填充。经度和纬度的位是交错的，以形成一个独特的52位整数。
  sorted set的double score可以代表一个52位的整数，而不会失去精度。（有兴趣的同学可以学习一下Geohash技术，使用二分法构建唯一的二进制串）
3.有效的经度是-180度到180度
  有效的纬度是-85.05112878度到85.05112878度
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><ol><li>查看附近的人</li><li>微信位置共享</li><li>地图上直线距离的展示</li></ol><h4 id="hyperloglog-基数" tabindex="-1"><a class="header-anchor" href="#hyperloglog-基数" aria-hidden="true">#</a> Hyperloglog（基数）</h4><p>什么是基数？ 不重复的元素</p><p>hyperloglog 是用来做基数统计的，其优点是：输入的提及无论多么大，hyperloglog使用的空间总是固定的12KB ，利用12KB，它可以计算2^64个不同元素的基数！非常节省空间！但缺点是估算的值，可能存在误差</p><p><strong>应用场景</strong></p><p>网页统计UV （浏览用户数量，同一天同一个ip多次访问算一次访问，目的是计数，而不是保存用户）</p><p>传统的方式，set保存用户的id，可以统计set中元素数量作为标准判断。</p><p>但如果这种方式保存大量用户id，会占用大量内存，我们的目的是为了计数，而不是去保存id。</p><h4 id="bitmaps-位图" tabindex="-1"><a class="header-anchor" href="#bitmaps-位图" aria-hidden="true">#</a> BitMaps（位图）</h4><p>Redis提供的Bitmaps这个“数据结构”可以实现对位的操作。Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。</p><p>可以把Bitmaps想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在bitmaps中叫做偏移量。单个bitmaps的最大长度是512MB，即2^32个比特位。</p><p><strong>应用场景</strong></p><p>两种状态的统计都可以使用bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。</p><h2 id="redis-应用" tabindex="-1"><a class="header-anchor" href="#redis-应用" aria-hidden="true">#</a> Redis 应用</h2><h4 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h4><p>Reference：</p><p><a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html" target="_blank" rel="noopener noreferrer">Redis实现分布式锁的7种方案，及正确使用姿势！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h5 id="什么是分布式锁" tabindex="-1"><a class="header-anchor" href="#什么是分布式锁" aria-hidden="true">#</a> 什么是分布式锁</h5><p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p><p>我们先来看下，一把靠谱的分布式锁应该有哪些特征：</p><p><img src="/assets/640.4c019642.png" alt="图片"></p><ul><li><strong>「互斥性」</strong>: 任意时刻，只有一个客户端能持有锁。</li><li><strong>「锁超时释放」</strong>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li><li><strong>「可重入性」</strong>:一个线程如果获取了锁之后,可以再次对其请求加锁。</li><li><strong>「高性能和高可用」</strong>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li><li><strong>「安全性」</strong>：锁只能被持有的客户端删除，不能被其他客户端删除</li></ul><h5 id="redis分布式锁方案一-setnx-expire" tabindex="-1"><a class="header-anchor" href="#redis分布式锁方案一-setnx-expire" aria-hidden="true">#</a> Redis分布式锁方案一：SETNX + EXPIRE</h5><p>提到Redis的分布式锁，很多小伙伴马上就会想到<code>setnx</code>+ <code>expire</code>命令。即先用<code>setnx</code>来抢锁，如果抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放。</p><p>SETNX 是SET IF NOT EXISTS的简写.日常命令格式是SETNX key value，如果 key不存在，则SETNX成功返回1，如果这个key已经存在了，则返回0。</p><p>假设某电商网站的某商品做秒杀活动，key可以设置为key_resource_id,value设置任意值，伪代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span>lock_value<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    expire（key_resource_id，<span class="token number">100</span>）<span class="token punctuation">;</span> <span class="token comment">//设置过期时间</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务请求</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这个方案中，<code>setnx</code>和<code>expire</code>两个命令分开了，<strong>「不是原子操作」</strong>。如果执行完<code>setnx</code>加锁，正要执行<code>expire</code>设置过期时间时，进程crash或者要重启维护了，那么这个锁就“长生不老”了，<strong>「别的线程永远获取不到锁啦」</strong>。</p><h5 id="redis分布式锁方案二-setnx-value值是-系统时间-过期时间" tabindex="-1"><a class="header-anchor" href="#redis分布式锁方案二-setnx-value值是-系统时间-过期时间" aria-hidden="true">#</a> Redis分布式锁方案二：SETNX + value值是(系统时间+过期时间)</h5><p>为了解决方案一，<strong>「发生异常锁得不到释放的场景」</strong>，有小伙伴认为，可以把过期时间放到<code>setnx</code>的value值里面。如果加锁失败，再拿出value值校验一下即可。加锁代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">long</span> expires <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> expireTime<span class="token punctuation">;</span> <span class="token comment">//系统时间+设置的过期时间</span>
<span class="token class-name">String</span> expiresStr <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>expires<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果当前锁不存在，返回加锁成功</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> expiresStr<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token comment">// 如果锁已经存在，获取锁的过期时间</span>
<span class="token class-name">String</span> currentValueStr <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>currentValueStr <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>currentValueStr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

     <span class="token comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span>
    <span class="token class-name">String</span> oldValueStr <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">getSet</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> expiresStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValueStr <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> oldValueStr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>currentValueStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span>
         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
        
<span class="token comment">//其他情况，均返回加锁失败</span>
<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方案的优点是，巧妙移除<code>expire</code>单独设置过期时间的操作，把**「过期时间放到setnx的value值」**里面来。解决了方案一发生异常，锁得不到释放的问题。但是这个方案还有别的缺点：</p><ul><li>过期时间是客户端自己生成的（System.currentTimeMillis()是当前系统的时间），必须要求分布式环境下，每个客户端的时间必须同步。</li><li>如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖</li><li>该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。</li></ul><h5 id="redis分布式锁方案三-使用lua脚本-包含setnx-expire两条指令" tabindex="-1"><a class="header-anchor" href="#redis分布式锁方案三-使用lua脚本-包含setnx-expire两条指令" aria-hidden="true">#</a> Redis分布式锁方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</h5><p>实际上，我们还可以使用Lua脚本来保证原子性（包含setnx和expire两条指令），lua脚本如下：</p><div class="language-lua ext-lua line-numbers-mode"><pre class="language-lua"><code><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;setnx&#39;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">then</span>
   redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;expire&#39;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
   <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加锁代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> lua_scripts <span class="token operator">=</span> <span class="token string">&quot;if redis.call(&#39;setnx&#39;,KEYS[1],ARGV[1]) == 1 then&quot;</span> <span class="token operator">+</span>
            <span class="token string">&quot; redis.call(&#39;expire&#39;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span><span class="token punctuation">;</span>   
<span class="token class-name">Object</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>lua_scripts<span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//判断是否成功</span>
<span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方案，跟方案二对比，你觉得哪个更好呢？</p><h5 id="redis分布式锁方案四-set的扩展命令-set-ex-px-nx" tabindex="-1"><a class="header-anchor" href="#redis分布式锁方案四-set的扩展命令-set-ex-px-nx" aria-hidden="true">#</a> Redis分布式锁方案四：SET的扩展命令（SET EX PX NX）</h5><p>除了使用Lua脚本，保证<code>SETNX + EXPIRE</code>两条指令的原子性，我们还可以巧用Redis的SET指令扩展参数！（<code>SET key value[EX seconds][PX milliseconds][NX|XX]</code>），它也是原子性的！</p><blockquote><p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p><ul><li>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。</li><li>XX: 仅当key存在时设置值</li><li>EX seconds :设定key的过期时间，时间单位是秒。</li><li>PX milliseconds: 设定key的过期时间，单位为毫秒</li></ul></blockquote><p>伪代码demo如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> lock_value<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;EX&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务处理</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是呢，这个方案还是可能存在问题：</p><ul><li>问题一：<strong>「锁过期释放了，业务还没执行完」</strong>。假设线程a获取锁成功，一直在执行临界区的代码。但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。</li><li>问题二：<strong>「锁被别的线程误删」</strong>。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完呢。</li></ul><h5 id="redis分布式锁方案五-set-ex-px-nx-校验唯一随机值-再删除" tabindex="-1"><a class="header-anchor" href="#redis分布式锁方案五-set-ex-px-nx-校验唯一随机值-再删除" aria-hidden="true">#</a> Redis分布式锁方案五：SET EX PX NX + 校验唯一随机值,再删除</h5><p>既然锁可能被别的线程误删，那我们给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下，不就OK了嘛。伪代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span>（jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">,</span> uni_request_id<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;EX&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>）<span class="token punctuation">{</span> <span class="token comment">//加锁</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> something  <span class="token comment">//业务处理</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       <span class="token comment">//判断是不是当前线程加的锁,是才释放</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>uni_request_id<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key_resource_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，**「判断是不是当前线程加的锁」<strong>和</strong>「释放锁」**不是一个原子操作。如果调用jedis.del()释放锁的时候，可能这把锁已经不属于当前客户端，会解除他人加的锁。</p><p>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</p><div class="language-lua ext-lua line-numbers-mode"><pre class="language-lua"><code><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span> 
   <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;del&#39;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token keyword">else</span>
   <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="redis分布式锁方案六-redisson框架" tabindex="-1"><a class="header-anchor" href="#redis分布式锁方案六-redisson框架" aria-hidden="true">#</a> Redis分布式锁方案六：Redisson框架</h5><p>方案五还是可能存在**「锁过期释放，业务没执行完」**的问题。有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实我们设想一下，是否可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p><p>当前开源框架Redisson解决了这个问题。我们一起来看下Redisson底层原理图吧：</p><img src="/assets/640-16499885861892.e6eb6f25.png" alt="图片" style="zoom:67%;"><p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了**「锁过期释放，业务没执行完」**问题。</p><h5 id="redis分布式锁方案七-多机实现的分布式锁redlock-redisson" tabindex="-1"><a class="header-anchor" href="#redis分布式锁方案七-多机实现的分布式锁redlock-redisson" aria-hidden="true">#</a> Redis分布式锁方案七：多机实现的分布式锁Redlock+Redisson</h5><p>前面六种方案都只是基于单机版的讨论，还不是很完美。其实Redis一般都是集群部署的：</p><p><img src="/assets/640-16499886511974.f5c2f697.png" alt="图片"></p><p>如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p><p>为了解决这个问题，Redis作者 antirez提出一种高级的分布式锁算法：Redlock。Redlock核心思想是这样的：搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p><p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。</p><img src="/assets/640-16499887218806.b9be8cf6.png" alt="图片" style="zoom:67%;"><p>RedLock的实现步骤:如下</p><ul><li>1.获取当前时间，以毫秒为单位。</li><li>2.按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</li><li>3.客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+4m0s+50ms）</li><li>如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</li><li>如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</li></ul><p>简化下步骤就是：</p><ul><li>按顺序向5个master节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该master节点。</li><li>如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li><li>如果获取锁失败，解锁！</li></ul><h2 id="redis事物" tabindex="-1"><a class="header-anchor" href="#redis事物" aria-hidden="true">#</a> Redis事物</h2><p>事务本质：一组命令的集合</p><h4 id="数据库事务与redis事务" tabindex="-1"><a class="header-anchor" href="#数据库事务与redis事务" aria-hidden="true">#</a> 数据库事务与redis事务</h4><p><strong>数据库事物</strong></p><p>数据库事务通过ACID（原子性、一致性、隔离性、持久性）来保证。</p><p>数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条SQL语句在被执行的时候，都会生成一条撤销日志(Undo Log)。</p><p><strong>Redis事物</strong></p><p>redis事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p><p>Redis中一个事务从开始到执行会经历开始事务（muiti）、命令入队和执行事务(exec)三个阶段，事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><p>一组命令中存在两种错误不同处理方式</p><p>1.代码语法错误（编译时异常）所有命令都不执行</p><p>2.代码逻辑错误（运行时错误），其他命令可以正常执行 （该点不保证事务的原子性）</p><p>为什么redis不支持回滚来保证原子性</p><p>这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p><h4 id="事务监控" tabindex="-1"><a class="header-anchor" href="#事务监控" aria-hidden="true">#</a> 事务监控</h4><p>悲观锁：认为什么时候都会出现问题，无论做什么操作都会加锁。</p><p>乐观锁：认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据。</p><p>使用cas实现乐观锁</p><p>redis使用watch key监控指定数据，相当于加乐观锁</p><p>watch保证事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</p><p>watch执行流程</p><p><img src="/assets/e1c88c595d6f4b52aa70e4cb820241e2.604c7427.jpeg" alt="一文搞懂redis"></p><h2 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化" aria-hidden="true">#</a> Redis持久化</h2><p>Redis是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题Redis供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失 两种持久化方式：快照（RDB文件）和追加式文件（AOF文件），下面分别为大家介绍两种方式的原理。</p><ul><li>RDB持久化方式会在一个特定的间隔保存那个时间点的数据快照。</li><li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</li><li>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</li></ul><p>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</p><h4 id="rdb持久化" tabindex="-1"><a class="header-anchor" href="#rdb持久化" aria-hidden="true">#</a> RDB持久化</h4><p>RDB持久化产生的文件是一个经过压缩的二进制文件，这个文件可以被保存到硬盘中，可以通过这个文件还原数据库的状态，它可以手动执行，也可以在redis.conf配置文件中配置，定时执行。</p><h5 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h5><p>在进行RDB时，redis的主进程不会做io操作，会fork一个子进程来完成该操作：</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求)</p><h5 id="触发机制" tabindex="-1"><a class="header-anchor" href="#触发机制" aria-hidden="true">#</a> 触发机制</h5><p>在Redis中RDB持久化的触发分为两种：自己手动触发与自动触发。</p><p>主动触发</p><ol><li>save命令是同步的命令，会占用主进程，会造成阻塞，阻塞所有客户端的请求</li><li>bgsave</li></ol><p>bgsave是异步进行，进行持久化的时候，redis还可以将继续响应客户端请求</p><p>bgsave和save对比</p><p><img src="/assets/e67f73aa4c3c447e90f5c6eea09fde63.54661eac.png" alt="一文搞懂redis"></p><p>自动触发</p><p>1、save自动触发配置，见下面配置，满足m秒内修改n次key，触发rdb</p><div class="language-properties ext-properties line-numbers-mode"><pre class="language-properties"><code><span class="token comment"># 时间策略   save m n m秒内修改n次key，触发rdb</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">900 1</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">300 10</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">60 10000</span>

<span class="token comment"># 文件名称</span>
<span class="token key attr-name">dbfilename</span> <span class="token value attr-value">dump.rdb</span>

<span class="token comment"># 文件保存路径</span>
<span class="token key attr-name">dir</span> <span class="token value attr-value">/home/work/app/redis/data/</span>

<span class="token comment"># 如果持久化出错，主进程是否停止写入</span>
<span class="token key attr-name">stop-writes-on-bgsave-error</span> <span class="token value attr-value">yes</span>

<span class="token comment"># 是否压缩</span>
<span class="token key attr-name">rdbcompression</span> <span class="token value attr-value">yes</span>

<span class="token comment"># 导入时是否检查</span>
<span class="token key attr-name">rdbchecksum</span> <span class="token value attr-value">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发bgsave命令；</p><p>3、执行flushall命令，会触发rdb</p><p>4、退出redis，且没有开启aof时</p><h5 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h5><p>优点：</p><p>1、RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</p><p>2、RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</p><p>3、RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</p><p>4、与 AOF 格式的文件相比，RDB 文件可以更快的重启。</p><p>缺点：</p><p>1、因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据。</p><p>2、RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</p><h4 id="aof持久化-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof持久化-append-only-file" aria-hidden="true">#</a> AOF持久化（Append Only File）</h4><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p><strong>AOF配置项</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code># 默认不开启aof  而是使用rdb的方式
appendonly no

# 默认文件名
appendfilename &quot;appendonly.aof&quot;

# 每次修改都会sync 消耗性能
# appendfsync always
# 每秒执行一次 sync 可能会丢失这一秒的数据
appendfsync everysec
# 不执行 sync ,这时候操作系统自己同步数据，速度最快
# appendfsync no 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是appendfsync everysec 配置，会有1s损耗），第二步是对aof文件的重写。</p><h5 id="aof-重写机制" tabindex="-1"><a class="header-anchor" href="#aof-重写机制" aria-hidden="true">#</a> AOF 重写机制</h5><p>随着Redis的运行，AOF的日志会越来越长，如果实例宕机重启，那么重放整个AOF将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr一千次，那么就不需要去记录这1000次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写。</p><p>Redis 提供了bgrewriteaof指令用于对AOF日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的AOF文件，至此完成。</p><p>同样的也可以在redis.config中对重写机制的触发进行配置：</p><p>通过将no-appendfsync-on-rewrite设置为yes，开启重写机制； auto-aof-rewrite-percentage 100意为比上次从写后文件大小增长了100%再次触发重写；</p><p>auto-aof-rewrite-min-size 64mb意为当文件至少要达到64mb才会触发制动重写。</p><h5 id="触发方式" tabindex="-1"><a class="header-anchor" href="#触发方式" aria-hidden="true">#</a> 触发方式</h5><ol><li>手动触发：bgrewriteaof</li><li>自动触发 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</li></ol><h5 id="优缺点-1" tabindex="-1"><a class="header-anchor" href="#优缺点-1" aria-hidden="true">#</a> 优缺点</h5><p>优点</p><p>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p><p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p><p>缺点</p><p>1、AOF 文件比 RDB 文件大，且恢复速度慢。</p><p>2、数据集大的时候，比 rdb 启动效率低。</p><h4 id="rdb与aof对比" tabindex="-1"><a class="header-anchor" href="#rdb与aof对比" aria-hidden="true">#</a> RDB与AOF对比</h4><p><img src="/assets/5e6d76532b9b49b9806cbeef39dae908.f03a4e29.png" alt="一文搞懂redis"></p><h2 id="redis-集群模式" tabindex="-1"><a class="header-anchor" href="#redis-集群模式" aria-hidden="true">#</a> Redis 集群模式</h2><p>https://segmentfault.com/a/1190000022808576</p><p>Redis集群模式主要有三种形式：</p><ul><li>主从复制模式</li><li>哨兵模式</li><li>Cluster模式</li></ul><h3 id="redis主从复制" tabindex="-1"><a class="header-anchor" href="#redis主从复制" aria-hidden="true">#</a> Redis主从复制</h3><p>什么是主从复制</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。
2.前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点
默认情况下，每台redis服务器都是主节点；且一个主节点可以有多个从节点（或者没有），但一个从节点只有一个主
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主从复制的作用主要包括</p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><p>主从库采用的是读写分离的方式</p><p><img src="/assets/4f9e3ed3754b4876ad6f73556ab72b8a.1e961a5e.png" alt="一文搞懂redis"></p><p><strong>1 原理</strong></p><p>分为全量复制与增量复制</p><p>全量复制：发生在第一次复制时</p><p>增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库</p><p><strong>2 全量复制的三个阶段</strong></p><p>第一阶段是主从库间建立连接、协商同步的过程。</p><p>主要是为全量复制做准备。从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p><p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</p><p>第二阶段，主库将所有数据同步给从库。</p><p>从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p><p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p><p>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</p><p>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p><h3 id="哨兵机制" tabindex="-1"><a class="header-anchor" href="#哨兵机制" aria-hidden="true">#</a> 哨兵机制</h3><p>哨兵的核心功能是主节点的自动故障转移</p><p>下图是一个典型的哨兵集群监控的逻辑图</p><p><img src="/assets/5a1ea619c5c040d3b535f60dcb8824f0.19dd3567.jpeg" alt="一文搞懂redis"></p><p>Redis Sentinel包含了若个Sentinel节点，这样做也带来了两个好处：</p><ol><li>对于节点的故障判断是由多个Sentinel节点共同完成，这样可以有效地防止误判</li><li>即使个别Sentinel节点不可用，整个Sentinel集群依然是可用的。</li></ol><p>哨兵实现了一下功能</p><ol><li>监控：每个Sentinel节点会对数据节点（Redis master/slave 节点）和其余Sentinel节点进行监控</li><li>通知：Sentinel节点会将故障转移的结果通知给应用方</li><li>故障转移：实现slave晋升为master，并维护后续正确的主从关系</li><li>配置中心：在Redis Sentinel模式中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息</li></ol><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置中心和通知功能，则需要在与客户端的交互中才能体现。</p><p><strong>1 原理</strong></p><p><strong>监控</strong></p><p>Sentinel节点需要监控master、slave以及其它Sentinel节点的状态。这一过程是通过Redis的pub/sub系统实现的。Redis Sentinel一共有三个定时监控任务，完成对各个节点发现和监控：</p><ol><li>监控主从拓扑信息：每隔10秒，每个Sentinel节点，会向master和slave发送INFO命令获取最新的拓扑结构</li><li>Sentinel节点信息交换：每隔2秒，每个Sentinel节点，会向Redis数据节点的__sentinel__:hello频道上，发送自身的信息，以及对主节点的判断信息。这样，Sentinel节点之间就可以交换信息</li><li>节点状态监控：每隔1秒，每个Sentinel节点，会向master、slave、其余Sentinel节点发送PING命令做心跳检测，来确认这些节点当前是否可达</li></ol><p><strong>主观/客观下线</strong></p><p>主观下线</p><p>每个Sentinel节点，每隔1秒会对数据节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复时，Sentinel节点会对该节点做失败判定，这个行为叫做主观下线。</p><p>客观下线</p><p>客观下线，是指当大多数Sentinel节点，都认为master节点宕机了，那么这个判定就是客观的，叫做客观下线。</p><p>那么这个大多数是指多少呢？这其实就是分布式协调中的quorum判定了，大多数就是过半数，比如哨兵数量是5，那么大多数就是5/2+1=3个，哨兵数量是10大多数就是10/2+1=6个。</p><p>注：Sentinel节点的数量至少为3个，否则不满足quorum判定条件。</p><p><strong>哨兵选举</strong></p><p>如果发生了客观下线，那么哨兵节点会选举出一个Leader来进行实际的故障转移工作。Redis使用了Raft算法来实现哨兵领导者选举，大致思路如下：</p><ol><li>每个Sentinel节点都有资格成为领导者，当它主观认为某个数据节点宕机后，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求自己成为领导者；</li><li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinelis-master-down-by-addr命令，将同意该请求，否则拒绝（每个Sentinel节点只有1票）；</li><li>如果该Sentinel节点发现自己的票数已经大于等于MAX(quorum, num(sentinels)/2+1)，那么它将成为领导者；</li><li>如果此过程没有选举出领导者，将进入下一次选举。</li></ol><p><strong>故障转移</strong></p><p>选举出的Leader Sentinel节点将负责故障转移，也就是进行master/slave节点的主从切换。故障转移，首先要从slave节点中筛选出一个作为新的master，主要考虑以下slave信息：</p><ol><li>跟master断开连接的时长：如果一个slave跟master的断开连接时长已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么该slave就被认为不适合选举为master；</li><li>slave的优先级配置：slave priority参数值越小，优先级就越高；</li><li>复制offset：当优先级相同时，哪个slave复制了越多的数据（offset越靠后），优先级越高；</li><li>run id：如果offset和优先级都相同，则哪个slave的run id越小，优先级越高。</li></ol><p>接着，筛选完slave后， 会对它执行slaveof no one命令，让其成为主节点。</p><p>最后，Sentinel领导者节点会向剩余的slave节点发送命令，让它们成为新的master节点的从节点，复制规则与parallel-syncs参数有关。</p><p>Sentinel节点集合会将原来的master节点更新为slave节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</p><p>注：Leader Sentinel节点，会从新的master节点那里得到一个configuration epoch，本质是个version版本号，每次主从切换的version号都必须是唯一的。其他的哨兵都是根据version来更新自己的master配置。</p><h3 id="cluster" tabindex="-1"><a class="header-anchor" href="#cluster" aria-hidden="true">#</a> Cluster</h3><h2 id="redis发布订阅模型" tabindex="-1"><a class="header-anchor" href="#redis发布订阅模型" aria-hidden="true">#</a> Redis发布订阅模型</h2><p>redis发布与订阅是一种消息通信的模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p><p>redis通过PUBLISH和SUBSCRIBE等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是订阅/发布到频道、订阅/发布到模式的客户端。</p><p><strong>1 频道（channel）</strong></p><p><strong>订阅</strong></p><p><img src="/assets/e9dbe0ed62194c7fbb1c0ca3431637c9.7c3b566e.png" alt="一文搞懂redis"></p><p><strong>发布</strong></p><p><img src="/assets/5228f7d3a5644991b43200d4070fd66c.60c25423.png" alt="一文搞懂redis"></p><p><strong>完整流程</strong></p><p>发布者发布消息</p><p>发布者向频道channel:1发布消息hi</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>127.0.0.1:6379&gt; publish channel:1 hi
(integer) 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>订阅者订阅消息</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>127.0.0.1:6379&gt; subscribe channel:1
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot; // 消息类型
2) &quot;channel:1&quot; // 频道
3) &quot;hi&quot; // 消息内容
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行subscribe后客户端会进入订阅状态，仅可以使subscribe、unsubscribe、psubscribe和punsubscribe这四个属于&quot;发布/订阅&quot;之外的命令</p><p>订阅频道后的客户端可能会收到三种消息类型</p><ul><li>subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li><li>message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li><li>unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非&quot;发布/订阅&quot;模式的命令了。</li></ul><p><strong>数据结构</strong></p><p>基于频道的发布订阅模式是通过字典数据类型实现的</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>struct redisServer {
    // ...
    dict *pubsub_channels;
    // ...
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src="/assets/ee3fcfccd9fe443faa8e475aed823a71.72452d73.jpeg" alt="一文搞懂redis"></p><p>订阅</p><p>当使用subscribe订阅时，在字典中找到频道key（如没有则创建），并将订阅的client关联在链表后面。</p><p>当client 10执行subscribe channel1 channel2 channel3时，会将client 10分别加到 channel1 channel2 channel3关联的链表尾部。</p><p><img src="/assets/e86a4f63816e48fabfeb4f2f8cee41c8.220e8397.png" alt="一文搞懂redis"></p><p>发布</p><p>发布时，根据key，找到字典汇总key的地址，然后将msg发送到关联的链表每一台机器。</p><p>退订</p><p>遍历关联的链表，将指定的地址删除即可。</p><p><strong>2 模式（pattern）</strong></p><p>pattern使用了通配符的方式来订阅</p><p>通配符中?表示1个占位符，*表示任意个占位符(包括0)，?*表示1个以上占位符。</p><p>所以当使用 publish命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个/某些模式和这个频道匹配的话， 那么所有订阅这个/这些频道的客户端也同样会收到信息。</p><p><img src="/assets/fce4dfcb7f884384a94944aad14fb395.950499af.png" alt="一文搞懂redis"></p><p>订阅发布完整流程</p><p>发布者发布消息</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> publish b m1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> publish b1 m1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> publish b11 m1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>订阅者订阅消息</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> psubscribe b*
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;psubscribe&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b*&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;pmessage&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b*&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;m1&quot;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;pmessage&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b*&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;b1&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;m1&quot;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;pmessage&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;b*&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;b11&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;m1&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数据结构</strong></p><p>pattern属性是一个链表，链表中保存着所有和模式相关的信息。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 链表中的每一个节点结构如下，保存着客户端与模式信息</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pubsubPattern</span> <span class="token punctuation">{</span>
    redisClient <span class="token operator">*</span>client<span class="token punctuation">;</span>
    robj <span class="token operator">*</span>pattern<span class="token punctuation">;</span>
<span class="token punctuation">}</span> pubsubPattern<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据结构图如下：</p><img src="/assets/68f2322a746c4d9db5374f8e362eba5a.c89a739d.png" alt="一文搞懂redis" style="zoom:67%;"><p>订阅</p><p>当有信的订阅时，会将订阅的客户端和模式信息添加到链表后面。</p><img src="/assets/757356ff137c4448a3a4901558811fed.86db9bad.png" alt="一文搞懂redis" style="zoom:67%;"><p>发布</p><p>当发布者发布消息时，首先会发送到对应的频道上，在遍历模式列表，根据key匹配模式，匹配成功将消息发给对应的订阅者。</p><p>完成的发布伪代码如下</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 遍历所有订阅频道 channel 的客户端</span>
    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment"># 将信息发送给它们</span>
        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
    <span class="token comment"># 取出所有模式，以及订阅模式的客户端</span>
    <span class="token keyword">for</span> pattern<span class="token punctuation">,</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">:</span>
        <span class="token comment"># 如果 channel 和模式匹配</span>
        <span class="token keyword">if</span> <span class="token keyword">match</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 那么也将信息发给订阅这个模式的客户端</span>
            send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>退订</p><p>使用punsubscribe，可以将订阅者退订，将改客户端移除出链表。</p><h3 id="redis常见问题" tabindex="-1"><a class="header-anchor" href="#redis常见问题" aria-hidden="true">#</a> Redis常见问题</h3><h4 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h4><p><strong>问题来源</strong></p><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><p>如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p><strong>解决方案</strong></p><p>1、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</p><p>2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</p><p>3、布隆过滤器。类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小。</p><h4 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h4><p><strong>问题来源</strong></p><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p><p><strong>解决方案</strong></p><p>1、设置热点数据永远不过期。</p><p>2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</p><p>3、加互斥锁</p><h4 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h4><p><strong>问题来源</strong></p><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p><strong>解决方案</strong></p><p>1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p><p>2、如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</p><p>3、设置热点数据永远不过期</p><h2 id="redis-常见面试题" tabindex="-1"><a class="header-anchor" href="#redis-常见面试题" aria-hidden="true">#</a> Redis 常见面试题</h2><ol><li><p>说一下你在项目中的redis的应用场景</p><ul><li>5大value类型，</li><li>缓存， 加速查询</li><li>为的是服务无状态，延伸思考，看你的项目有哪些数据杰克狗会对象，在单机需要锁，需要分布式锁，抽出来放到redis</li><li>无锁化</li></ul></li><li><p>redis是单线程还是多线程</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>无论是什么版本，工作线程就是一个
6.x 高版本出现了IO多线程
使用上来说，是没什么变化的
去学一下系统IO课程(选修)    --  netty
单线程，满足redis的串行原子，只不过IO多线程后，把输入/输出放到更多下的线程里去并行， 1. 执行时间缩短，更快。2,更好的压着系统及硬件的资源
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>​ 客户端被读取的顺序不能被保障，那个顺序是可以被保障的？在一个连接里，socket里</p><ol start="3"><li><p>redis存在线程安全问题么？为什么？</p></li><li><p>遇到过缓存穿透么？</p><p>DB里没有数据，缓存肯定没有，就会造成请求透传到DB</p></li></ol><p>​ 数据库是架构的瓶颈，有效的请求到达数据库，即便放大前置环节的复杂度和成本</p><p>​ 如何解决？ ​ 锁</p><ol start="5"><li><p>遇到过缓存击穿么？ redis没有换缓存，DB存在数据，瞬时出现大量并发请求</p><p>锁</p></li><li><p>如何避免缓存雪崩</p><p>大量热点key过期</p></li><li><p>Redis是怎么删除过期Key的？</p></li><li><p>缓存如何回收的</p><p>​ 1。后台轮询，分段分批的删除哪些过期的key</p><ol start="2"><li><p>请求的时候判断是否已经过期</p><p>尽量的吧内存无用空间回收回来</p></li></ol></li><li><p>缓存如何淘汰？</p><p>内存空间不足的情况下</p><p>淘汰机制里有不允许淘汰</p><p>lru/lfu/random/ttl</p><p>全空间</p><p>设置过过期key的集合中</p></li><li><p>如何进行缓存预热？</p><p>​</p><p>​ -</p></li><li><p>数据库与缓存不一致，如何解决？</p></li><li><p>简述一下主从不一致问题？</p></li><li><p>描述一下redis持久化原理</p></li><li><p>Redis也扛不住了，万级流量会打到DB上，如何处理？</p></li><li><p>Redis有哪些持久化方式</p></li></ol></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 895252461@qq.com">诗人都藏在水底</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/middleware/redis/redis-cluster.html" class="" aria-label="Redis Cluster"><!--[--><!--]--> Redis Cluster <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.02d01547.js" defer></script>
  </body>
</html>
